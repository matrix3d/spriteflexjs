/**
 * Generated by Apache Royale Compiler from Box2D/Collision/IBroadPhase.as
 * Box2D.Collision.IBroadPhase
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.IBroadPhase');
/* Royale Dependency List: Box2D.Collision.b2AABB,Box2D.Collision.b2RayCastInput,Box2D.Common.Math.b2Vec2*/




/**
 * @interface
 */
Box2D.Collision.IBroadPhase = function() {
};
/**
 * Create a proxy with an initial AABB. Pairs are not reported until
 * UpdatePairs is called.
 * @param {Box2D.Collision.b2AABB} aabb
 * @param {*} userData
 * @return {*}
 */
Box2D.Collision.IBroadPhase.prototype.CreateProxy = function(aabb, userData) {
};
/**
 * Destroy a proxy. It is up to the client to remove any pairs.
 * @param {*} proxy
 */
Box2D.Collision.IBroadPhase.prototype.DestroyProxy = function(proxy) {
};
/**
 * Call MoveProxy as many times as you like, then when you are done
 * call UpdatePairs to finalized the proxy pairs (for your time step).
 * @param {*} proxy
 * @param {Box2D.Collision.b2AABB} aabb
 * @param {Box2D.Common.Math.b2Vec2} displacement
 */
Box2D.Collision.IBroadPhase.prototype.MoveProxy = function(proxy, aabb, displacement) {
};
/**
 * @param {*} proxyA
 * @param {*} proxyB
 * @return {boolean}
 */
Box2D.Collision.IBroadPhase.prototype.TestOverlap = function(proxyA, proxyB) {
};
/**
 * Get user data from a proxy. Returns null if the proxy is invalid.
 * @param {*} proxy
 * @return {*}
 */
Box2D.Collision.IBroadPhase.prototype.GetUserData = function(proxy) {
};
/**
 * Get the fat AABB for a proxy.
 * @param {*} proxy
 * @return {Box2D.Collision.b2AABB}
 */
Box2D.Collision.IBroadPhase.prototype.GetFatAABB = function(proxy) {
};
/**
 * Get the number of proxies.
 * @return {number}
 */
Box2D.Collision.IBroadPhase.prototype.GetProxyCount = function() {
};
/**
 * Update the pairs. This results in pair callbacks. This can only add pairs.
 * @param {Function} callback
 */
Box2D.Collision.IBroadPhase.prototype.UpdatePairs = function(callback) {
};
/**
 * Query an AABB for overlapping proxies. The callback class
 * is called with each proxy that overlaps 
 * the supplied AABB, and return a Boolean indicating if 
 * the broaphase should proceed to the next match.
 * @asparam callback This function should be a function matching signature
 * <code>function Callback(proxy:*):Boolean</code>
 * @param {Function} callback
 * @param {Box2D.Collision.b2AABB} aabb
 */
Box2D.Collision.IBroadPhase.prototype.Query = function(callback, aabb) {
};
/**
 * Ray-cast  agains the proxies in the tree. This relies on the callback
 * to perform exact ray-cast in the case where the proxy contains a shape
 * The callback also performs any collision filtering
 * @asparam callback This function should be a function matching signature
 * <code>function Callback(subInput:b2RayCastInput, proxy:*):Number</code>
 * Where the returned number is the new value for maxFraction
 * @param {Function} callback
 * @param {Box2D.Collision.b2RayCastInput} input
 */
Box2D.Collision.IBroadPhase.prototype.RayCast = function(callback, input) {
};
Box2D.Collision.IBroadPhase.prototype.Validate = function() {
};
/**
 * Give the broadphase a chance for structural optimizations
 * @param {number} iterations
 */
Box2D.Collision.IBroadPhase.prototype.Rebalance = function(iterations) {
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.IBroadPhase.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'IBroadPhase', qName: 'Box2D.Collision.IBroadPhase', kind: 'interface' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.IBroadPhase.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'CreateProxy': { type: '*', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'*', false ]; }},
        'DestroyProxy': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ '*', false ]; }},
        'MoveProxy': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ '*', false ,'Box2D.Collision.b2AABB', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'TestOverlap': { type: 'Boolean', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ '*', false ,'*', false ]; }},
        'GetUserData': { type: '*', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ '*', false ]; }},
        'GetFatAABB': { type: 'Box2D.Collision.b2AABB', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ '*', false ]; }},
        'GetProxyCount': { type: 'int', declaredBy: 'Box2D.Collision.IBroadPhase'},
        'UpdatePairs': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ 'Function', false ]; }},
        'Query': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ 'Function', false ,'Box2D.Collision.b2AABB', false ]; }},
        'RayCast': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ 'Function', false ,'Box2D.Collision.b2RayCastInput', false ]; }},
        'Validate': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase'},
        'Rebalance': { type: 'void', declaredBy: 'Box2D.Collision.IBroadPhase', parameters: function () { return [ 'int', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.IBroadPhase.prototype.ROYALE_COMPILE_FLAGS = 9;
