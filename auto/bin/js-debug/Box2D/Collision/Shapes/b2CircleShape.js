/**
 * Generated by Apache Royale Compiler from Box2D/Collision/Shapes/b2CircleShape.as
 * Box2D.Collision.Shapes.b2CircleShape
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.Shapes.b2CircleShape');
/* Royale Dependency List: Box2D.Collision.Shapes.b2MassData,Box2D.Collision.b2AABB,Box2D.Collision.b2RayCastInput,Box2D.Collision.b2RayCastOutput,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings,org.apache.royale.utils.Language*/

goog.require('Box2D.Collision.Shapes.b2Shape');



/**
 * @constructor
 * @extends {Box2D.Collision.Shapes.b2Shape}
 * @param {number=} radius
 */
Box2D.Collision.Shapes.b2CircleShape = function(radius) {
  radius = typeof radius !== 'undefined' ? radius : 0;
  
  this.m_p = new Box2D.Common.Math.b2Vec2();
  Box2D.Collision.Shapes.b2CircleShape.base(this, 'constructor');
  this.m_type = Box2D.Collision.Shapes.b2Shape.e_circleShape;
  this.m_radius = radius;
};
goog.inherits(Box2D.Collision.Shapes.b2CircleShape, Box2D.Collision.Shapes.b2Shape);


/**
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.Copy = function() {
  var /** @type {Box2D.Collision.Shapes.b2Shape} */ s = new Box2D.Collision.Shapes.b2CircleShape();
  s.Set(this);
  return s;
};


/**
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.Set = function(other) {
  Box2D.Collision.Shapes.b2CircleShape.superClass_.Set.apply(this, [ other] );
  if (org.apache.royale.utils.Language.is(other, Box2D.Collision.Shapes.b2CircleShape)) {
    var /** @type {Box2D.Collision.Shapes.b2CircleShape} */ other2 = other;
    this.m_p.SetV(other2.m_p);
  }
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.TestPoint = function(transform, p) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = transform.R;
  var /** @type {number} */ dX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var /** @type {number} */ dY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  dX = p.x - dX;
  dY = p.y - dY;
  return (dX * dX + dY * dY) <= this.m_radius * this.m_radius;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.RayCast = function(output, input, transform) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = transform.R;
  var /** @type {number} */ positionX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var /** @type {number} */ positionY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  var /** @type {number} */ sX = input.p1.x - positionX;
  var /** @type {number} */ sY = input.p1.y - positionY;
  var /** @type {number} */ b = (sX * sX + sY * sY) - this.m_radius * this.m_radius;
  var /** @type {number} */ rX = input.p2.x - input.p1.x;
  var /** @type {number} */ rY = input.p2.y - input.p1.y;
  var /** @type {number} */ c = (sX * rX + sY * rY);
  var /** @type {number} */ rr = (rX * rX + rY * rY);
  var /** @type {number} */ sigma = c * c - rr * b;
  if (sigma < 0.0 || rr < Number.MIN_VALUE) {
    return false;
  }
  var /** @type {number} */ a = -(c + Math.sqrt(sigma));
  if (0.0 <= a && a <= input.maxFraction * rr) {
    a /= rr;
    output.fraction = a;
    output.normal.x = sX + a * rX;
    output.normal.y = sY + a * rY;
    output.normal.Normalize();
    return true;
  }
  return false;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeAABB = function(aabb, transform) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = transform.R;
  var /** @type {number} */ pX = transform.position.x + (tMat.col1.x * this.m_p.x + tMat.col2.x * this.m_p.y);
  var /** @type {number} */ pY = transform.position.y + (tMat.col1.y * this.m_p.x + tMat.col2.y * this.m_p.y);
  aabb.lowerBound.Set(pX - this.m_radius, pY - this.m_radius);
  aabb.upperBound.Set(pX + this.m_radius, pY + this.m_radius);
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = density * Box2D.Common.b2Settings.b2_pi * this.m_radius * this.m_radius;
  massData.center.SetV(this.m_p);
  massData.I = massData.mass * (0.5 * this.m_radius * this.m_radius + (this.m_p.x * this.m_p.x + this.m_p.y * this.m_p.y));
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ p = Box2D.Common.Math.b2Math.MulX(xf, this.m_p);
  var /** @type {number} */ l = -(Box2D.Common.Math.b2Math.Dot(normal, p) - offset);
  if (l < -this.m_radius + Number.MIN_VALUE) {
    return 0;
  }
  if (l > this.m_radius) {
    c.SetV(p);
    return Math.PI * this.m_radius * this.m_radius;
  }
  var /** @type {number} */ r2 = this.m_radius * this.m_radius;
  var /** @type {number} */ l2 = l * l;
  var /** @type {number} */ area = r2 * (Math.asin(l / this.m_radius) + Math.PI / 2) + l * Math.sqrt(r2 - l2);
  var /** @type {number} */ com = -2 / 3 * Math.pow(r2 - l2, 1.5) / area;
  c.x = p.x + normal.x * com;
  c.y = p.y + normal.y * com;
  return area;
};


/**
 * Get the local position of this circle in its parent body.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.GetLocalPosition = function() {
  return this.m_p;
};


/**
 * Set the local position of this circle in its parent body.
 * @param {Box2D.Common.Math.b2Vec2} position
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.SetLocalPosition = function(position) {
  this.m_p.SetV(position);
};


/**
 * Get the radius of the circle
 * @return {number}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.GetRadius = function() {
  return this.m_radius;
};


/**
 * Set the radius of the circle
 * @param {number} radius
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.SetRadius = function(radius) {
  this.m_radius = radius;
};


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.m_p = null;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2CircleShape', qName: 'Box2D.Collision.Shapes.b2CircleShape', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_p': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2CircleShape */ inst, /** * */ v) {return v !== undefined ? inst.m_p = v : inst.m_p;}}
      };
    },
    methods: function () {
      return {
        'Copy': { type: 'Box2D.Collision.Shapes.b2Shape', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape'},
        'Set': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2Shape', false ]; }},
        'TestPoint': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCast': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Collision.b2RayCastOutput', false ,'Box2D.Collision.b2RayCastInput', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeAABB': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeMass': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', false ,'Number', false ]; }},
        'ComputeSubmergedArea': { type: 'Number', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Number', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLocalPosition': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape'},
        'SetLocalPosition': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetRadius': { type: 'Number', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape'},
        'SetRadius': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Number', false ]; }},
        'b2CircleShape': { type: '', declaredBy: 'Box2D.Collision.Shapes.b2CircleShape', parameters: function () { return [ 'Number', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.Shapes.b2CircleShape.prototype.ROYALE_COMPILE_FLAGS = 9;
