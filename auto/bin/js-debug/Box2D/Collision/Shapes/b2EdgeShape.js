/**
 * Generated by Apache Royale Compiler from Box2D/Collision/Shapes/b2EdgeShape.as
 * Box2D.Collision.Shapes.b2EdgeShape
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.Shapes.b2EdgeShape');
/* Royale Dependency List: Box2D.Collision.Shapes.b2MassData,Box2D.Collision.b2AABB,Box2D.Collision.b2RayCastInput,Box2D.Collision.b2RayCastOutput,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings*/

goog.require('Box2D.Collision.Shapes.b2Shape');



/**
 * @asprivate
 * @constructor
 * @extends {Box2D.Collision.Shapes.b2Shape}
 * @param {Box2D.Common.Math.b2Vec2} v1
 * @param {Box2D.Common.Math.b2Vec2} v2
 */
Box2D.Collision.Shapes.b2EdgeShape = function(v1, v2) {
  
  this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec = new Box2D.Common.Math.b2Vec2();
  this.m_v1 = new Box2D.Common.Math.b2Vec2();
  this.m_v2 = new Box2D.Common.Math.b2Vec2();
  this.m_coreV1 = new Box2D.Common.Math.b2Vec2();
  this.m_coreV2 = new Box2D.Common.Math.b2Vec2();
  this.m_normal = new Box2D.Common.Math.b2Vec2();
  this.m_direction = new Box2D.Common.Math.b2Vec2();
  this.m_cornerDir1 = new Box2D.Common.Math.b2Vec2();
  this.m_cornerDir2 = new Box2D.Common.Math.b2Vec2();
  Box2D.Collision.Shapes.b2EdgeShape.base(this, 'constructor');
  this.m_type = Box2D.Collision.Shapes.b2Shape.e_edgeShape;
  this.m_prevEdge = null;
  this.m_nextEdge = null;
  this.m_v1 = v1;
  this.m_v2 = v2;
  this.m_direction.Set(this.m_v2.x - this.m_v1.x, this.m_v2.y - this.m_v1.y);
  this.m_length = this.m_direction.Normalize();
  this.m_normal.Set(this.m_direction.y, -this.m_direction.x);
  this.m_coreV1.Set(-Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.x - this.m_direction.x) + this.m_v1.x, -Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.y - this.m_direction.y) + this.m_v1.y);
  this.m_coreV2.Set(-Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.x + this.m_direction.x) + this.m_v2.x, -Box2D.Common.b2Settings.b2_toiSlop * (this.m_normal.y + this.m_direction.y) + this.m_v2.y);
  this.m_cornerDir1 = this.m_normal;
  this.m_cornerDir2.Set(-this.m_normal.x, -this.m_normal.y);
};
goog.inherits(Box2D.Collision.Shapes.b2EdgeShape, Box2D.Collision.Shapes.b2Shape);


/**
 * Returns false. Edges cannot contain points. 
 * @override
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.TestPoint = function(transform, p) {
  return false;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.RayCast = function(output, input, transform) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {number} */ rX = input.p2.x - input.p1.x;
  var /** @type {number} */ rY = input.p2.y - input.p1.y;
  tMat = transform.R;
  var /** @type {number} */ v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var /** @type {number} */ v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var /** @type {number} */ nX = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y) - v1Y;
  var /** @type {number} */ nY = -(transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y) - v1X);
  var /** @type {number} */ k_slop = 100.0 * Number.MIN_VALUE;
  var /** @type {number} */ denom = -(rX * nX + rY * nY);
  if (denom > k_slop) {
    var /** @type {number} */ bX = input.p1.x - v1X;
    var /** @type {number} */ bY = input.p1.y - v1Y;
    var /** @type {number} */ a = (bX * nX + bY * nY);
    if (0.0 <= a && a <= input.maxFraction * denom) {
      var /** @type {number} */ mu2 = -rX * bY + rY * bX;
      if (-k_slop * denom <= mu2 && mu2 <= denom * (1.0 + k_slop)) {
        a /= denom;
        output.fraction = a;
        var /** @type {number} */ nLen = Math.sqrt(nX * nX + nY * nY);
        output.normal.x = nX / nLen;
        output.normal.y = nY / nLen;
        return true;
      }
    }
  }
  return false;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeAABB = function(aabb, transform) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = transform.R;
  var /** @type {number} */ v1X = transform.position.x + (tMat.col1.x * this.m_v1.x + tMat.col2.x * this.m_v1.y);
  var /** @type {number} */ v1Y = transform.position.y + (tMat.col1.y * this.m_v1.x + tMat.col2.y * this.m_v1.y);
  var /** @type {number} */ v2X = transform.position.x + (tMat.col1.x * this.m_v2.x + tMat.col2.x * this.m_v2.y);
  var /** @type {number} */ v2Y = transform.position.y + (tMat.col1.y * this.m_v2.x + tMat.col2.y * this.m_v2.y);
  if (v1X < v2X) {
    aabb.lowerBound.x = v1X;
    aabb.upperBound.x = v2X;
  } else {
    aabb.lowerBound.x = v2X;
    aabb.upperBound.x = v1X;
  }
  if (v1Y < v2Y) {
    aabb.lowerBound.y = v1Y;
    aabb.upperBound.y = v2Y;
  } else {
    aabb.lowerBound.y = v2Y;
    aabb.upperBound.y = v1Y;
  }
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeMass = function(massData, density) {
  massData.mass = 0;
  massData.center.SetV(this.m_v1);
  massData.I = 0;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ v0 = new Box2D.Common.Math.b2Vec2(normal.x * offset, normal.y * offset);
  var /** @type {Box2D.Common.Math.b2Vec2} */ v1 = Box2D.Common.Math.b2Math.MulX(xf, this.m_v1);
  var /** @type {Box2D.Common.Math.b2Vec2} */ v2 = Box2D.Common.Math.b2Math.MulX(xf, this.m_v2);
  var /** @type {number} */ d1 = Box2D.Common.Math.b2Math.Dot(normal, v1) - offset;
  var /** @type {number} */ d2 = Box2D.Common.Math.b2Math.Dot(normal, v2) - offset;
  if (d1 > 0) {
    if (d2 > 0) {
      return 0;
    } else {
      v1.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v1.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y;
    }
  } else {
    if (d2 > 0) {
      v2.x = -d2 / (d1 - d2) * v1.x + d1 / (d1 - d2) * v2.x;
      v2.y = -d2 / (d1 - d2) * v1.y + d1 / (d1 - d2) * v2.y;
    } else {
    }
  }
  c.x = (v0.x + v1.x + v2.x) / 3;
  c.y = (v0.y + v1.y + v2.y) / 3;
  return 0.5 * ((v1.x - v0.x) * (v2.y - v0.y) - (v1.y - v0.y) * (v2.x - v0.x));
};


/**
 * Get the distance from vertex1 to vertex2.
 * @return {number}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetLength = function() {
  return this.m_length;
};


/**
 * Get the local position of vertex1 in parent body.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex1 = function() {
  return this.m_v1;
};


/**
 * Get the local position of vertex2 in parent body.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetVertex2 = function() {
  return this.m_v2;
};


/**
 * Get a core vertex in local coordinates. These vertices
 * represent a smaller edge that is used for time of impact
 * computations.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex1 = function() {
  return this.m_coreV1;
};


/**
 * Get a core vertex in local coordinates. These vertices
 * represent a smaller edge that is used for time of impact
 * computations.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCoreVertex2 = function() {
  return this.m_coreV2;
};


/**
 * Get a perpendicular unit vector, pointing
 * from the solid side to the empty side.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetNormalVector = function() {
  return this.m_normal;
};


/**
 * Get a parallel unit vector, pointing
 * from vertex1 to vertex2.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetDirectionVector = function() {
  return this.m_direction;
};


/**
 * Returns a unit vector halfway between 
 * m_direction and m_prevEdge.m_direction.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner1Vector = function() {
  return this.m_cornerDir1;
};


/**
 * Returns a unit vector halfway between 
 * m_direction and m_nextEdge.m_direction.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetCorner2Vector = function() {
  return this.m_cornerDir2;
};


/**
 * Returns true if the first corner of this edge
 * bends towards the solid side.
 * @return {boolean}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Corner1IsConvex = function() {
  return this.m_cornerConvex1;
};


/**
 * Returns true if the second corner of this edge
 * bends towards the solid side. 
 * @return {boolean}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Corner2IsConvex = function() {
  return this.m_cornerConvex2;
};


/**
 * Get the first vertex and apply the supplied transform.
 * @param {Box2D.Common.Math.b2Transform} xf
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetFirstVertex = function(xf) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = xf.R;
  return new Box2D.Common.Math.b2Vec2(xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y), xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y));
};


/**
 * Get the next edge in the chain.
 * @return {Box2D.Collision.Shapes.b2EdgeShape}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetNextEdge = function() {
  return this.m_nextEdge;
};


/**
 * Get the previous edge in the chain.
 * @return {Box2D.Collision.Shapes.b2EdgeShape}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.GetPrevEdge = function() {
  return this.m_prevEdge;
};


/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec = null;


/**
 * Get the support point in the given world direction.
 * Use the supplied transform.
 * @param {Box2D.Common.Math.b2Transform} xf
 * @param {number} dX
 * @param {number} dY
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.Support = function(xf, dX, dY) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = xf.R;
  var /** @type {number} */ v1X = xf.position.x + (tMat.col1.x * this.m_coreV1.x + tMat.col2.x * this.m_coreV1.y);
  var /** @type {number} */ v1Y = xf.position.y + (tMat.col1.y * this.m_coreV1.x + tMat.col2.y * this.m_coreV1.y);
  var /** @type {number} */ v2X = xf.position.x + (tMat.col1.x * this.m_coreV2.x + tMat.col2.x * this.m_coreV2.y);
  var /** @type {number} */ v2Y = xf.position.y + (tMat.col1.y * this.m_coreV2.x + tMat.col2.y * this.m_coreV2.y);
  if ((v1X * dX + v1Y * dY) > (v2X * dX + v2Y * dY)) {
    this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec.x = v1X;
    this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec.y = v1Y;
  } else {
    this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec.x = v2X;
    this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec.y = v2Y;
  }
  return this.Box2D_Collision_Shapes_b2EdgeShape_s_supportVec;
};


/**
 * @asprivate
 * @param {Box2D.Collision.Shapes.b2EdgeShape} edge
 * @param {Box2D.Common.Math.b2Vec2} core
 * @param {Box2D.Common.Math.b2Vec2} cornerDir
 * @param {boolean} convex
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.SetPrevEdge = function(edge, core, cornerDir, convex) {
  this.m_prevEdge = edge;
  this.m_coreV1 = core;
  this.m_cornerDir1 = cornerDir;
  this.m_cornerConvex1 = convex;
};


/**
 * @asprivate
 * @param {Box2D.Collision.Shapes.b2EdgeShape} edge
 * @param {Box2D.Common.Math.b2Vec2} core
 * @param {Box2D.Common.Math.b2Vec2} cornerDir
 * @param {boolean} convex
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.SetNextEdge = function(edge, core, cornerDir, convex) {
  this.m_nextEdge = edge;
  this.m_coreV2 = core;
  this.m_cornerDir2 = cornerDir;
  this.m_cornerConvex2 = convex;
};


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_v1 = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_v2 = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_coreV1 = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_coreV2 = null;


/**
 * @type {number}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_length = NaN;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_normal = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_direction = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_cornerDir1 = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_cornerDir2 = null;


/**
 * @type {boolean}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_cornerConvex1 = false;


/**
 * @type {boolean}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_cornerConvex2 = false;


/**
 * @type {Box2D.Collision.Shapes.b2EdgeShape}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_nextEdge = null;


/**
 * @type {Box2D.Collision.Shapes.b2EdgeShape}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.m_prevEdge = null;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2EdgeShape', qName: 'Box2D.Collision.Shapes.b2EdgeShape', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_v1': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_v1 = v : inst.m_v1;}},
        'm_v2': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_v2 = v : inst.m_v2;}},
        'm_coreV1': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_coreV1 = v : inst.m_coreV1;}},
        'm_coreV2': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_coreV2 = v : inst.m_coreV2;}},
        'm_length': { type: 'Number', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_length = v : inst.m_length;}},
        'm_normal': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_normal = v : inst.m_normal;}},
        'm_direction': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_direction = v : inst.m_direction;}},
        'm_cornerDir1': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_cornerDir1 = v : inst.m_cornerDir1;}},
        'm_cornerDir2': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_cornerDir2 = v : inst.m_cornerDir2;}},
        'm_cornerConvex1': { type: 'Boolean', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_cornerConvex1 = v : inst.m_cornerConvex1;}},
        'm_cornerConvex2': { type: 'Boolean', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_cornerConvex2 = v : inst.m_cornerConvex2;}},
        'm_nextEdge': { type: 'Box2D.Collision.Shapes.b2EdgeShape', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_nextEdge = v : inst.m_nextEdge;}},
        'm_prevEdge': { type: 'Box2D.Collision.Shapes.b2EdgeShape', get_set: function (/** Box2D.Collision.Shapes.b2EdgeShape */ inst, /** * */ v) {return v !== undefined ? inst.m_prevEdge = v : inst.m_prevEdge;}}
      };
    },
    methods: function () {
      return {
        'TestPoint': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCast': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Collision.b2RayCastOutput', false ,'Box2D.Collision.b2RayCastInput', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeAABB': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeMass': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', false ,'Number', false ]; }},
        'ComputeSubmergedArea': { type: 'Number', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Number', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLength': { type: 'Number', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetVertex1': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetVertex2': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetCoreVertex1': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetCoreVertex2': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetNormalVector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetDirectionVector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetCorner1Vector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetCorner2Vector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'Corner1IsConvex': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'Corner2IsConvex': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetFirstVertex': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ]; }},
        'GetNextEdge': { type: 'Box2D.Collision.Shapes.b2EdgeShape', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'GetPrevEdge': { type: 'Box2D.Collision.Shapes.b2EdgeShape', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape'},
        'Support': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ,'Number', false ,'Number', false ]; }},
        'b2EdgeShape': { type: '', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'SetPrevEdge': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2EdgeShape', false ,'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ,'Boolean', false ]; }},
        'SetNextEdge': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2EdgeShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2EdgeShape', false ,'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ,'Boolean', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.Shapes.b2EdgeShape.prototype.ROYALE_COMPILE_FLAGS = 9;
