/**
 * Generated by Apache Royale Compiler from Box2D/Collision/Shapes/b2PolygonShape.as
 * Box2D.Collision.Shapes.b2PolygonShape
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.Shapes.b2PolygonShape');
/* Royale Dependency List: Box2D.Collision.Shapes.b2MassData,Box2D.Collision.b2AABB,Box2D.Collision.b2OBB,Box2D.Collision.b2RayCastInput,Box2D.Collision.b2RayCastOutput,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings,org.apache.royale.utils.Language*/

goog.require('Box2D.Collision.Shapes.b2Shape');



/**
 * @asprivate
 * @constructor
 * @extends {Box2D.Collision.Shapes.b2Shape}
 */
Box2D.Collision.Shapes.b2PolygonShape = function() {
  Box2D.Collision.Shapes.b2PolygonShape.base(this, 'constructor');
  this.m_type = Box2D.Collision.Shapes.b2Shape.e_polygonShape;
  this.m_centroid = new Box2D.Common.Math.b2Vec2();
  this.m_vertices = new Array();
  this.m_normals = new Array();
};
goog.inherits(Box2D.Collision.Shapes.b2PolygonShape, Box2D.Collision.Shapes.b2Shape);


/**
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Copy = function() {
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ s = new Box2D.Collision.Shapes.b2PolygonShape();
  s.Set(this);
  return s;
};


/**
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Set = function(other) {
  Box2D.Collision.Shapes.b2PolygonShape.superClass_.Set.apply(this, [ other] );
  if (org.apache.royale.utils.Language.is(other, Box2D.Collision.Shapes.b2PolygonShape)) {
    var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ other2 = other;
    this.m_centroid.SetV(other2.m_centroid);
    this.m_vertexCount = other2.m_vertexCount;
    this.Box2D_Collision_Shapes_b2PolygonShape_Reserve(this.m_vertexCount);
    for (var /** @type {number} */ i = 0; i < this.m_vertexCount; i++) {
      this.m_vertices[i].SetV(other2.m_vertices[i]);
      this.m_normals[i].SetV(other2.m_normals[i]);
    }
  }
};


/**
 * Copy vertices. This assumes the vertices define a convex polygon.
 * It is assumed that the exterior is the the right of each edge.
 * @param {Array} vertices
 * @param {number=} vertexCount
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsArray = function(vertices, vertexCount) {
  vertexCount = typeof vertexCount !== 'undefined' ? vertexCount : 0;
  var /** @type {Array} */ v = new Array();
  var foreachiter0_target = vertices;
  for (var foreachiter0 in foreachiter0_target) 
  {
  var tVec = foreachiter0_target[foreachiter0];
  {
    v.push(tVec);
  }}
  
  this.SetAsVector(v, vertexCount);
};


/**
 * @nocollapse
 * @param {Array} vertices
 * @param {number} vertexCount
 * @return {Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.AsArray = function(vertices, vertexCount) {
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygonShape = new Box2D.Collision.Shapes.b2PolygonShape();
  polygonShape.SetAsArray(vertices, vertexCount);
  return polygonShape;
};


/**
 * Copy vertices. This assumes the vertices define a convex polygon.
 * It is assumed that the exterior is the the right of each edge.
 * @param {Array} vertices
 * @param {number=} vertexCount
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsVector = function(vertices, vertexCount) {
  vertexCount = typeof vertexCount !== 'undefined' ? vertexCount : 0;
  var /** @type {number} */ i = 0;
  if (vertexCount == 0)
    vertexCount = vertices.length;
  Box2D.Common.b2Settings.b2Assert(2 <= vertexCount);
  this.m_vertexCount = (vertexCount) >> 0;
  this.Box2D_Collision_Shapes_b2PolygonShape_Reserve((vertexCount) >> 0);
  //var /** @type {number} */ i = 0;
  for (i = 0; i < this.m_vertexCount; i++) {
    this.m_vertices[i].SetV(vertices[i]);
  }
  for (i = 0; i < this.m_vertexCount; ++i) {
    var /** @type {number} */ i1 = i;
    var /** @type {number} */ i2 = (i + 1 < this.m_vertexCount ? i + 1 : 0) >> 0;
    var /** @type {Box2D.Common.Math.b2Vec2} */ edge = Box2D.Common.Math.b2Math.SubtractVV(/* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i2], Box2D.Common.Math.b2Vec2, true), /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i1], Box2D.Common.Math.b2Vec2, true));
    Box2D.Common.b2Settings.b2Assert(edge.LengthSquared() > Number.MIN_VALUE);
    this.m_normals[i].SetV(Box2D.Common.Math.b2Math.CrossVF(edge, 1.0));
    this.m_normals[i].Normalize();
  }
  this.m_centroid = Box2D.Collision.Shapes.b2PolygonShape.ComputeCentroid(this.m_vertices, (this.m_vertexCount) >>> 0);
};


/**
 * @nocollapse
 * @param {Array} vertices
 * @param {number} vertexCount
 * @return {Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.AsVector = function(vertices, vertexCount) {
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygonShape = new Box2D.Collision.Shapes.b2PolygonShape();
  polygonShape.SetAsVector(vertices, vertexCount);
  return polygonShape;
};


/**
 * Build vertices to represent an axis-aligned box.
 * @asparam hx the half-width.
 * @asparam hy the half-height.
 * @param {number} hx
 * @param {number} hy
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsBox = function(hx, hy) {
  this.m_vertexCount = 4;
  this.Box2D_Collision_Shapes_b2PolygonShape_Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0.0, -1.0);
  this.m_normals[1].Set(1.0, 0.0);
  this.m_normals[2].Set(0.0, 1.0);
  this.m_normals[3].Set(-1.0, 0.0);
  this.m_centroid.SetZero();
};


/**
 * @nocollapse
 * @param {number} hx
 * @param {number} hy
 * @return {Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.AsBox = function(hx, hy) {
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygonShape = new Box2D.Collision.Shapes.b2PolygonShape();
  polygonShape.SetAsBox(hx, hy);
  return polygonShape;
};


Box2D.Collision.Shapes.b2PolygonShape.get__s_mat = function() {
  var value = new Box2D.Common.Math.b2Mat22();
  Object.defineProperties(Box2D.Collision.Shapes.b2PolygonShape, { s_mat: { value: value, writable: true }});
  return value;
};
Box2D.Collision.Shapes.b2PolygonShape.set__s_mat = function(value) {
  Object.defineProperties(Box2D.Collision.Shapes.b2PolygonShape, { s_mat: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Mat22}
 */
Box2D.Collision.Shapes.b2PolygonShape.s_mat;

Object.defineProperties(Box2D.Collision.Shapes.b2PolygonShape, /** @lends {Box2D.Collision.Shapes.b2PolygonShape} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Mat22}
 */
s_mat: {
  get: Box2D.Collision.Shapes.b2PolygonShape.get__s_mat,
  set: Box2D.Collision.Shapes.b2PolygonShape.set__s_mat,
  configurable: true}});


/**
 * @param {number} hx
 * @param {number} hy
 * @param {Box2D.Common.Math.b2Vec2=} center
 * @param {number=} angle
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsOrientedBox = function(hx, hy, center, angle) {
  center = typeof center !== 'undefined' ? center : null;
  angle = typeof angle !== 'undefined' ? angle : 0.0;
  this.m_vertexCount = 4;
  this.Box2D_Collision_Shapes_b2PolygonShape_Reserve(4);
  this.m_vertices[0].Set(-hx, -hy);
  this.m_vertices[1].Set(hx, -hy);
  this.m_vertices[2].Set(hx, hy);
  this.m_vertices[3].Set(-hx, hy);
  this.m_normals[0].Set(0.0, -1.0);
  this.m_normals[1].Set(1.0, 0.0);
  this.m_normals[2].Set(0.0, 1.0);
  this.m_normals[3].Set(-1.0, 0.0);
  this.m_centroid = center;
  var /** @type {Box2D.Common.Math.b2Transform} */ xf = new Box2D.Common.Math.b2Transform();
  xf.position = center;
  xf.R.Set(angle);
  for (var /** @type {number} */ i = 0; i < this.m_vertexCount; ++i) {
    this.m_vertices[i] = Box2D.Common.Math.b2Math.MulX(xf, /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true));
    this.m_normals[i] = Box2D.Common.Math.b2Math.MulMV(xf.R, /* implicit cast */ org.apache.royale.utils.Language.as(this.m_normals[i], Box2D.Common.Math.b2Vec2, true));
  }
};


/**
 * @nocollapse
 * @param {number} hx
 * @param {number} hy
 * @param {Box2D.Common.Math.b2Vec2=} center
 * @param {number=} angle
 * @return {Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.AsOrientedBox = function(hx, hy, center, angle) {
  center = typeof center !== 'undefined' ? center : null;
  angle = typeof angle !== 'undefined' ? angle : 0.0;
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygonShape = new Box2D.Collision.Shapes.b2PolygonShape();
  polygonShape.SetAsOrientedBox(hx, hy, center, angle);
  return polygonShape;
};


/**
 * Set this as a single edge.
 * @param {Box2D.Common.Math.b2Vec2} v1
 * @param {Box2D.Common.Math.b2Vec2} v2
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.SetAsEdge = function(v1, v2) {
  this.m_vertexCount = 2;
  this.Box2D_Collision_Shapes_b2PolygonShape_Reserve(2);
  this.m_vertices[0].SetV(v1);
  this.m_vertices[1].SetV(v2);
  this.m_centroid.x = 0.5 * (v1.x + v2.x);
  this.m_centroid.y = 0.5 * (v1.y + v2.y);
  this.m_normals[0] = Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(v2, v1), 1.0);
  this.m_normals[0].Normalize();
  this.m_normals[1].x = -this.m_normals[0].x;
  this.m_normals[1].y = -this.m_normals[0].y;
};


/**
 * Set this as a single edge.
 * @nocollapse
 * @param {Box2D.Common.Math.b2Vec2} v1
 * @param {Box2D.Common.Math.b2Vec2} v2
 * @return {Box2D.Collision.Shapes.b2PolygonShape}
 */
Box2D.Collision.Shapes.b2PolygonShape.AsEdge = function(v1, v2) {
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygonShape = new Box2D.Collision.Shapes.b2PolygonShape();
  polygonShape.SetAsEdge(v1, v2);
  return polygonShape;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.TestPoint = function(xf, p) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = xf.R;
  var /** @type {number} */ tX = p.x - xf.position.x;
  var /** @type {number} */ tY = p.y - xf.position.y;
  var /** @type {number} */ pLocalX = (tX * tMat.col1.x + tY * tMat.col1.y);
  var /** @type {number} */ pLocalY = (tX * tMat.col2.x + tY * tMat.col2.y);
  for (var /** @type {number} */ i = 0; i < this.m_vertexCount; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true);
    tX = pLocalX - tVec.x;
    tY = pLocalY - tVec.y;
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_normals[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ dot = (tVec.x * tX + tVec.y * tY);
    if (dot > 0.0) {
      return false;
    }
  }
  return true;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.RayCast = function(output, input, transform) {
  var /** @type {number} */ tX = NaN;
  var /** @type {number} */ tY = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {number} */ lower = 0.0;
  var /** @type {number} */ upper = input.maxFraction;
  //var /** @type {number} */ tX = NaN;
  //var /** @type {number} */ tY = NaN;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  tX = input.p1.x - transform.position.x;
  tY = input.p1.y - transform.position.y;
  tMat = transform.R;
  var /** @type {number} */ p1X = (tX * tMat.col1.x + tY * tMat.col1.y);
  var /** @type {number} */ p1Y = (tX * tMat.col2.x + tY * tMat.col2.y);
  tX = input.p2.x - transform.position.x;
  tY = input.p2.y - transform.position.y;
  tMat = transform.R;
  var /** @type {number} */ p2X = (tX * tMat.col1.x + tY * tMat.col1.y);
  var /** @type {number} */ p2Y = (tX * tMat.col2.x + tY * tMat.col2.y);
  var /** @type {number} */ dX = p2X - p1X;
  var /** @type {number} */ dY = p2Y - p1Y;
  var /** @type {number} */ index = -1;
  for (var /** @type {number} */ i = 0; i < this.m_vertexCount; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true);
    tX = tVec.x - p1X;
    tY = tVec.y - p1Y;
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_normals[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ numerator = (tVec.x * tX + tVec.y * tY);
    var /** @type {number} */ denominator = (tVec.x * dX + tVec.y * dY);
    if (denominator == 0.0) {
      if (numerator < 0.0) {
        return false;
      }
    } else {
      if (denominator < 0.0 && numerator < lower * denominator) {
        lower = numerator / denominator;
        index = i;
      } else if (denominator > 0.0 && numerator < upper * denominator) {
        upper = numerator / denominator;
      }
    }
    if (upper < lower - Number.MIN_VALUE) {
      return false;
    }
  }
  if (index >= 0) {
    output.fraction = lower;
    tMat = transform.R;
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_normals[index], Box2D.Common.Math.b2Vec2, true);
    output.normal.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    output.normal.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    return true;
  }
  return false;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeAABB = function(aabb, xf) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[0], Box2D.Common.Math.b2Vec2, true);
  var /** @type {number} */ lowerX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ lowerY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var /** @type {number} */ upperX = lowerX;
  var /** @type {number} */ upperY = lowerY;
  for (var /** @type {number} */ i = 1; i < this.m_vertexCount; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ vX = xf.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    var /** @type {number} */ vY = xf.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    lowerX = lowerX < vX ? lowerX : vX;
    lowerY = lowerY < vY ? lowerY : vY;
    upperX = upperX > vX ? upperX : vX;
    upperY = upperY > vY ? upperY : vY;
  }
  aabb.lowerBound.x = lowerX - this.m_radius;
  aabb.lowerBound.y = lowerY - this.m_radius;
  aabb.upperBound.x = upperX + this.m_radius;
  aabb.upperBound.y = upperY + this.m_radius;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeMass = function(massData, density) {
  if (this.m_vertexCount == 2) {
    massData.center.x = 0.5 * (this.m_vertices[0].x + this.m_vertices[1].x);
    massData.center.y = 0.5 * (this.m_vertices[0].y + this.m_vertices[1].y);
    massData.mass = 0.0;
    massData.I = 0.0;
    return;
  }
  var /** @type {number} */ centerX = 0.0;
  var /** @type {number} */ centerY = 0.0;
  var /** @type {number} */ area = 0.0;
  var /** @type {number} */ I = 0.0;
  var /** @type {number} */ p1X = 0.0;
  var /** @type {number} */ p1Y = 0.0;
  var /** @type {number} */ k_inv3 = 1.0 / 3.0;
  for (var /** @type {number} */ i = 0; i < this.m_vertexCount; ++i) {
    var /** @type {Box2D.Common.Math.b2Vec2} */ p2 = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {Box2D.Common.Math.b2Vec2} */ p3 = /* implicit cast */ org.apache.royale.utils.Language.as(i + 1 < this.m_vertexCount ? this.m_vertices[org.apache.royale.utils.Language._int(i + 1)] : this.m_vertices[0], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ e1X = p2.x - p1X;
    var /** @type {number} */ e1Y = p2.y - p1Y;
    var /** @type {number} */ e2X = p3.x - p1X;
    var /** @type {number} */ e2Y = p3.y - p1Y;
    var /** @type {number} */ D = e1X * e2Y - e1Y * e2X;
    var /** @type {number} */ triangleArea = 0.5 * D;
    area += triangleArea;
    centerX += triangleArea * k_inv3 * (p1X + p2.x + p3.x);
    centerY += triangleArea * k_inv3 * (p1Y + p2.y + p3.y);
    var /** @type {number} */ px = p1X;
    var /** @type {number} */ py = p1Y;
    var /** @type {number} */ ex1 = e1X;
    var /** @type {number} */ ey1 = e1Y;
    var /** @type {number} */ ex2 = e2X;
    var /** @type {number} */ ey2 = e2Y;
    var /** @type {number} */ intx2 = k_inv3 * (0.25 * (ex1 * ex1 + ex2 * ex1 + ex2 * ex2) + (px * ex1 + px * ex2)) + 0.5 * px * px;
    var /** @type {number} */ inty2 = k_inv3 * (0.25 * (ey1 * ey1 + ey2 * ey1 + ey2 * ey2) + (py * ey1 + py * ey2)) + 0.5 * py * py;
    I += D * (intx2 + inty2);
  }
  massData.mass = density * area;
  centerX *= 1.0 / area;
  centerY *= 1.0 / area;
  massData.center.Set(centerX, centerY);
  massData.I = density * I;
};


/**
 * @inheritDoc
 * @override
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ComputeSubmergedArea = function(normal, offset, xf, c) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ p3 = null;
  var /** @type {number} */ i = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ normalL = Box2D.Common.Math.b2Math.MulTMV(xf.R, normal);
  var /** @type {number} */ offsetL = offset - Box2D.Common.Math.b2Math.Dot(normal, xf.position);
  var /** @type {Array} */ depths = new Array();
  var /** @type {number} */ diveCount = 0;
  var /** @type {number} */ intoIndex = -1;
  var /** @type {number} */ outoIndex = -1;
  var /** @type {boolean} */ lastSubmerged = false;
  //var /** @type {number} */ i = 0;
  for (i = 0; i < this.m_vertexCount; ++i) {
    depths[i] = Box2D.Common.Math.b2Math.Dot(normalL, /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true)) - offsetL;
    var /** @type {boolean} */ isSubmerged = depths[i] < -Number.MIN_VALUE;
    if (i > 0) {
      if (isSubmerged) {
        if (!lastSubmerged) {
          intoIndex = (i - 1) >> 0;
          diveCount++;
        }
      } else {
        if (lastSubmerged) {
          outoIndex = (i - 1) >> 0;
          diveCount++;
        }
      }
    }
    lastSubmerged = isSubmerged;
  }
  switch (diveCount) {
    case 0:
      if (lastSubmerged) {
        var /** @type {Box2D.Collision.Shapes.b2MassData} */ md = new Box2D.Collision.Shapes.b2MassData();
        this.ComputeMass(md, 1);
        c.SetV(Box2D.Common.Math.b2Math.MulX(xf, md.center));
        return md.mass;
      } else {
        return 0;
      }
      break;
    case 1:
      if (intoIndex == -1) {
        intoIndex = (this.m_vertexCount - 1) >> 0;
      } else {
        outoIndex = (this.m_vertexCount - 1) >> 0;
      }
      break;
  }
  var /** @type {number} */ intoIndex2 = ((intoIndex + 1) % this.m_vertexCount) >> 0;
  var /** @type {number} */ outoIndex2 = ((outoIndex + 1) % this.m_vertexCount) >> 0;
  var /** @type {number} */ intoLamdda = (0 - depths[intoIndex]) / (depths[intoIndex2] - depths[intoIndex]);
  var /** @type {number} */ outoLamdda = (0 - depths[outoIndex]) / (depths[outoIndex2] - depths[outoIndex]);
  var /** @type {Box2D.Common.Math.b2Vec2} */ intoVec = new Box2D.Common.Math.b2Vec2(this.m_vertices[intoIndex].x * (1 - intoLamdda) + this.m_vertices[intoIndex2].x * intoLamdda, this.m_vertices[intoIndex].y * (1 - intoLamdda) + this.m_vertices[intoIndex2].y * intoLamdda);
  var /** @type {Box2D.Common.Math.b2Vec2} */ outoVec = new Box2D.Common.Math.b2Vec2(this.m_vertices[outoIndex].x * (1 - outoLamdda) + this.m_vertices[outoIndex2].x * outoLamdda, this.m_vertices[outoIndex].y * (1 - outoLamdda) + this.m_vertices[outoIndex2].y * outoLamdda);
  var /** @type {number} */ area = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ center = new Box2D.Common.Math.b2Vec2();
  var /** @type {Box2D.Common.Math.b2Vec2} */ p2 = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[intoIndex2], Box2D.Common.Math.b2Vec2, true);
  //var /** @type {Box2D.Common.Math.b2Vec2} */ p3 = null;
  i = intoIndex2;
  while (i != outoIndex2) {
    i = ((i + 1) % this.m_vertexCount) >> 0;
    if (i == outoIndex2)
      p3 = outoVec;
    else
      p3 = /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ triangleArea = 0.5 * ((p2.x - intoVec.x) * (p3.y - intoVec.y) - (p2.y - intoVec.y) * (p3.x - intoVec.x));
    area += triangleArea;
    center.x += triangleArea * (intoVec.x + p2.x + p3.x) / 3;
    center.y += triangleArea * (intoVec.y + p2.y + p3.y) / 3;
    p2 = p3;
  }
  center.Multiply(1 / area);
  c.SetV(Box2D.Common.Math.b2Math.MulX(xf, center));
  return area;
};


/**
 * Get the vertex count.
 * @return {number}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetVertexCount = function() {
  return this.m_vertexCount;
};


/**
 * Get the vertices in local coordinates.
 * @return {Array}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetVertices = function() {
  return this.m_vertices;
};


/**
 * Get the edge normal vectors. There is one for each vertex.
 * @return {Array}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetNormals = function() {
  return this.m_normals;
};


/**
 * Get the supporting vertex index in the given direction.
 * @param {Box2D.Common.Math.b2Vec2} d
 * @return {number}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetSupport = function(d) {
  var /** @type {number} */ bestIndex = 0;
  var /** @type {number} */ bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for (var /** @type {number} */ i = 1; i < this.m_vertexCount; ++i) {
    var /** @type {number} */ value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return bestIndex;
};


/**
 * @param {Box2D.Common.Math.b2Vec2} d
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.GetSupportVertex = function(d) {
  var /** @type {number} */ bestIndex = 0;
  var /** @type {number} */ bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for (var /** @type {number} */ i = 1; i < this.m_vertexCount; ++i) {
    var /** @type {number} */ value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[bestIndex], Box2D.Common.Math.b2Vec2, true);
};


/**
 * @private
 * @return {boolean}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Box2D_Collision_Shapes_b2PolygonShape_Validate = function() {
  return false;
};


/**
 * @private
 * @param {number} count
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.Box2D_Collision_Shapes_b2PolygonShape_Reserve = function(count) {
  for (var /** @type {number} */ i = (this.m_vertices.length) >> 0; i < count; i++) {
    this.m_vertices[i] = new Box2D.Common.Math.b2Vec2();
    this.m_normals[i] = new Box2D.Common.Math.b2Vec2();
  }
};


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.m_centroid = null;


/**
 * @type {Array}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.m_vertices = null;


/**
 * @type {Array}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.m_normals = null;


/**
 * @type {number}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.m_vertexCount = 0;


/**
 * Computes the centroid of the given polygon
 * @asparam	vs		vector of b2Vec specifying a polygon
 * @asparam	count	length of vs
 * @asreturn the polygon centroid
 * @nocollapse
 * @param {Array} vs
 * @param {number} count
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.Shapes.b2PolygonShape.ComputeCentroid = function(vs, count) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ c = new Box2D.Common.Math.b2Vec2();
  var /** @type {number} */ area = 0.0;
  var /** @type {number} */ p1X = 0.0;
  var /** @type {number} */ p1Y = 0.0;
  var /** @type {number} */ inv3 = 1.0 / 3.0;
  for (var /** @type {number} */ i = 0; i < count; ++i) {
    var /** @type {Box2D.Common.Math.b2Vec2} */ p2 = /* implicit cast */ org.apache.royale.utils.Language.as(vs[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {Box2D.Common.Math.b2Vec2} */ p3 = /* implicit cast */ org.apache.royale.utils.Language.as(i + 1 < count ? vs[org.apache.royale.utils.Language._int(i + 1)] : vs[0], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ e1X = p2.x - p1X;
    var /** @type {number} */ e1Y = p2.y - p1Y;
    var /** @type {number} */ e2X = p3.x - p1X;
    var /** @type {number} */ e2Y = p3.y - p1Y;
    var /** @type {number} */ D = (e1X * e2Y - e1Y * e2X);
    var /** @type {number} */ triangleArea = 0.5 * D;
    area += triangleArea;
    c.x += triangleArea * inv3 * (p1X + p2.x + p3.x);
    c.y += triangleArea * inv3 * (p1Y + p2.y + p3.y);
  }
  c.x *= 1.0 / area;
  c.y *= 1.0 / area;
  return c;
};


/**
 * Computes a polygon's OBB
 * @see http://www.geometrictools.com/Documentation/MinimumAreaRectangle.pdf
 * @nocollapse
 * @param {Box2D.Collision.b2OBB} obb
 * @param {Array} vs
 * @param {number} count
 */
Box2D.Collision.Shapes.b2PolygonShape.ComputeOBB = function(obb, vs, count) {
  var /** @type {number} */ i = 0;
  //var /** @type {number} */ i = 0;
  var /** @type {Array} */ p = new Array(count + 1);
  for (i = 0; i < count; ++i) {
    p[i] = vs[i];
  }
  p[count] = p[0];
  var /** @type {number} */ minArea = Number.MAX_VALUE;
  for (i = 1; i <= count; ++i) {
    var /** @type {Box2D.Common.Math.b2Vec2} */ root = /* implicit cast */ org.apache.royale.utils.Language.as(p[org.apache.royale.utils.Language._int(i - 1)], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ uxX = p[i].x - root.x;
    var /** @type {number} */ uxY = p[i].y - root.y;
    var /** @type {number} */ length = Math.sqrt(uxX * uxX + uxY * uxY);
    uxX /= length;
    uxY /= length;
    var /** @type {number} */ uyX = -uxY;
    var /** @type {number} */ uyY = uxX;
    var /** @type {number} */ lowerX = Number.MAX_VALUE;
    var /** @type {number} */ lowerY = Number.MAX_VALUE;
    var /** @type {number} */ upperX = -Number.MAX_VALUE;
    var /** @type {number} */ upperY = -Number.MAX_VALUE;
    for (var /** @type {number} */ j = 0; j < count; ++j) {
      var /** @type {number} */ dX = p[j].x - root.x;
      var /** @type {number} */ dY = p[j].y - root.y;
      var /** @type {number} */ rX = (uxX * dX + uxY * dY);
      var /** @type {number} */ rY = (uyX * dX + uyY * dY);
      if (rX < lowerX)
        lowerX = rX;
      if (rY < lowerY)
        lowerY = rY;
      if (rX > upperX)
        upperX = rX;
      if (rY > upperY)
        upperY = rY;
    }
    var /** @type {number} */ area = (upperX - lowerX) * (upperY - lowerY);
    if (area < 0.95 * minArea) {
      minArea = area;
      obb.R.col1.x = uxX;
      obb.R.col1.y = uxY;
      obb.R.col2.x = uyX;
      obb.R.col2.y = uyY;
      var /** @type {number} */ centerX = 0.5 * (lowerX + upperX);
      var /** @type {number} */ centerY = 0.5 * (lowerY + upperY);
      var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = obb.R;
      obb.center.x = root.x + (tMat.col1.x * centerX + tMat.col2.x * centerY);
      obb.center.y = root.y + (tMat.col1.y * centerX + tMat.col2.y * centerY);
      obb.extents.x = 0.5 * (upperX - lowerX);
      obb.extents.y = 0.5 * (upperY - lowerY);
    }
  }
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2PolygonShape', qName: 'Box2D.Collision.Shapes.b2PolygonShape', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_centroid': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.Shapes.b2PolygonShape */ inst, /** * */ v) {return v !== undefined ? inst.m_centroid = v : inst.m_centroid;}},
        'm_vertices': { type: 'Array', get_set: function (/** Box2D.Collision.Shapes.b2PolygonShape */ inst, /** * */ v) {return v !== undefined ? inst.m_vertices = v : inst.m_vertices;}},
        'm_normals': { type: 'Array', get_set: function (/** Box2D.Collision.Shapes.b2PolygonShape */ inst, /** * */ v) {return v !== undefined ? inst.m_normals = v : inst.m_normals;}},
        'm_vertexCount': { type: 'int', get_set: function (/** Box2D.Collision.Shapes.b2PolygonShape */ inst, /** * */ v) {return v !== undefined ? inst.m_vertexCount = v : inst.m_vertexCount;}}
      };
    },
    methods: function () {
      return {
        'Copy': { type: 'Box2D.Collision.Shapes.b2Shape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape'},
        'Set': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2Shape', false ]; }},
        'SetAsArray': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Array', false ,'Number', true ]; }},
        '|AsArray': { type: 'Box2D.Collision.Shapes.b2PolygonShape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Array', false ,'Number', false ]; }},
        'SetAsVector': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Array', false ,'Number', true ]; }},
        '|AsVector': { type: 'Box2D.Collision.Shapes.b2PolygonShape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Array', false ,'Number', false ]; }},
        'SetAsBox': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        '|AsBox': { type: 'Box2D.Collision.Shapes.b2PolygonShape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'SetAsOrientedBox': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Number', false ,'Number', false ,'Box2D.Common.Math.b2Vec2', true ,'Number', true ]; }},
        '|AsOrientedBox': { type: 'Box2D.Collision.Shapes.b2PolygonShape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Number', false ,'Number', false ,'Box2D.Common.Math.b2Vec2', true ,'Number', true ]; }},
        'SetAsEdge': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        '|AsEdge': { type: 'Box2D.Collision.Shapes.b2PolygonShape', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'TestPoint': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCast': { type: 'Boolean', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Collision.b2RayCastOutput', false ,'Box2D.Collision.b2RayCastInput', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeAABB': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'ComputeMass': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', false ,'Number', false ]; }},
        'ComputeSubmergedArea': { type: 'Number', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Number', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetVertexCount': { type: 'int', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape'},
        'GetVertices': { type: 'Array', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape'},
        'GetNormals': { type: 'Array', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape'},
        'GetSupport': { type: 'int', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetSupportVertex': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'b2PolygonShape': { type: '', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape'},
        '|ComputeCentroid': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Array', false ,'uint', false ]; }},
        '|ComputeOBB': { type: 'void', declaredBy: 'Box2D.Collision.Shapes.b2PolygonShape', parameters: function () { return [ 'Box2D.Collision.b2OBB', false ,'Array', false ,'int', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Collision.Shapes.b2PolygonShape.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Collision.Shapes.b2PolygonShape);
