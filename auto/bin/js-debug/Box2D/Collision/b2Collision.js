/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2Collision.as
 * Box2D.Collision.b2Collision
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2Collision');
/* Royale Dependency List: Box2D.Collision.Shapes.b2CircleShape,Box2D.Collision.Shapes.b2PolygonShape,Box2D.Collision.b2AABB,Box2D.Collision.b2Manifold,Box2D.Collision.b2ManifoldPoint,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Transform,Box2D.Common.b2Settings*/
/* Royale Static Dependency List: org.apache.royale.utils.Language,Box2D.Collision.ClipVertex*/

goog.require('Box2D.Collision.ClipVertex');
goog.require('Box2D.Common.Math.b2Vec2');
goog.require('Box2D.Collision.b2ContactID');
goog.require('org.apache.royale.utils.Language');



/**
 * @constructor
 */
Box2D.Collision.b2Collision = function() {
};


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Collision.b2Collision.b2_nullFeature = 0xff;


/**
 * @nocollapse
 * @param {Array} vOut
 * @param {Array} vIn
 * @param {Box2D.Common.Math.b2Vec2} normal
 * @param {number} offset
 * @return {number}
 */
Box2D.Collision.b2Collision.ClipSegmentToLine = function(vOut, vIn, normal, offset) {
  var /** @type {Box2D.Collision.ClipVertex} */ cv = null;
  var /** @type {Box2D.Collision.ClipVertex} */ cv2 = null;
  //var /** @type {Box2D.Collision.ClipVertex} */ cv = null;
  var /** @type {number} */ numOut = 0;
  cv = /* implicit cast */ org.apache.royale.utils.Language.as(vIn[0], Box2D.Collision.ClipVertex, true);
  var /** @type {Box2D.Common.Math.b2Vec2} */ vIn0 = cv.v;
  cv = /* implicit cast */ org.apache.royale.utils.Language.as(vIn[1], Box2D.Collision.ClipVertex, true);
  var /** @type {Box2D.Common.Math.b2Vec2} */ vIn1 = cv.v;
  var /** @type {number} */ distance0 = normal.x * vIn0.x + normal.y * vIn0.y - offset;
  var /** @type {number} */ distance1 = normal.x * vIn1.x + normal.y * vIn1.y - offset;
  if (distance0 <= 0.0)
    vOut[numOut++].Set(vIn[0]);
  if (distance1 <= 0.0)
    vOut[numOut++].Set(vIn[1]);
  if (distance0 * distance1 < 0.0) {
    var /** @type {number} */ interp = distance0 / (distance0 - distance1);
    cv = /* implicit cast */ org.apache.royale.utils.Language.as(vOut[numOut], Box2D.Collision.ClipVertex, true);
    var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = cv.v;
    tVec.x = vIn0.x + interp * (vIn1.x - vIn0.x);
    tVec.y = vIn0.y + interp * (vIn1.y - vIn0.y);
    cv = /* implicit cast */ org.apache.royale.utils.Language.as(vOut[numOut], Box2D.Collision.ClipVertex, true);
    //var /** @type {Box2D.Collision.ClipVertex} */ cv2 = null;
    if (distance0 > 0.0) {
      cv2 = /* implicit cast */ org.apache.royale.utils.Language.as(vIn[0], Box2D.Collision.ClipVertex, true);
      cv.id = cv2.id;
    } else {
      cv2 = /* implicit cast */ org.apache.royale.utils.Language.as(vIn[1], Box2D.Collision.ClipVertex, true);
      cv.id = cv2.id;
    }
    ++numOut;
  }
  return numOut;
};


/**
 * @nocollapse
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly1
 * @param {Box2D.Common.Math.b2Transform} xf1
 * @param {number} edge1
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly2
 * @param {Box2D.Common.Math.b2Transform} xf2
 * @return {number}
 */
Box2D.Collision.b2Collision.EdgeSeparation = function(poly1, xf1, edge1, poly2, xf2) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {number} */ count1 = poly1.m_vertexCount;
  var /** @type {Array} */ vertices1 = poly1.m_vertices;
  var /** @type {Array} */ normals1 = poly1.m_normals;
  var /** @type {number} */ count2 = poly2.m_vertexCount;
  var /** @type {Array} */ vertices2 = poly2.m_vertices;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  tMat = xf1.R;
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(normals1[edge1], Box2D.Common.Math.b2Vec2, true);
  var /** @type {number} */ normal1WorldX = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ normal1WorldY = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  var /** @type {number} */ normal1X = (tMat.col1.x * normal1WorldX + tMat.col1.y * normal1WorldY);
  var /** @type {number} */ normal1Y = (tMat.col2.x * normal1WorldX + tMat.col2.y * normal1WorldY);
  var /** @type {number} */ index = 0;
  var /** @type {number} */ minDot = Number.MAX_VALUE;
  for (var /** @type {number} */ i = 0; i < count2; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices2[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ dot = tVec.x * normal1X + tVec.y * normal1Y;
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices1[edge1], Box2D.Common.Math.b2Vec2, true);
  tMat = xf1.R;
  var /** @type {number} */ v1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ v1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices2[index], Box2D.Common.Math.b2Vec2, true);
  tMat = xf2.R;
  var /** @type {number} */ v2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ v2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  v2X -= v1X;
  v2Y -= v1Y;
  var /** @type {number} */ separation = v2X * normal1WorldX + v2Y * normal1WorldY;
  return separation;
};


/**
 * @nocollapse
 * @param {Array} edgeIndex
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly1
 * @param {Box2D.Common.Math.b2Transform} xf1
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly2
 * @param {Box2D.Common.Math.b2Transform} xf2
 * @return {number}
 */
Box2D.Collision.b2Collision.FindMaxSeparation = function(edgeIndex, poly1, xf1, poly2, xf2) {
  var /** @type {number} */ bestEdge = 0;
  var /** @type {number} */ increment = 0;
  var /** @type {number} */ bestSeparation = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {number} */ count1 = poly1.m_vertexCount;
  var /** @type {Array} */ normals1 = poly1.m_normals;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  tMat = xf2.R;
  tVec = poly2.m_centroid;
  var /** @type {number} */ dX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ dY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf1.R;
  tVec = poly1.m_centroid;
  dX -= xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  dY -= xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var /** @type {number} */ dLocal1X = (dX * xf1.R.col1.x + dY * xf1.R.col1.y);
  var /** @type {number} */ dLocal1Y = (dX * xf1.R.col2.x + dY * xf1.R.col2.y);
  var /** @type {number} */ edge = 0;
  var /** @type {number} */ maxDot = -Number.MAX_VALUE;
  for (var /** @type {number} */ i = 0; i < count1; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(normals1[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ dot = (tVec.x * dLocal1X + tVec.y * dLocal1Y);
    if (dot > maxDot) {
      maxDot = dot;
      edge = i;
    }
  }
  var /** @type {number} */ s = Box2D.Collision.b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
  var /** @type {number} */ prevEdge = (edge - 1 >= 0 ? edge - 1 : count1 - 1) >> 0;
  var /** @type {number} */ sPrev = Box2D.Collision.b2Collision.EdgeSeparation(poly1, xf1, prevEdge, poly2, xf2);
  var /** @type {number} */ nextEdge = (edge + 1 < count1 ? edge + 1 : 0) >> 0;
  var /** @type {number} */ sNext = Box2D.Collision.b2Collision.EdgeSeparation(poly1, xf1, nextEdge, poly2, xf2);
  //var /** @type {number} */ bestEdge = 0;
  //var /** @type {number} */ bestSeparation = NaN;
  //var /** @type {number} */ increment = 0;
  if (sPrev > s && sPrev > sNext) {
    increment = -1;
    bestEdge = prevEdge;
    bestSeparation = sPrev;
  } else if (sNext > s) {
    increment = 1;
    bestEdge = nextEdge;
    bestSeparation = sNext;
  } else {
    edgeIndex[0] = edge;
    return s;
  }
  while (true) {
    if (increment == -1)
      edge = (bestEdge - 1 >= 0 ? bestEdge - 1 : count1 - 1) >> 0;
    else
      edge = (bestEdge + 1 < count1 ? bestEdge + 1 : 0) >> 0;
    s = Box2D.Collision.b2Collision.EdgeSeparation(poly1, xf1, edge, poly2, xf2);
    if (s > bestSeparation) {
      bestEdge = edge;
      bestSeparation = s;
    } else {
      break;
    }
  }
  edgeIndex[0] = bestEdge;
  return bestSeparation;
};


/**
 * @nocollapse
 * @param {Array} c
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly1
 * @param {Box2D.Common.Math.b2Transform} xf1
 * @param {number} edge1
 * @param {Box2D.Collision.Shapes.b2PolygonShape} poly2
 * @param {Box2D.Common.Math.b2Transform} xf2
 */
Box2D.Collision.b2Collision.FindIncidentEdge = function(c, poly1, xf1, edge1, poly2, xf2) {
  var /** @type {Box2D.Collision.ClipVertex} */ tClip = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {number} */ count1 = poly1.m_vertexCount;
  var /** @type {Array} */ normals1 = poly1.m_normals;
  var /** @type {number} */ count2 = poly2.m_vertexCount;
  var /** @type {Array} */ vertices2 = poly2.m_vertices;
  var /** @type {Array} */ normals2 = poly2.m_normals;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  tMat = xf1.R;
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(normals1[edge1], Box2D.Common.Math.b2Vec2, true);
  var /** @type {number} */ normal1X = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ normal1Y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  var /** @type {number} */ tX = (tMat.col1.x * normal1X + tMat.col1.y * normal1Y);
  normal1Y = (tMat.col2.x * normal1X + tMat.col2.y * normal1Y);
  normal1X = tX;
  var /** @type {number} */ index = 0;
  var /** @type {number} */ minDot = Number.MAX_VALUE;
  for (var /** @type {number} */ i = 0; i < count2; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(normals2[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ dot = (normal1X * tVec.x + normal1Y * tVec.y);
    if (dot < minDot) {
      minDot = dot;
      index = i;
    }
  }
  //var /** @type {Box2D.Collision.ClipVertex} */ tClip = null;
  var /** @type {number} */ i1 = index;
  var /** @type {number} */ i2 = (i1 + 1 < count2 ? i1 + 1 : 0) >> 0;
  tClip = /* implicit cast */ org.apache.royale.utils.Language.as(c[0], Box2D.Collision.ClipVertex, true);
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices2[i1], Box2D.Common.Math.b2Vec2, true);
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i1;
  tClip.id.features.incidentVertex = 0;
  tClip = /* implicit cast */ org.apache.royale.utils.Language.as(c[1], Box2D.Collision.ClipVertex, true);
  tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices2[i2], Box2D.Common.Math.b2Vec2, true);
  tMat = xf2.R;
  tClip.v.x = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  tClip.v.y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tClip.id.features.referenceEdge = edge1;
  tClip.id.features.incidentEdge = i2;
  tClip.id.features.incidentVertex = 1;
};


/**
 * @private
 * @return {Array}
 */
Box2D.Collision.b2Collision.MakeClipPointVector = function() {
  var /** @type {Array} */ r = new Array(2);
  r[0] = new Box2D.Collision.ClipVertex();
  r[1] = new Box2D.Collision.ClipVertex();
  return r;
};


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Collision.s_incidentEdge;


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Collision.s_clipPoints1;


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Collision.s_clipPoints2;


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Collision.s_edgeAO = new Array(1);


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Collision.s_edgeBO = new Array(1);


Box2D.Collision.b2Collision.get__s_localTangent = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_localTangent: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_localTangent = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_localTangent: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_localTangent;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_localTangent: {
  get: Box2D.Collision.b2Collision.get__s_localTangent,
  set: Box2D.Collision.b2Collision.set__s_localTangent,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_localNormal = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_localNormal: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_localNormal = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_localNormal: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_localNormal;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_localNormal: {
  get: Box2D.Collision.b2Collision.get__s_localNormal,
  set: Box2D.Collision.b2Collision.set__s_localNormal,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_planePoint = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_planePoint: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_planePoint = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_planePoint: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_planePoint;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_planePoint: {
  get: Box2D.Collision.b2Collision.get__s_planePoint,
  set: Box2D.Collision.b2Collision.set__s_planePoint,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_normal = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_normal: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_normal = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_normal: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_normal;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_normal: {
  get: Box2D.Collision.b2Collision.get__s_normal,
  set: Box2D.Collision.b2Collision.set__s_normal,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_tangent = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_tangent: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_tangent = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_tangent: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_tangent;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_tangent: {
  get: Box2D.Collision.b2Collision.get__s_tangent,
  set: Box2D.Collision.b2Collision.set__s_tangent,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_tangent2 = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_tangent2: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_tangent2 = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_tangent2: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_tangent2;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_tangent2: {
  get: Box2D.Collision.b2Collision.get__s_tangent2,
  set: Box2D.Collision.b2Collision.set__s_tangent2,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_v11 = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_v11: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_v11 = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_v11: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_v11;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_v11: {
  get: Box2D.Collision.b2Collision.get__s_v11,
  set: Box2D.Collision.b2Collision.set__s_v11,
  configurable: true}});


Box2D.Collision.b2Collision.get__s_v12 = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { s_v12: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__s_v12 = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { s_v12: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.s_v12;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
s_v12: {
  get: Box2D.Collision.b2Collision.get__s_v12,
  set: Box2D.Collision.b2Collision.set__s_v12,
  configurable: true}});


Box2D.Collision.b2Collision.get__b2CollidePolyTempVec = function() {
  var value = new Box2D.Common.Math.b2Vec2();
  Object.defineProperties(Box2D.Collision.b2Collision, { b2CollidePolyTempVec: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Collision.set__b2CollidePolyTempVec = function(value) {
  Object.defineProperties(Box2D.Collision.b2Collision, { b2CollidePolyTempVec: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2Collision.b2CollidePolyTempVec;

Object.defineProperties(Box2D.Collision.b2Collision, /** @lends {Box2D.Collision.b2Collision} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
b2CollidePolyTempVec: {
  get: Box2D.Collision.b2Collision.get__b2CollidePolyTempVec,
  set: Box2D.Collision.b2Collision.set__b2CollidePolyTempVec,
  configurable: true}});


/**
 * @nocollapse
 * @param {Box2D.Collision.b2Manifold} manifold
 * @param {Box2D.Collision.Shapes.b2PolygonShape} polyA
 * @param {Box2D.Common.Math.b2Transform} xfA
 * @param {Box2D.Collision.Shapes.b2PolygonShape} polyB
 * @param {Box2D.Common.Math.b2Transform} xfB
 */
Box2D.Collision.b2Collision.CollidePolygons = function(manifold, polyA, xfA, polyB, xfB) {
  var /** @type {Box2D.Common.Math.b2Transform} */ xf1 = null;
  var /** @type {number} */ np = 0;
  var /** @type {Box2D.Common.Math.b2Transform} */ xf2 = null;
  var /** @type {number} */ flip = 0;
  var /** @type {number} */ edge1 = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ local_v12 = null;
  var /** @type {Box2D.Collision.ClipVertex} */ cv = null;
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ poly2 = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ poly1 = null;
  //var /** @type {Box2D.Collision.ClipVertex} */ cv = null;
  manifold.m_pointCount = 0;
  var /** @type {number} */ totalRadius = polyA.m_radius + polyB.m_radius;
  var /** @type {number} */ edgeA = 0;
  Box2D.Collision.b2Collision.s_edgeAO[0] = edgeA;
  var /** @type {number} */ separationA = Box2D.Collision.b2Collision.FindMaxSeparation(Box2D.Collision.b2Collision.s_edgeAO, polyA, xfA, polyB, xfB);
  edgeA = (Box2D.Collision.b2Collision.s_edgeAO[0]) >> 0;
  if (separationA > totalRadius)
    return;
  var /** @type {number} */ edgeB = 0;
  Box2D.Collision.b2Collision.s_edgeBO[0] = edgeB;
  var /** @type {number} */ separationB = Box2D.Collision.b2Collision.FindMaxSeparation(Box2D.Collision.b2Collision.s_edgeBO, polyB, xfB, polyA, xfA);
  edgeB = (Box2D.Collision.b2Collision.s_edgeBO[0]) >> 0;
  if (separationB > totalRadius)
    return;
  //var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ poly1 = null;
  //var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ poly2 = null;
  //var /** @type {Box2D.Common.Math.b2Transform} */ xf1 = null;
  //var /** @type {Box2D.Common.Math.b2Transform} */ xf2 = null;
  //var /** @type {number} */ edge1 = 0;
  //var /** @type {number} */ flip = 0;
  
/**
 * @const
 * @type {number}
 */
var k_relativeTol = 0.98;
  
/**
 * @const
 * @type {number}
 */
var k_absoluteTol = 0.001;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  if (separationB > k_relativeTol * separationA + k_absoluteTol) {
    poly1 = polyB;
    poly2 = polyA;
    xf1 = xfB;
    xf2 = xfA;
    edge1 = edgeB;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceB;
    flip = 1;
  } else {
    poly1 = polyA;
    poly2 = polyB;
    xf1 = xfA;
    xf2 = xfB;
    edge1 = edgeA;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceA;
    flip = 0;
  }
  var /** @type {Array} */ incidentEdge = Box2D.Collision.b2Collision.s_incidentEdge;
  Box2D.Collision.b2Collision.FindIncidentEdge(incidentEdge, poly1, xf1, edge1, poly2, xf2);
  var /** @type {number} */ count1 = poly1.m_vertexCount;
  var /** @type {Array} */ vertices1 = poly1.m_vertices;
  var /** @type {Box2D.Common.Math.b2Vec2} */ local_v11 = /* implicit cast */ org.apache.royale.utils.Language.as(vertices1[edge1], Box2D.Common.Math.b2Vec2, true);
  //var /** @type {Box2D.Common.Math.b2Vec2} */ local_v12 = null;
  if (edge1 + 1 < count1) {
    local_v12 = /* implicit cast */ org.apache.royale.utils.Language.as(vertices1[org.apache.royale.utils.Language._int(edge1 + 1)], Box2D.Common.Math.b2Vec2, true);
  } else {
    local_v12 = /* implicit cast */ org.apache.royale.utils.Language.as(vertices1[0], Box2D.Common.Math.b2Vec2, true);
  }
  var /** @type {Box2D.Common.Math.b2Vec2} */ localTangent = Box2D.Collision.b2Collision.s_localTangent;
  localTangent.Set(local_v12.x - local_v11.x, local_v12.y - local_v11.y);
  localTangent.Normalize();
  var /** @type {Box2D.Common.Math.b2Vec2} */ localNormal = Box2D.Collision.b2Collision.s_localNormal;
  localNormal.x = localTangent.y;
  localNormal.y = -localTangent.x;
  var /** @type {Box2D.Common.Math.b2Vec2} */ planePoint = Box2D.Collision.b2Collision.s_planePoint;
  planePoint.Set(0.5 * (local_v11.x + local_v12.x), 0.5 * (local_v11.y + local_v12.y));
  var /** @type {Box2D.Common.Math.b2Vec2} */ tangent = Box2D.Collision.b2Collision.s_tangent;
  tMat = xf1.R;
  tangent.x = (tMat.col1.x * localTangent.x + tMat.col2.x * localTangent.y);
  tangent.y = (tMat.col1.y * localTangent.x + tMat.col2.y * localTangent.y);
  var /** @type {Box2D.Common.Math.b2Vec2} */ tangent2 = Box2D.Collision.b2Collision.s_tangent2;
  tangent2.x = -tangent.x;
  tangent2.y = -tangent.y;
  var /** @type {Box2D.Common.Math.b2Vec2} */ normal = Box2D.Collision.b2Collision.s_normal;
  normal.x = tangent.y;
  normal.y = -tangent.x;
  var /** @type {Box2D.Common.Math.b2Vec2} */ v11 = Box2D.Collision.b2Collision.s_v11;
  var /** @type {Box2D.Common.Math.b2Vec2} */ v12 = Box2D.Collision.b2Collision.s_v12;
  v11.x = xf1.position.x + (tMat.col1.x * local_v11.x + tMat.col2.x * local_v11.y);
  v11.y = xf1.position.y + (tMat.col1.y * local_v11.x + tMat.col2.y * local_v11.y);
  v12.x = xf1.position.x + (tMat.col1.x * local_v12.x + tMat.col2.x * local_v12.y);
  v12.y = xf1.position.y + (tMat.col1.y * local_v12.x + tMat.col2.y * local_v12.y);
  var /** @type {number} */ frontOffset = normal.x * v11.x + normal.y * v11.y;
  var /** @type {number} */ sideOffset1 = -tangent.x * v11.x - tangent.y * v11.y + totalRadius;
  var /** @type {number} */ sideOffset2 = tangent.x * v12.x + tangent.y * v12.y + totalRadius;
  var /** @type {Array} */ clipPoints1 = Box2D.Collision.b2Collision.s_clipPoints1;
  var /** @type {Array} */ clipPoints2 = Box2D.Collision.b2Collision.s_clipPoints2;
  //var /** @type {number} */ np = 0;
  np = Box2D.Collision.b2Collision.ClipSegmentToLine(clipPoints1, incidentEdge, tangent2, sideOffset1);
  if (np < 2)
    return;
  np = Box2D.Collision.b2Collision.ClipSegmentToLine(clipPoints2, clipPoints1, tangent, sideOffset2);
  if (np < 2)
    return;
  manifold.m_localPlaneNormal.SetV(localNormal);
  manifold.m_localPoint.SetV(planePoint);
  var /** @type {number} */ pointCount = 0;
  for (var /** @type {number} */ i = 0; i < Box2D.Common.b2Settings.b2_maxManifoldPoints; ++i) {
    cv = /* implicit cast */ org.apache.royale.utils.Language.as(clipPoints2[i], Box2D.Collision.ClipVertex, true);
    var /** @type {number} */ separation = normal.x * cv.v.x + normal.y * cv.v.y - frontOffset;
    if (separation <= totalRadius) {
      var /** @type {Box2D.Collision.b2ManifoldPoint} */ cp = /* implicit cast */ org.apache.royale.utils.Language.as(manifold.m_points[pointCount], Box2D.Collision.b2ManifoldPoint, true);
      tMat = xf2.R;
      var /** @type {number} */ tX = cv.v.x - xf2.position.x;
      var /** @type {number} */ tY = cv.v.y - xf2.position.y;
      cp.m_localPoint.x = (tX * tMat.col1.x + tY * tMat.col1.y);
      cp.m_localPoint.y = (tX * tMat.col2.x + tY * tMat.col2.y);
      cp.m_id.Set(cv.id);
      cp.m_id.features.flip = (flip) >> 0;
      ++pointCount;
    }
  }
  manifold.m_pointCount = pointCount;
};


/**
 * @nocollapse
 * @param {Box2D.Collision.b2Manifold} manifold
 * @param {Box2D.Collision.Shapes.b2CircleShape} circle1
 * @param {Box2D.Common.Math.b2Transform} xf1
 * @param {Box2D.Collision.Shapes.b2CircleShape} circle2
 * @param {Box2D.Common.Math.b2Transform} xf2
 */
Box2D.Collision.b2Collision.CollideCircles = function(manifold, circle1, xf1, circle2, xf2) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  manifold.m_pointCount = 0;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  tMat = xf1.R;
  tVec = circle1.m_p;
  var /** @type {number} */ p1X = xf1.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ p1Y = xf1.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  tMat = xf2.R;
  tVec = circle2.m_p;
  var /** @type {number} */ p2X = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ p2Y = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  var /** @type {number} */ dX = p2X - p1X;
  var /** @type {number} */ dY = p2Y - p1Y;
  var /** @type {number} */ distSqr = dX * dX + dY * dY;
  var /** @type {number} */ radius = circle1.m_radius + circle2.m_radius;
  if (distSqr > radius * radius) {
    return;
  }
  manifold.m_type = Box2D.Collision.b2Manifold.e_circles;
  manifold.m_localPoint.SetV(circle1.m_p);
  manifold.m_localPlaneNormal.SetZero();
  manifold.m_pointCount = 1;
  manifold.m_points[0].m_localPoint.SetV(circle2.m_p);
  manifold.m_points[0].m_id.key = 0;
};


/**
 * @nocollapse
 * @param {Box2D.Collision.b2Manifold} manifold
 * @param {Box2D.Collision.Shapes.b2PolygonShape} polygon
 * @param {Box2D.Common.Math.b2Transform} xf1
 * @param {Box2D.Collision.Shapes.b2CircleShape} circle
 * @param {Box2D.Common.Math.b2Transform} xf2
 */
Box2D.Collision.b2Collision.CollidePolygonAndCircle = function(manifold, polygon, xf1, circle, xf2) {
  var /** @type {number} */ dist = NaN;
  var /** @type {number} */ positionX = NaN;
  var /** @type {number} */ positionY = NaN;
  var /** @type {Box2D.Collision.b2ManifoldPoint} */ tPoint = null;
  var /** @type {number} */ dX = NaN;
  var /** @type {number} */ dY = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  manifold.m_pointCount = 0;
  //var /** @type {Box2D.Collision.b2ManifoldPoint} */ tPoint = null;
  //var /** @type {number} */ dX = NaN;
  //var /** @type {number} */ dY = NaN;
  //var /** @type {number} */ positionX = NaN;
  //var /** @type {number} */ positionY = NaN;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  tMat = xf2.R;
  tVec = circle.m_p;
  var /** @type {number} */ cX = xf2.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  var /** @type {number} */ cY = xf2.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  dX = cX - xf1.position.x;
  dY = cY - xf1.position.y;
  tMat = xf1.R;
  var /** @type {number} */ cLocalX = (dX * tMat.col1.x + dY * tMat.col1.y);
  var /** @type {number} */ cLocalY = (dX * tMat.col2.x + dY * tMat.col2.y);
  //var /** @type {number} */ dist = NaN;
  var /** @type {number} */ normalIndex = 0;
  var /** @type {number} */ separation = -Number.MAX_VALUE;
  var /** @type {number} */ radius = polygon.m_radius + circle.m_radius;
  var /** @type {number} */ vertexCount = polygon.m_vertexCount;
  var /** @type {Array} */ vertices = polygon.m_vertices;
  var /** @type {Array} */ normals = polygon.m_normals;
  for (var /** @type {number} */ i = 0; i < vertexCount; ++i) {
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(vertices[i], Box2D.Common.Math.b2Vec2, true);
    dX = cLocalX - tVec.x;
    dY = cLocalY - tVec.y;
    tVec = /* implicit cast */ org.apache.royale.utils.Language.as(normals[i], Box2D.Common.Math.b2Vec2, true);
    var /** @type {number} */ s = tVec.x * dX + tVec.y * dY;
    if (s > radius) {
      return;
    }
    if (s > separation) {
      separation = s;
      normalIndex = i;
    }
  }
  var /** @type {number} */ vertIndex1 = normalIndex;
  var /** @type {number} */ vertIndex2 = (vertIndex1 + 1 < vertexCount ? vertIndex1 + 1 : 0) >> 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ v1 = /* implicit cast */ org.apache.royale.utils.Language.as(vertices[vertIndex1], Box2D.Common.Math.b2Vec2, true);
  var /** @type {Box2D.Common.Math.b2Vec2} */ v2 = /* implicit cast */ org.apache.royale.utils.Language.as(vertices[vertIndex2], Box2D.Common.Math.b2Vec2, true);
  if (separation < Number.MIN_VALUE) {
    manifold.m_pointCount = 1;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.SetV(/* implicit cast */ org.apache.royale.utils.Language.as(normals[normalIndex], Box2D.Common.Math.b2Vec2, true));
    manifold.m_localPoint.x = 0.5 * (v1.x + v2.x);
    manifold.m_localPoint.y = 0.5 * (v1.y + v2.y);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
    return;
  }
  var /** @type {number} */ u1 = (cLocalX - v1.x) * (v2.x - v1.x) + (cLocalY - v1.y) * (v2.y - v1.y);
  var /** @type {number} */ u2 = (cLocalX - v2.x) * (v1.x - v2.x) + (cLocalY - v2.y) * (v1.y - v2.y);
  if (u1 <= 0.0) {
    if ((cLocalX - v1.x) * (cLocalX - v1.x) + (cLocalY - v1.y) * (cLocalY - v1.y) > radius * radius)
      return;
    manifold.m_pointCount = 1;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v1.x;
    manifold.m_localPlaneNormal.y = cLocalY - v1.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v1);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
  } else if (u2 <= 0) {
    if ((cLocalX - v2.x) * (cLocalX - v2.x) + (cLocalY - v2.y) * (cLocalY - v2.y) > radius * radius)
      return;
    manifold.m_pointCount = 1;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = cLocalX - v2.x;
    manifold.m_localPlaneNormal.y = cLocalY - v2.y;
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.SetV(v2);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
  } else {
    var /** @type {number} */ faceCenterX = 0.5 * (v1.x + v2.x);
    var /** @type {number} */ faceCenterY = 0.5 * (v1.y + v2.y);
    separation = (cLocalX - faceCenterX) * normals[vertIndex1].x + (cLocalY - faceCenterY) * normals[vertIndex1].y;
    if (separation > radius)
      return;
    manifold.m_pointCount = 1;
    manifold.m_type = Box2D.Collision.b2Manifold.e_faceA;
    manifold.m_localPlaneNormal.x = Number(normals[vertIndex1].x);
    manifold.m_localPlaneNormal.y = Number(normals[vertIndex1].y);
    manifold.m_localPlaneNormal.Normalize();
    manifold.m_localPoint.Set(faceCenterX, faceCenterY);
    manifold.m_points[0].m_localPoint.SetV(circle.m_p);
    manifold.m_points[0].m_id.key = 0;
  }
};


/**
 * @nocollapse
 * @param {Box2D.Collision.b2AABB} a
 * @param {Box2D.Collision.b2AABB} b
 * @return {boolean}
 */
Box2D.Collision.b2Collision.TestOverlap = function(a, b) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ t1 = b.lowerBound;
  var /** @type {Box2D.Common.Math.b2Vec2} */ t2 = a.upperBound;
  var /** @type {number} */ d1X = t1.x - t2.x;
  var /** @type {number} */ d1Y = t1.y - t2.y;
  t1 = a.lowerBound;
  t2 = b.upperBound;
  var /** @type {number} */ d2X = t1.x - t2.x;
  var /** @type {number} */ d2Y = t1.y - t2.y;
  if (d1X > 0.0 || d1Y > 0.0)
    return false;
  if (d2X > 0.0 || d2Y > 0.0)
    return false;
  return true;
};

Box2D.Collision.b2Collision.s_incidentEdge = Box2D.Collision.b2Collision.MakeClipPointVector();
Box2D.Collision.b2Collision.s_clipPoints1 = Box2D.Collision.b2Collision.MakeClipPointVector();
Box2D.Collision.b2Collision.s_clipPoints2 = Box2D.Collision.b2Collision.MakeClipPointVector();




/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2Collision.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2Collision', qName: 'Box2D.Collision.b2Collision', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2Collision.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        '|ClipSegmentToLine': { type: 'int', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Array', false ,'Array', false ,'Box2D.Common.Math.b2Vec2', false ,'Number', false ]; }},
        '|EdgeSeparation': { type: 'Number', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ,'int', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|FindMaxSeparation': { type: 'Number', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Array', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|FindIncidentEdge': { type: 'void', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Array', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ,'int', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|CollidePolygons': { type: 'void', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Box2D.Collision.b2Manifold', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|CollideCircles': { type: 'void', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Box2D.Collision.b2Manifold', false ,'Box2D.Collision.Shapes.b2CircleShape', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Collision.Shapes.b2CircleShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|CollidePolygonAndCircle': { type: 'void', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Box2D.Collision.b2Manifold', false ,'Box2D.Collision.Shapes.b2PolygonShape', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Collision.Shapes.b2CircleShape', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        '|TestOverlap': { type: 'Boolean', declaredBy: 'Box2D.Collision.b2Collision', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'Box2D.Collision.b2AABB', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2Collision.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Collision.b2Collision.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Collision.b2Collision);
