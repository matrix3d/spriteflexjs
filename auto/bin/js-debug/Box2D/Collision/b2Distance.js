/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2Distance.as
 * Box2D.Collision.b2Distance
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2Distance');
/* Royale Dependency List: Box2D.Collision.b2DistanceInput,Box2D.Collision.b2DistanceOutput,Box2D.Collision.b2DistanceProxy,Box2D.Collision.b2Simplex,Box2D.Collision.b2SimplexCache,Box2D.Collision.b2SimplexVertex,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings*/
/* Royale Static Dependency List: org.apache.royale.utils.Language*/

goog.require('org.apache.royale.utils.Language');



/**
 * @constructor
 */
Box2D.Collision.b2Distance = function() {
};


/**
 * @private
 * @type {number}
 */
Box2D.Collision.b2Distance.b2_gjkCalls = 0;


/**
 * @private
 * @type {number}
 */
Box2D.Collision.b2Distance.b2_gjkIters = 0;


/**
 * @private
 * @type {number}
 */
Box2D.Collision.b2Distance.b2_gjkMaxIters = 0;


Box2D.Collision.b2Distance.get__s_simplex = function() {
  var value = new Box2D.Collision.b2Simplex();
  Object.defineProperties(Box2D.Collision.b2Distance, { s_simplex: { value: value, writable: true }});
  return value;
};
Box2D.Collision.b2Distance.set__s_simplex = function(value) {
  Object.defineProperties(Box2D.Collision.b2Distance, { s_simplex: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Collision.b2Simplex}
 */
Box2D.Collision.b2Distance.s_simplex;

Object.defineProperties(Box2D.Collision.b2Distance, /** @lends {Box2D.Collision.b2Distance} */ {
/**
 * @private
 * @type {Box2D.Collision.b2Simplex}
 */
s_simplex: {
  get: Box2D.Collision.b2Distance.get__s_simplex,
  set: Box2D.Collision.b2Distance.set__s_simplex,
  configurable: true}});


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Distance.s_saveA = new Array(3);


/**
 * @private
 * @type {Array}
 */
Box2D.Collision.b2Distance.s_saveB = new Array(3);


/**
 * @nocollapse
 * @param {Box2D.Collision.b2DistanceOutput} output
 * @param {Box2D.Collision.b2SimplexCache} cache
 * @param {Box2D.Collision.b2DistanceInput} input
 */
Box2D.Collision.b2Distance.Distance = function(output, cache, input) {
  var /** @type {number} */ i = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ p = null;
  ++Box2D.Collision.b2Distance.b2_gjkCalls;
  var /** @type {Box2D.Collision.b2DistanceProxy} */ proxyA = input.proxyA;
  var /** @type {Box2D.Collision.b2DistanceProxy} */ proxyB = input.proxyB;
  var /** @type {Box2D.Common.Math.b2Transform} */ transformA = input.transformA;
  var /** @type {Box2D.Common.Math.b2Transform} */ transformB = input.transformB;
  var /** @type {Box2D.Collision.b2Simplex} */ simplex = Box2D.Collision.b2Distance.s_simplex;
  simplex.ReadCache(cache, proxyA, transformA, proxyB, transformB);
  var /** @type {Array} */ vertices = simplex.m_vertices;
  
/**
 * @const
 * @type {number}
 */
var k_maxIters = 20;
  var /** @type {Array} */ saveA = Box2D.Collision.b2Distance.s_saveA;
  var /** @type {Array} */ saveB = Box2D.Collision.b2Distance.s_saveB;
  var /** @type {number} */ saveCount = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ closestPoint = simplex.GetClosestPoint();
  var /** @type {number} */ distanceSqr1 = closestPoint.LengthSquared();
  var /** @type {number} */ distanceSqr2 = distanceSqr1;
  //var /** @type {number} */ i = 0;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ p = null;
  var /** @type {number} */ iter = 0;
  while (iter < k_maxIters) {
    saveCount = simplex.m_count;
    for (i = 0; i < saveCount; i++) {
      saveA[i] = vertices[i].indexA;
      saveB[i] = vertices[i].indexB;
    }
    switch (simplex.m_count) {
      case 1:
        break;
      case 2:
        simplex.Solve2();
        break;
      case 3:
        simplex.Solve3();
        break;
      default:
        Box2D.Common.b2Settings.b2Assert(false);
    }
    if (simplex.m_count == 3) {
      break;
    }
    p = simplex.GetClosestPoint();
    distanceSqr2 = p.LengthSquared();
    distanceSqr1 = distanceSqr2;
    var /** @type {Box2D.Common.Math.b2Vec2} */ d = simplex.GetSearchDirection();
    if (d.LengthSquared() < Number.MIN_VALUE * Number.MIN_VALUE) {
      break;
    }
    var /** @type {Box2D.Collision.b2SimplexVertex} */ vertex = /* implicit cast */ org.apache.royale.utils.Language.as(vertices[simplex.m_count], Box2D.Collision.b2SimplexVertex, true);
    vertex.indexA = (proxyA.GetSupport(Box2D.Common.Math.b2Math.MulTMV(transformA.R, d.GetNegative()))) >> 0;
    vertex.wA = Box2D.Common.Math.b2Math.MulX(transformA, proxyA.GetVertex(vertex.indexA));
    vertex.indexB = (proxyB.GetSupport(Box2D.Common.Math.b2Math.MulTMV(transformB.R, d))) >> 0;
    vertex.wB = Box2D.Common.Math.b2Math.MulX(transformB, proxyB.GetVertex(vertex.indexB));
    vertex.w = Box2D.Common.Math.b2Math.SubtractVV(vertex.wB, vertex.wA);
    ++iter;
    ++Box2D.Collision.b2Distance.b2_gjkIters;
    var /** @type {boolean} */ duplicate = false;
    for (i = 0; i < saveCount; i++) {
      if (vertex.indexA == saveA[i] && vertex.indexB == saveB[i]) {
        duplicate = true;
        break;
      }
    }
    if (duplicate) {
      break;
    }
    ++simplex.m_count;
  }
  Box2D.Collision.b2Distance.b2_gjkMaxIters = (Box2D.Common.Math.b2Math.Max(Box2D.Collision.b2Distance.b2_gjkMaxIters, iter)) >> 0;
  simplex.GetWitnessPoints(output.pointA, output.pointB);
  output.distance = Box2D.Common.Math.b2Math.SubtractVV(output.pointA, output.pointB).Length();
  output.iterations = iter;
  simplex.WriteCache(cache);
  if (input.useRadii) {
    var /** @type {number} */ rA = proxyA.m_radius;
    var /** @type {number} */ rB = proxyB.m_radius;
    if (output.distance > rA + rB && output.distance > Number.MIN_VALUE) {
      output.distance -= rA + rB;
      var /** @type {Box2D.Common.Math.b2Vec2} */ normal = Box2D.Common.Math.b2Math.SubtractVV(output.pointB, output.pointA);
      normal.Normalize();
      output.pointA.x += rA * normal.x;
      output.pointA.y += rA * normal.y;
      output.pointB.x -= rB * normal.x;
      output.pointB.y -= rB * normal.y;
    } else {
      p = new Box2D.Common.Math.b2Vec2();
      p.x = .5 * (output.pointA.x + output.pointB.x);
      p.y = .5 * (output.pointA.y + output.pointB.y);
      output.pointA.x = output.pointB.x = p.x;
      output.pointA.y = output.pointB.y = p.y;
      output.distance = 0.0;
    }
  }
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2Distance.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2Distance', qName: 'Box2D.Collision.b2Distance', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2Distance.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        '|Distance': { type: 'void', declaredBy: 'Box2D.Collision.b2Distance', parameters: function () { return [ 'Box2D.Collision.b2DistanceOutput', false ,'Box2D.Collision.b2SimplexCache', false ,'Box2D.Collision.b2DistanceInput', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2Distance.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Collision.b2Distance.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Collision.b2Distance);
