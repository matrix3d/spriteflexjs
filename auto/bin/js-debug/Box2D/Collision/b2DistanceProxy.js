/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2DistanceProxy.as
 * Box2D.Collision.b2DistanceProxy
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2DistanceProxy');
/* Royale Dependency List: Box2D.Collision.Shapes.b2CircleShape,Box2D.Collision.Shapes.b2PolygonShape,Box2D.Collision.Shapes.b2Shape,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings,org.apache.royale.utils.Language*/




/**
 * @constructor
 */
Box2D.Collision.b2DistanceProxy = function() {
};


/**
 * Initialize the proxy using the given shape. The shape
 * must remain in scope while the proxy is in use.
 * @param {Box2D.Collision.Shapes.b2Shape} shape
 */
Box2D.Collision.b2DistanceProxy.prototype.Set = function(shape) {
  switch (shape.GetType()) {
    case Box2D.Collision.Shapes.b2Shape.e_circleShape:
      var /** @type {Box2D.Collision.Shapes.b2CircleShape} */ circle = shape;
      this.m_vertices = new Array(1, true);
      this.m_vertices[0] = circle.m_p;
      this.m_count = 1;
      this.m_radius = circle.m_radius;
      break;
    case Box2D.Collision.Shapes.b2Shape.e_polygonShape:
      var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ polygon = shape;
      this.m_vertices = polygon.m_vertices;
      this.m_count = polygon.m_vertexCount;
      this.m_radius = polygon.m_radius;
      break;
    default:
      Box2D.Common.b2Settings.b2Assert(false);
  }
};


/**
 * Get the supporting vertex index in the given direction.
 * @param {Box2D.Common.Math.b2Vec2} d
 * @return {number}
 */
Box2D.Collision.b2DistanceProxy.prototype.GetSupport = function(d) {
  var /** @type {number} */ bestIndex = 0;
  var /** @type {number} */ bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for (var /** @type {number} */ i = 1; i < this.m_count; ++i) {
    var /** @type {number} */ value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return bestIndex;
};


/**
 * Get the supporting vertex in the given direction.
 * @param {Box2D.Common.Math.b2Vec2} d
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2DistanceProxy.prototype.GetSupportVertex = function(d) {
  var /** @type {number} */ bestIndex = 0;
  var /** @type {number} */ bestValue = this.m_vertices[0].x * d.x + this.m_vertices[0].y * d.y;
  for (var /** @type {number} */ i = 1; i < this.m_count; ++i) {
    var /** @type {number} */ value = this.m_vertices[i].x * d.x + this.m_vertices[i].y * d.y;
    if (value > bestValue) {
      bestIndex = i;
      bestValue = value;
    }
  }
  return /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[bestIndex], Box2D.Common.Math.b2Vec2, true);
};


/**
 * Get the vertex count.
 * @return {number}
 */
Box2D.Collision.b2DistanceProxy.prototype.GetVertexCount = function() {
  return this.m_count;
};


/**
 * Get a vertex by index. Used by b2Distance.
 * @param {number} index
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2DistanceProxy.prototype.GetVertex = function(index) {
  Box2D.Common.b2Settings.b2Assert(0 <= index && index < this.m_count);
  return /* implicit cast */ org.apache.royale.utils.Language.as(this.m_vertices[index], Box2D.Common.Math.b2Vec2, true);
};


/**
 * @type {Array}
 */
Box2D.Collision.b2DistanceProxy.prototype.m_vertices = null;


/**
 * @type {number}
 */
Box2D.Collision.b2DistanceProxy.prototype.m_count = 0;


/**
 * @type {number}
 */
Box2D.Collision.b2DistanceProxy.prototype.m_radius = NaN;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2DistanceProxy.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2DistanceProxy', qName: 'Box2D.Collision.b2DistanceProxy', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2DistanceProxy.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_vertices': { type: 'Array', get_set: function (/** Box2D.Collision.b2DistanceProxy */ inst, /** * */ v) {return v !== undefined ? inst.m_vertices = v : inst.m_vertices;}},
        'm_count': { type: 'int', get_set: function (/** Box2D.Collision.b2DistanceProxy */ inst, /** * */ v) {return v !== undefined ? inst.m_count = v : inst.m_count;}},
        'm_radius': { type: 'Number', get_set: function (/** Box2D.Collision.b2DistanceProxy */ inst, /** * */ v) {return v !== undefined ? inst.m_radius = v : inst.m_radius;}}
      };
    },
    methods: function () {
      return {
        'Set': { type: 'void', declaredBy: 'Box2D.Collision.b2DistanceProxy', parameters: function () { return [ 'Box2D.Collision.Shapes.b2Shape', false ]; }},
        'GetSupport': { type: 'Number', declaredBy: 'Box2D.Collision.b2DistanceProxy', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetSupportVertex': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.b2DistanceProxy', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetVertexCount': { type: 'int', declaredBy: 'Box2D.Collision.b2DistanceProxy'},
        'GetVertex': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Collision.b2DistanceProxy', parameters: function () { return [ 'int', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2DistanceProxy.prototype.ROYALE_COMPILE_FLAGS = 9;
