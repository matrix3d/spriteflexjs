/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2DynamicTree.as
 * Box2D.Collision.b2DynamicTree
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2DynamicTree');
/* Royale Dependency List: Box2D.Collision.b2AABB,Box2D.Collision.b2DynamicTreeNode,Box2D.Collision.b2RayCastInput,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings,org.apache.royale.utils.Language*/




/**
 * Constructing the tree initializes the node pool.
 * @constructor
 */
Box2D.Collision.b2DynamicTree = function() {
  this.Box2D_Collision_b2DynamicTree_m_root = null;
  this.Box2D_Collision_b2DynamicTree_m_freeList = null;
  this.Box2D_Collision_b2DynamicTree_m_path = 0;
  this.Box2D_Collision_b2DynamicTree_m_insertionCount = 0;
};


/**
 * Create a proxy. Provide a tight fitting AABB and a userData.
 * @param {Box2D.Collision.b2AABB} aabb
 * @param {*} userData
 * @return {Box2D.Collision.b2DynamicTreeNode}
 */
Box2D.Collision.b2DynamicTree.prototype.CreateProxy = function(aabb, userData) {
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node = this.Box2D_Collision_b2DynamicTree_AllocateNode();
  var /** @type {number} */ extendX = Box2D.Common.b2Settings.b2_aabbExtension;
  var /** @type {number} */ extendY = Box2D.Common.b2Settings.b2_aabbExtension;
  node.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  node.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  node.aabb.upperBound.x = aabb.upperBound.x + extendX;
  node.aabb.upperBound.y = aabb.upperBound.y + extendY;
  node.userData = userData;
  this.Box2D_Collision_b2DynamicTree_InsertLeaf(node);
  return node;
};


/**
 * Destroy a proxy. This asserts if the id is invalid.
 * @param {Box2D.Collision.b2DynamicTreeNode} proxy
 */
Box2D.Collision.b2DynamicTree.prototype.DestroyProxy = function(proxy) {
  this.Box2D_Collision_b2DynamicTree_RemoveLeaf(proxy);
  this.Box2D_Collision_b2DynamicTree_FreeNode(proxy);
};


/**
 * Move a proxy with a swept AABB. If the proxy has moved outside of its fattened AABB,
 * then the proxy is removed from the tree and re-inserted. Otherwise
 * the function returns immediately.
 * @param {Box2D.Collision.b2DynamicTreeNode} proxy
 * @param {Box2D.Collision.b2AABB} aabb
 * @param {Box2D.Common.Math.b2Vec2} displacement
 * @return {boolean}
 */
Box2D.Collision.b2DynamicTree.prototype.MoveProxy = function(proxy, aabb, displacement) {
  Box2D.Common.b2Settings.b2Assert(proxy.IsLeaf());
  if (proxy.aabb.Contains(aabb)) {
    return false;
  }
  this.Box2D_Collision_b2DynamicTree_RemoveLeaf(proxy);
  var /** @type {number} */ extendX = Box2D.Common.b2Settings.b2_aabbExtension + Box2D.Common.b2Settings.b2_aabbMultiplier * (displacement.x > 0 ? displacement.x : -displacement.x);
  var /** @type {number} */ extendY = Box2D.Common.b2Settings.b2_aabbExtension + Box2D.Common.b2Settings.b2_aabbMultiplier * (displacement.y > 0 ? displacement.y : -displacement.y);
  proxy.aabb.lowerBound.x = aabb.lowerBound.x - extendX;
  proxy.aabb.lowerBound.y = aabb.lowerBound.y - extendY;
  proxy.aabb.upperBound.x = aabb.upperBound.x + extendX;
  proxy.aabb.upperBound.y = aabb.upperBound.y + extendY;
  this.Box2D_Collision_b2DynamicTree_InsertLeaf(proxy);
  return true;
};


/**
 * Perform some iterations to re-balance the tree.
 * @param {number} iterations
 */
Box2D.Collision.b2DynamicTree.prototype.Rebalance = function(iterations) {
  if (this.Box2D_Collision_b2DynamicTree_m_root == null)
    return;
  for (var /** @type {number} */ i = 0; i < iterations; i++) {
    var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node = this.Box2D_Collision_b2DynamicTree_m_root;
    var /** @type {number} */ bit = 0;
    while (node.IsLeaf() == false) {
      node = (this.Box2D_Collision_b2DynamicTree_m_path >> bit) & 1 ? node.child2 : node.child1;
      bit = ((bit + 1) & 31) >>> 0;
    }
    ++this.Box2D_Collision_b2DynamicTree_m_path;
    this.Box2D_Collision_b2DynamicTree_RemoveLeaf(node);
    this.Box2D_Collision_b2DynamicTree_InsertLeaf(node);
  }
};


/**
 * @param {Box2D.Collision.b2DynamicTreeNode} proxy
 * @return {Box2D.Collision.b2AABB}
 */
Box2D.Collision.b2DynamicTree.prototype.GetFatAABB = function(proxy) {
  return proxy.aabb;
};


/**
 * Get user data from a proxy. Returns null if the proxy is invalid.
 * @param {Box2D.Collision.b2DynamicTreeNode} proxy
 * @return {*}
 */
Box2D.Collision.b2DynamicTree.prototype.GetUserData = function(proxy) {
  return proxy.userData;
};


/**
 * Query an AABB for overlapping proxies. The callback
 * is called for each proxy that overlaps the supplied AABB.
 * The callback should match function signature
 * <code>fuction callback(proxy:b2DynamicTreeNode):Boolean</code>
 * and should return false to trigger premature termination.
 * @param {Function} callback
 * @param {Box2D.Collision.b2AABB} aabb
 */
Box2D.Collision.b2DynamicTree.prototype.Query = function(callback, aabb) {
  if (this.Box2D_Collision_b2DynamicTree_m_root == null)
    return;
  var /** @type {Array} */ stack = new Array();
  var /** @type {number} */ count = 0;
  stack[count++] = this.Box2D_Collision_b2DynamicTree_m_root;
  while (count > 0) {
    var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node = /* implicit cast */ org.apache.royale.utils.Language.as(stack[--count], Box2D.Collision.b2DynamicTreeNode, true);
    if (node.aabb.TestOverlap(aabb)) {
      if (node.IsLeaf()) {
        var /** @type {boolean} */ proceed = !!(callback(node));
        if (!proceed)
          return;
      } else {
        stack[count++] = node.child1;
        stack[count++] = node.child2;
      }
    }
  }
};


/**
 * Ray-cast against the proxies in the tree. This relies on the callback
 * to perform a exact ray-cast in the case were the proxy contains a shape.
 * The callback also performs the any collision filtering. This has performance
 * roughly equal to k * log(n), where k is the number of collisions and n is the
 * number of proxies in the tree.
 * @asparam input the ray-cast input data. The ray extends from p1 to p1 + maxFraction * (p2 - p1).
 * @asparam callback a callback class that is called for each proxy that is hit by the ray.
 * It should be of signature:
 * <code>function callback(input:b2RayCastInput, proxy:*):void</code>
 * @param {Function} callback
 * @param {Box2D.Collision.b2RayCastInput} input
 */
Box2D.Collision.b2DynamicTree.prototype.RayCast = function(callback, input) {
  var /** @type {number} */ tX = NaN;
  var /** @type {number} */ tY = NaN;
  if (this.Box2D_Collision_b2DynamicTree_m_root == null)
    return;
  var /** @type {Box2D.Common.Math.b2Vec2} */ p1 = input.p1;
  var /** @type {Box2D.Common.Math.b2Vec2} */ p2 = input.p2;
  var /** @type {Box2D.Common.Math.b2Vec2} */ r = Box2D.Common.Math.b2Math.SubtractVV(p1, p2);
  r.Normalize();
  var /** @type {Box2D.Common.Math.b2Vec2} */ v = Box2D.Common.Math.b2Math.CrossFV(1.0, r);
  var /** @type {Box2D.Common.Math.b2Vec2} */ abs_v = Box2D.Common.Math.b2Math.AbsV(v);
  var /** @type {number} */ maxFraction = input.maxFraction;
  var /** @type {Box2D.Collision.b2AABB} */ segmentAABB = new Box2D.Collision.b2AABB();
  //var /** @type {number} */ tX = NaN;
  //var /** @type {number} */ tY = NaN;
  tX = p1.x + maxFraction * (p2.x - p1.x);
  tY = p1.y + maxFraction * (p2.y - p1.y);
  segmentAABB.lowerBound.x = Math.min(p1.x, tX);
  segmentAABB.lowerBound.y = Math.min(p1.y, tY);
  segmentAABB.upperBound.x = Math.max(p1.x, tX);
  segmentAABB.upperBound.y = Math.max(p1.y, tY);
  var /** @type {Array} */ stack = new Array();
  var /** @type {number} */ count = 0;
  stack[count++] = this.Box2D_Collision_b2DynamicTree_m_root;
  while (count > 0) {
    var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node = /* implicit cast */ org.apache.royale.utils.Language.as(stack[--count], Box2D.Collision.b2DynamicTreeNode, true);
    if (node.aabb.TestOverlap(segmentAABB) == false) {
      continue;
    }
    var /** @type {Box2D.Common.Math.b2Vec2} */ c = node.aabb.GetCenter();
    var /** @type {Box2D.Common.Math.b2Vec2} */ h = node.aabb.GetExtents();
    var /** @type {number} */ separation = Math.abs(v.x * (p1.x - c.x) + v.y * (p1.y - c.y)) - abs_v.x * h.x - abs_v.y * h.y;
    if (separation > 0.0)
      continue;
    if (node.IsLeaf()) {
      var /** @type {Box2D.Collision.b2RayCastInput} */ subInput = new Box2D.Collision.b2RayCastInput();
      subInput.p1 = input.p1;
      subInput.p2 = input.p2;
      subInput.maxFraction = input.maxFraction;
      maxFraction = Number(callback(subInput, node));
      if (maxFraction == 0.0)
        return;
      tX = p1.x + maxFraction * (p2.x - p1.x);
      tY = p1.y + maxFraction * (p2.y - p1.y);
      segmentAABB.lowerBound.x = Math.min(p1.x, tX);
      segmentAABB.lowerBound.y = Math.min(p1.y, tY);
      segmentAABB.upperBound.x = Math.max(p1.x, tX);
      segmentAABB.upperBound.y = Math.max(p1.y, tY);
    } else {
      stack[count++] = node.child1;
      stack[count++] = node.child2;
    }
  }
};


/**
 * @private
 * @return {Box2D.Collision.b2DynamicTreeNode}
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_AllocateNode = function() {
  if (this.Box2D_Collision_b2DynamicTree_m_freeList) {
    var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node = this.Box2D_Collision_b2DynamicTree_m_freeList;
    this.Box2D_Collision_b2DynamicTree_m_freeList = node.parent;
    node.parent = null;
    node.child1 = null;
    node.child2 = null;
    return node;
  }
  return new Box2D.Collision.b2DynamicTreeNode();
};


/**
 * @private
 * @param {Box2D.Collision.b2DynamicTreeNode} node
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_FreeNode = function(node) {
  node.parent = this.Box2D_Collision_b2DynamicTree_m_freeList;
  this.Box2D_Collision_b2DynamicTree_m_freeList = node;
};


/**
 * @private
 * @param {Box2D.Collision.b2DynamicTreeNode} leaf
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_InsertLeaf = function(leaf) {
  ++this.Box2D_Collision_b2DynamicTree_m_insertionCount;
  if (this.Box2D_Collision_b2DynamicTree_m_root == null) {
    this.Box2D_Collision_b2DynamicTree_m_root = leaf;
    this.Box2D_Collision_b2DynamicTree_m_root.parent = null;
    return;
  }
  var /** @type {Box2D.Common.Math.b2Vec2} */ center = leaf.aabb.GetCenter();
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ sibling = this.Box2D_Collision_b2DynamicTree_m_root;
  if (sibling.IsLeaf() == false) {
    do {
      var /** @type {Box2D.Collision.b2DynamicTreeNode} */ child1 = sibling.child1;
      var /** @type {Box2D.Collision.b2DynamicTreeNode} */ child2 = sibling.child2;
      var /** @type {number} */ norm1 = Math.abs((child1.aabb.lowerBound.x + child1.aabb.upperBound.x) / 2 - center.x) + Math.abs((child1.aabb.lowerBound.y + child1.aabb.upperBound.y) / 2 - center.y);
      var /** @type {number} */ norm2 = Math.abs((child2.aabb.lowerBound.x + child2.aabb.upperBound.x) / 2 - center.x) + Math.abs((child2.aabb.lowerBound.y + child2.aabb.upperBound.y) / 2 - center.y);
      if (norm1 < norm2) {
        sibling = child1;
      } else {
        sibling = child2;
      }
    } while (sibling.IsLeaf() == false);
  }
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node1 = sibling.parent;
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node2 = this.Box2D_Collision_b2DynamicTree_AllocateNode();
  node2.parent = node1;
  node2.userData = null;
  node2.aabb.Combine(leaf.aabb, sibling.aabb);
  if (node1) {
    if (sibling.parent.child1 == sibling) {
      node1.child1 = node2;
    } else {
      node1.child2 = node2;
    }
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    do {
      if (node1.aabb.Contains(node2.aabb))
        break;
      node1.aabb.Combine(node1.child1.aabb, node1.child2.aabb);
      node2 = node1;
      node1 = node1.parent;
    } while (node1);
  } else {
    node2.child1 = sibling;
    node2.child2 = leaf;
    sibling.parent = node2;
    leaf.parent = node2;
    this.Box2D_Collision_b2DynamicTree_m_root = node2;
  }
};


/**
 * @private
 * @param {Box2D.Collision.b2DynamicTreeNode} leaf
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_RemoveLeaf = function(leaf) {
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ sibling = null;
  if (leaf == this.Box2D_Collision_b2DynamicTree_m_root) {
    this.Box2D_Collision_b2DynamicTree_m_root = null;
    return;
  }
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node2 = leaf.parent;
  var /** @type {Box2D.Collision.b2DynamicTreeNode} */ node1 = node2.parent;
  //var /** @type {Box2D.Collision.b2DynamicTreeNode} */ sibling = null;
  if (node2.child1 == leaf) {
    sibling = node2.child2;
  } else {
    sibling = node2.child1;
  }
  if (node1) {
    if (node1.child1 == node2) {
      node1.child1 = sibling;
    } else {
      node1.child2 = sibling;
    }
    sibling.parent = node1;
    this.Box2D_Collision_b2DynamicTree_FreeNode(node2);
    while (node1) {
      var /** @type {Box2D.Collision.b2AABB} */ oldAABB = node1.aabb;
      node1.aabb = Box2D.Collision.b2AABB.Combine2(node1.child1.aabb, node1.child2.aabb);
      if (oldAABB.Contains(node1.aabb))
        break;
      node1 = node1.parent;
    }
  } else {
    this.Box2D_Collision_b2DynamicTree_m_root = sibling;
    sibling.parent = null;
    this.Box2D_Collision_b2DynamicTree_FreeNode(node2);
  }
};


/**
 * @private
 * @type {Box2D.Collision.b2DynamicTreeNode}
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_m_root = null;


/**
 * @private
 * @type {Box2D.Collision.b2DynamicTreeNode}
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_m_freeList = null;


/**
 * @private
 * @type {number}
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_m_path = 0;


/**
 * @private
 * @type {number}
 */
Box2D.Collision.b2DynamicTree.prototype.Box2D_Collision_b2DynamicTree_m_insertionCount = 0;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2DynamicTree.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2DynamicTree', qName: 'Box2D.Collision.b2DynamicTree', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2DynamicTree.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'b2DynamicTree': { type: '', declaredBy: 'Box2D.Collision.b2DynamicTree'},
        'CreateProxy': { type: 'Box2D.Collision.b2DynamicTreeNode', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Box2D.Collision.b2AABB', false ,'*', false ]; }},
        'DestroyProxy': { type: 'void', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Box2D.Collision.b2DynamicTreeNode', false ]; }},
        'MoveProxy': { type: 'Boolean', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Box2D.Collision.b2DynamicTreeNode', false ,'Box2D.Collision.b2AABB', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'Rebalance': { type: 'void', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'int', false ]; }},
        'GetFatAABB': { type: 'Box2D.Collision.b2AABB', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Box2D.Collision.b2DynamicTreeNode', false ]; }},
        'GetUserData': { type: '*', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Box2D.Collision.b2DynamicTreeNode', false ]; }},
        'Query': { type: 'void', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Function', false ,'Box2D.Collision.b2AABB', false ]; }},
        'RayCast': { type: 'void', declaredBy: 'Box2D.Collision.b2DynamicTree', parameters: function () { return [ 'Function', false ,'Box2D.Collision.b2RayCastInput', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2DynamicTree.prototype.ROYALE_COMPILE_FLAGS = 9;
