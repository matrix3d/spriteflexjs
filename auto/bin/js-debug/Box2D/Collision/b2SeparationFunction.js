/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2SeparationFunction.as
 * Box2D.Collision.b2SeparationFunction
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2SeparationFunction');
/* Royale Dependency List: Box2D.Collision.b2DistanceProxy,Box2D.Collision.b2SimplexCache,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings*/




/**
 * @constructor
 */
Box2D.Collision.b2SeparationFunction = function() {

this.m_localPoint = new Box2D.Common.Math.b2Vec2();
this.m_axis = new Box2D.Common.Math.b2Vec2();
};


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Collision.b2SeparationFunction.e_points = 0x1;


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Collision.b2SeparationFunction.e_faceA = 0x2;


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Collision.b2SeparationFunction.e_faceB = 0x4;


/**
 * @param {Box2D.Collision.b2SimplexCache} cache
 * @param {Box2D.Collision.b2DistanceProxy} proxyA
 * @param {Box2D.Common.Math.b2Transform} transformA
 * @param {Box2D.Collision.b2DistanceProxy} proxyB
 * @param {Box2D.Common.Math.b2Transform} transformB
 */
Box2D.Collision.b2SeparationFunction.prototype.Initialize = function(cache, proxyA, transformA, proxyB, transformB) {
  var /** @type {number} */ normalX = NaN;
  var /** @type {number} */ normalY = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB1 = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB2 = null;
  var /** @type {number} */ pointAY = NaN;
  var /** @type {number} */ pointAX = NaN;
  var /** @type {number} */ sgn = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA2 = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA1 = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB = null;
  var /** @type {number} */ s = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {number} */ pointBY = NaN;
  var /** @type {number} */ pointBX = NaN;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  this.m_proxyA = proxyA;
  this.m_proxyB = proxyB;
  var /** @type {number} */ count = (cache.count) >> 0;
  Box2D.Common.b2Settings.b2Assert(0 < count && count < 3);
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA1 = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA2 = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB1 = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB2 = null;
  //var /** @type {number} */ pointAX = NaN;
  //var /** @type {number} */ pointAY = NaN;
  //var /** @type {number} */ pointBX = NaN;
  //var /** @type {number} */ pointBY = NaN;
  //var /** @type {number} */ normalX = NaN;
  //var /** @type {number} */ normalY = NaN;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  //var /** @type {number} */ s = NaN;
  //var /** @type {number} */ sgn = NaN;
  if (count == 1) {
    this.m_type = Box2D.Collision.b2SeparationFunction.e_points;
    localPointA = this.m_proxyA.GetVertex((cache.indexA[0]) >> 0);
    localPointB = this.m_proxyB.GetVertex((cache.indexB[0]) >> 0);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    this.m_axis.x = pointBX - pointAX;
    this.m_axis.y = pointBY - pointAY;
    this.m_axis.Normalize();
  } else if (cache.indexB[0] == cache.indexB[1]) {
    this.m_type = Box2D.Collision.b2SeparationFunction.e_faceA;
    localPointA1 = this.m_proxyA.GetVertex((cache.indexA[0]) >> 0);
    localPointA2 = this.m_proxyA.GetVertex((cache.indexA[1]) >> 0);
    localPointB = this.m_proxyB.GetVertex((cache.indexB[0]) >> 0);
    this.m_localPoint.x = 0.5 * (localPointA1.x + localPointA2.x);
    this.m_localPoint.y = 0.5 * (localPointA1.y + localPointA2.y);
    this.m_axis = Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
    this.m_axis.Normalize();
    tVec = this.m_axis;
    tMat = transformA.R;
    normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tVec = this.m_localPoint;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointB;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    s = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
    if (s < 0.0) {
      this.m_axis.NegativeSelf();
    }
  } else if (cache.indexA[0] == cache.indexA[0]) {
    this.m_type = Box2D.Collision.b2SeparationFunction.e_faceB;
    localPointB1 = this.m_proxyB.GetVertex((cache.indexB[0]) >> 0);
    localPointB2 = this.m_proxyB.GetVertex((cache.indexB[1]) >> 0);
    localPointA = this.m_proxyA.GetVertex((cache.indexA[0]) >> 0);
    this.m_localPoint.x = 0.5 * (localPointB1.x + localPointB2.x);
    this.m_localPoint.y = 0.5 * (localPointB1.y + localPointB2.y);
    this.m_axis = Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
    this.m_axis.Normalize();
    tVec = this.m_axis;
    tMat = transformB.R;
    normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
    normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
    tVec = this.m_localPoint;
    tMat = transformB.R;
    pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    tVec = localPointA;
    tMat = transformA.R;
    pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
    pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
    s = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
    if (s < 0.0) {
      this.m_axis.NegativeSelf();
    }
  } else {
    localPointA1 = this.m_proxyA.GetVertex((cache.indexA[0]) >> 0);
    localPointA2 = this.m_proxyA.GetVertex((cache.indexA[1]) >> 0);
    localPointB1 = this.m_proxyB.GetVertex((cache.indexB[0]) >> 0);
    localPointB2 = this.m_proxyB.GetVertex((cache.indexB[1]) >> 0);
    var /** @type {Box2D.Common.Math.b2Vec2} */ pA = Box2D.Common.Math.b2Math.MulX(transformA, localPointA);
    var /** @type {Box2D.Common.Math.b2Vec2} */ dA = Box2D.Common.Math.b2Math.MulMV(transformA.R, Box2D.Common.Math.b2Math.SubtractVV(localPointA2, localPointA1));
    var /** @type {Box2D.Common.Math.b2Vec2} */ pB = Box2D.Common.Math.b2Math.MulX(transformB, localPointB);
    var /** @type {Box2D.Common.Math.b2Vec2} */ dB = Box2D.Common.Math.b2Math.MulMV(transformB.R, Box2D.Common.Math.b2Math.SubtractVV(localPointB2, localPointB1));
    var /** @type {number} */ a = dA.x * dA.x + dA.y * dA.y;
    var /** @type {number} */ e = dB.x * dB.x + dB.y * dB.y;
    var /** @type {Box2D.Common.Math.b2Vec2} */ r = Box2D.Common.Math.b2Math.SubtractVV(dB, dA);
    var /** @type {number} */ c = dA.x * r.x + dA.y * r.y;
    var /** @type {number} */ f = dB.x * r.x + dB.y * r.y;
    var /** @type {number} */ b = dA.x * dB.x + dA.y * dB.y;
    var /** @type {number} */ denom = a * e - b * b;
    s = 0.0;
    if (denom != 0.0) {
      s = Box2D.Common.Math.b2Math.Clamp((b * f - c * e) / denom, 0.0, 1.0);
    }
    var /** @type {number} */ t = (b * s + f) / e;
    if (t < 0.0) {
      t = 0.0;
      s = Box2D.Common.Math.b2Math.Clamp((b - c) / a, 0.0, 1.0);
    }
    localPointA = new Box2D.Common.Math.b2Vec2();
    localPointA.x = localPointA1.x + s * (localPointA2.x - localPointA1.x);
    localPointA.y = localPointA1.y + s * (localPointA2.y - localPointA1.y);
    localPointB = new Box2D.Common.Math.b2Vec2();
    localPointB.x = localPointB1.x + s * (localPointB2.x - localPointB1.x);
    localPointB.y = localPointB1.y + s * (localPointB2.y - localPointB1.y);
    if (s == 0.0 || s == 1.0) {
      this.m_type = Box2D.Collision.b2SeparationFunction.e_faceB;
      this.m_axis = Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointB2, localPointB1), 1.0);
      this.m_axis.Normalize();
      this.m_localPoint = localPointB;
      tVec = this.m_axis;
      tMat = transformB.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointA;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      sgn = (pointAX - pointBX) * normalX + (pointAY - pointBY) * normalY;
      if (s < 0.0) {
        this.m_axis.NegativeSelf();
      }
    } else {
      this.m_type = Box2D.Collision.b2SeparationFunction.e_faceA;
      this.m_axis = Box2D.Common.Math.b2Math.CrossVF(Box2D.Common.Math.b2Math.SubtractVV(localPointA2, localPointA1), 1.0);
      this.m_localPoint = localPointA;
      tVec = this.m_axis;
      tMat = transformA.R;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tVec = this.m_localPoint;
      tMat = transformA.R;
      pointAX = transformA.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointAY = transformA.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      tVec = localPointB;
      tMat = transformB.R;
      pointBX = transformB.position.x + (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
      pointBY = transformB.position.y + (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
      sgn = (pointBX - pointAX) * normalX + (pointBY - pointAY) * normalY;
      if (s < 0.0) {
        this.m_axis.NegativeSelf();
      }
    }
  }
};


/**
 * @param {Box2D.Common.Math.b2Transform} transformA
 * @param {Box2D.Common.Math.b2Transform} transformB
 * @return {number}
 */
Box2D.Collision.b2SeparationFunction.prototype.Evaluate = function(transformA, transformB) {
  var /** @type {Box2D.Common.Math.b2Vec2} */ normal = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB = null;
  var /** @type {number} */ seperation = NaN;
  var /** @type {Box2D.Common.Math.b2Vec2} */ pointA = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ axisB = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ pointB = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ axisA = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ axisA = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ axisB = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointA = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ localPointB = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ pointA = null;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ pointB = null;
  //var /** @type {number} */ seperation = NaN;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ normal = null;
  switch (this.m_type) {
    case Box2D.Collision.b2SeparationFunction.e_points:
      axisA = Box2D.Common.Math.b2Math.MulTMV(transformA.R, this.m_axis);
      axisB = Box2D.Common.Math.b2Math.MulTMV(transformB.R, this.m_axis.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointA = Box2D.Common.Math.b2Math.MulX(transformA, localPointA);
      pointB = Box2D.Common.Math.b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * this.m_axis.x + (pointB.y - pointA.y) * this.m_axis.y;
      return seperation;
    case Box2D.Collision.b2SeparationFunction.e_faceA:
      normal = Box2D.Common.Math.b2Math.MulMV(transformA.R, this.m_axis);
      pointA = Box2D.Common.Math.b2Math.MulX(transformA, this.m_localPoint);
      axisB = Box2D.Common.Math.b2Math.MulTMV(transformB.R, normal.GetNegative());
      localPointB = this.m_proxyB.GetSupportVertex(axisB);
      pointB = Box2D.Common.Math.b2Math.MulX(transformB, localPointB);
      seperation = (pointB.x - pointA.x) * normal.x + (pointB.y - pointA.y) * normal.y;
      return seperation;
    case Box2D.Collision.b2SeparationFunction.e_faceB:
      normal = Box2D.Common.Math.b2Math.MulMV(transformB.R, this.m_axis);
      pointB = Box2D.Common.Math.b2Math.MulX(transformB, this.m_localPoint);
      axisA = Box2D.Common.Math.b2Math.MulTMV(transformA.R, normal.GetNegative());
      localPointA = this.m_proxyA.GetSupportVertex(axisA);
      pointA = Box2D.Common.Math.b2Math.MulX(transformA, localPointA);
      seperation = (pointA.x - pointB.x) * normal.x + (pointA.y - pointB.y) * normal.y;
      return seperation;
    default:
      Box2D.Common.b2Settings.b2Assert(false);
      return 0.0;
  }
};


/**
 * @type {Box2D.Collision.b2DistanceProxy}
 */
Box2D.Collision.b2SeparationFunction.prototype.m_proxyA = null;


/**
 * @type {Box2D.Collision.b2DistanceProxy}
 */
Box2D.Collision.b2SeparationFunction.prototype.m_proxyB = null;


/**
 * @type {number}
 */
Box2D.Collision.b2SeparationFunction.prototype.m_type = 0;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2SeparationFunction.prototype.m_localPoint = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2SeparationFunction.prototype.m_axis = null;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2SeparationFunction.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2SeparationFunction', qName: 'Box2D.Collision.b2SeparationFunction', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2SeparationFunction.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_proxyA': { type: 'Box2D.Collision.b2DistanceProxy', get_set: function (/** Box2D.Collision.b2SeparationFunction */ inst, /** * */ v) {return v !== undefined ? inst.m_proxyA = v : inst.m_proxyA;}},
        'm_proxyB': { type: 'Box2D.Collision.b2DistanceProxy', get_set: function (/** Box2D.Collision.b2SeparationFunction */ inst, /** * */ v) {return v !== undefined ? inst.m_proxyB = v : inst.m_proxyB;}},
        'm_type': { type: 'int', get_set: function (/** Box2D.Collision.b2SeparationFunction */ inst, /** * */ v) {return v !== undefined ? inst.m_type = v : inst.m_type;}},
        'm_localPoint': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.b2SeparationFunction */ inst, /** * */ v) {return v !== undefined ? inst.m_localPoint = v : inst.m_localPoint;}},
        'm_axis': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.b2SeparationFunction */ inst, /** * */ v) {return v !== undefined ? inst.m_axis = v : inst.m_axis;}}
      };
    },
    methods: function () {
      return {
        'Initialize': { type: 'void', declaredBy: 'Box2D.Collision.b2SeparationFunction', parameters: function () { return [ 'Box2D.Collision.b2SimplexCache', false ,'Box2D.Collision.b2DistanceProxy', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Collision.b2DistanceProxy', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'Evaluate': { type: 'Number', declaredBy: 'Box2D.Collision.b2SeparationFunction', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Transform', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2SeparationFunction.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Collision.b2SeparationFunction.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Collision.b2SeparationFunction);
