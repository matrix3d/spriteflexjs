/**
 * Generated by Apache Royale Compiler from Box2D/Collision/b2WorldManifold.as
 * Box2D.Collision.b2WorldManifold
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Collision.b2WorldManifold');
/* Royale Dependency List: Box2D.Collision.b2Manifold,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings*/




/**
 * @constructor
 */
Box2D.Collision.b2WorldManifold = function() {
  
  this.m_normal = new Box2D.Common.Math.b2Vec2();
  this.m_points = new Array(Box2D.Common.b2Settings.b2_maxManifoldPoints);
  for (var /** @type {number} */ i = 0; i < Box2D.Common.b2Settings.b2_maxManifoldPoints; i++) {
    this.m_points[i] = new Box2D.Common.Math.b2Vec2();
  }
};


/**
 * Evaluate the manifold with supplied transforms. This assumes
 * modest motion from the original state. This does not change the
 * point count, impulses, etc. The radii must come from the shapes
 * that generated the manifold.
 * @param {Box2D.Collision.b2Manifold} manifold
 * @param {Box2D.Common.Math.b2Transform} xfA
 * @param {number} radiusA
 * @param {Box2D.Common.Math.b2Transform} xfB
 * @param {number} radiusB
 */
Box2D.Collision.b2WorldManifold.prototype.Initialize = function(manifold, xfA, radiusA, xfB, radiusB) {
  var /** @type {number} */ normalX = NaN;
  var /** @type {number} */ normalY = NaN;
  var /** @type {number} */ clipPointX = NaN;
  var /** @type {number} */ clipPointY = NaN;
  var /** @type {number} */ planePointY = NaN;
  var /** @type {number} */ planePointX = NaN;
  var /** @type {number} */ i = 0;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  if (manifold.m_pointCount == 0) {
    return;
  }
  //var /** @type {number} */ i = 0;
  //var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = null;
  //var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = null;
  //var /** @type {number} */ normalX = NaN;
  //var /** @type {number} */ normalY = NaN;
  //var /** @type {number} */ planePointX = NaN;
  //var /** @type {number} */ planePointY = NaN;
  //var /** @type {number} */ clipPointX = NaN;
  //var /** @type {number} */ clipPointY = NaN;
  switch (manifold.m_type) {
    case Box2D.Collision.b2Manifold.e_circles:
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      var /** @type {number} */ pointAX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var /** @type {number} */ pointAY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_points[0].m_localPoint;
      var /** @type {number} */ pointBX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      var /** @type {number} */ pointBY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      var /** @type {number} */ dX = pointBX - pointAX;
      var /** @type {number} */ dY = pointBY - pointAY;
      var /** @type {number} */ d2 = dX * dX + dY * dY;
      if (d2 > Number.MIN_VALUE * Number.MIN_VALUE) {
        var /** @type {number} */ d = Math.sqrt(d2);
        this.m_normal.x = dX / d;
        this.m_normal.y = dY / d;
      } else {
        this.m_normal.x = 1;
        this.m_normal.y = 0;
      }
      var /** @type {number} */ cAX = pointAX + radiusA * this.m_normal.x;
      var /** @type {number} */ cAY = pointAY + radiusA * this.m_normal.y;
      var /** @type {number} */ cBX = pointBX - radiusB * this.m_normal.x;
      var /** @type {number} */ cBY = pointBY - radiusB * this.m_normal.y;
      this.m_points[0].x = 0.5 * (cAX + cBX);
      this.m_points[0].y = 0.5 * (cAY + cBY);
      break;
    case Box2D.Collision.b2Manifold.e_faceA:
      tMat = xfA.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfA.R;
      tVec = manifold.m_localPoint;
      planePointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = normalX;
      this.m_normal.y = normalY;
      for (i = 0; i < manifold.m_pointCount; i++) {
        tMat = xfB.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusA - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusB) * normalY;
      }
      break;
    case Box2D.Collision.b2Manifold.e_faceB:
      tMat = xfB.R;
      tVec = manifold.m_localPlaneNormal;
      normalX = tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      normalY = tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      tMat = xfB.R;
      tVec = manifold.m_localPoint;
      planePointX = xfB.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
      planePointY = xfB.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
      this.m_normal.x = -normalX;
      this.m_normal.y = -normalY;
      for (i = 0; i < manifold.m_pointCount; i++) {
        tMat = xfA.R;
        tVec = manifold.m_points[i].m_localPoint;
        clipPointX = xfA.position.x + tMat.col1.x * tVec.x + tMat.col2.x * tVec.y;
        clipPointY = xfA.position.y + tMat.col1.y * tVec.x + tMat.col2.y * tVec.y;
        this.m_points[i].x = clipPointX + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalX;
        this.m_points[i].y = clipPointY + 0.5 * (radiusB - (clipPointX - planePointX) * normalX - (clipPointY - planePointY) * normalY - radiusA) * normalY;
      }
      break;
  }
};


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Collision.b2WorldManifold.prototype.m_normal = null;


/**
 * @type {Array}
 */
Box2D.Collision.b2WorldManifold.prototype.m_points = null;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Collision.b2WorldManifold.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2WorldManifold', qName: 'Box2D.Collision.b2WorldManifold', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Collision.b2WorldManifold.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_normal': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Collision.b2WorldManifold */ inst, /** * */ v) {return v !== undefined ? inst.m_normal = v : inst.m_normal;}},
        'm_points': { type: 'Array', get_set: function (/** Box2D.Collision.b2WorldManifold */ inst, /** * */ v) {return v !== undefined ? inst.m_points = v : inst.m_points;}}
      };
    },
    methods: function () {
      return {
        'b2WorldManifold': { type: '', declaredBy: 'Box2D.Collision.b2WorldManifold'},
        'Initialize': { type: 'void', declaredBy: 'Box2D.Collision.b2WorldManifold', parameters: function () { return [ 'Box2D.Collision.b2Manifold', false ,'Box2D.Common.Math.b2Transform', false ,'Number', false ,'Box2D.Common.Math.b2Transform', false ,'Number', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Collision.b2WorldManifold.prototype.ROYALE_COMPILE_FLAGS = 9;
