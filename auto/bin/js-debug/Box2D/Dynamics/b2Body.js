/**
 * Generated by Apache Royale Compiler from Box2D/Dynamics/b2Body.as
 * Box2D.Dynamics.b2Body
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Dynamics.b2Body');
/* Royale Dependency List: Box2D.Collision.IBroadPhase,Box2D.Collision.Shapes.b2EdgeShape,Box2D.Collision.Shapes.b2MassData,Box2D.Collision.Shapes.b2Shape,Box2D.Common.Math.b2Mat22,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Sweep,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Settings,Box2D.Dynamics.Contacts.b2Contact,Box2D.Dynamics.Contacts.b2ContactEdge,Box2D.Dynamics.Controllers.b2ControllerEdge,Box2D.Dynamics.Joints.b2JointEdge,Box2D.Dynamics.b2BodyDef,Box2D.Dynamics.b2Fixture,Box2D.Dynamics.b2FixtureDef,Box2D.Dynamics.b2World*/




/**
 * @asprivate
 * @constructor
 * @param {Box2D.Dynamics.b2BodyDef} bd
 * @param {Box2D.Dynamics.b2World} world
 */
Box2D.Dynamics.b2Body = function(bd, world) {
  
  this.m_xf = new Box2D.Common.Math.b2Transform();
  this.m_sweep = new Box2D.Common.Math.b2Sweep();
  this.m_linearVelocity = new Box2D.Common.Math.b2Vec2();
  this.m_force = new Box2D.Common.Math.b2Vec2();
  this.m_flags = 0;
  if (bd.bullet) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_bulletFlag;
  }
  if (bd.fixedRotation) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_fixedRotationFlag;
  }
  if (bd.allowSleep) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_allowSleepFlag;
  }
  if (bd.awake) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_awakeFlag;
  }
  if (bd.active) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_activeFlag;
  }
  this.m_world = world;
  this.m_xf.position.SetV(bd.position);
  this.m_xf.R.Set(bd.angle);
  this.m_sweep.localCenter.SetZero();
  this.m_sweep.t0 = 1.0;
  this.m_sweep.a0 = this.m_sweep.a = bd.angle;
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = this.m_xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_jointList = null;
  this.m_controllerList = null;
  this.m_contactList = null;
  this.m_controllerCount = 0;
  this.m_prev = null;
  this.m_next = null;
  this.m_linearVelocity.SetV(bd.linearVelocity);
  this.m_angularVelocity = bd.angularVelocity;
  this.m_linearDamping = bd.linearDamping;
  this.m_angularDamping = bd.angularDamping;
  this.m_force.Set(0.0, 0.0);
  this.m_torque = 0.0;
  this.m_sleepTime = 0.0;
  this.m_type = (bd.type) >> 0;
  if (this.m_type == Box2D.Dynamics.b2Body.b2_dynamicBody) {
    this.m_mass = 1.0;
    this.m_invMass = 1.0;
  } else {
    this.m_mass = 0.0;
    this.m_invMass = 0.0;
  }
  this.m_I = 0.0;
  this.m_invI = 0.0;
  this.m_inertiaScale = bd.inertiaScale;
  this.Box2D_Dynamics_b2Body_m_userData = bd.userData;
  this.m_fixtureList = null;
  this.m_fixtureCount = 0;
};


/**
 * @private
 * @param {Box2D.Collision.Shapes.b2EdgeShape} s1
 * @param {Box2D.Collision.Shapes.b2EdgeShape} s2
 * @param {number} angle1
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.Box2D_Dynamics_b2Body_connectEdges = function(s1, s2, angle1) {
  var /** @type {number} */ angle2 = Math.atan2(s2.GetDirectionVector().y, s2.GetDirectionVector().x);
  var /** @type {number} */ coreOffset = Math.tan((angle2 - angle1) * 0.5);
  var /** @type {Box2D.Common.Math.b2Vec2} */ core = Box2D.Common.Math.b2Math.MulFV(coreOffset, s2.GetDirectionVector());
  core = Box2D.Common.Math.b2Math.SubtractVV(core, s2.GetNormalVector());
  core = Box2D.Common.Math.b2Math.MulFV(Box2D.Common.b2Settings.b2_toiSlop, core);
  core = Box2D.Common.Math.b2Math.AddVV(core, s2.GetVertex1());
  var /** @type {Box2D.Common.Math.b2Vec2} */ cornerDir = Box2D.Common.Math.b2Math.AddVV(s1.GetDirectionVector(), s2.GetDirectionVector());
  cornerDir.Normalize();
  var /** @type {boolean} */ convex = Box2D.Common.Math.b2Math.Dot(s1.GetDirectionVector(), s2.GetNormalVector()) > 0.0;
  s1.SetNextEdge(s2, core, cornerDir, convex);
  s2.SetPrevEdge(s1, core, cornerDir, convex);
  return angle2;
};


/**
 * Creates a fixture and attach it to this body. Use this function if you need
 * to set some fixture parameters, like friction. Otherwise you can create the
 * fixture directly from a shape.
 * If the density is non-zero, this function automatically updates the mass of the body.
 * Contacts are not created until the next time step.
 * @asparam fixtureDef the fixture definition.
 * @param {Box2D.Dynamics.b2FixtureDef} def
 * @return {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Body.prototype.CreateFixture = function(def) {
  if (this.m_world.IsLocked() == true) {
    return null;
  }
  var /** @type {Box2D.Dynamics.b2Fixture} */ fixture = new Box2D.Dynamics.b2Fixture();
  fixture.Create(this, this.m_xf, def);
  if (this.m_flags & Box2D.Dynamics.b2Body.e_activeFlag) {
    var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.CreateProxy(broadPhase, this.m_xf);
  }
  fixture.m_next = this.m_fixtureList;
  this.m_fixtureList = fixture;
  ++this.m_fixtureCount;
  fixture.m_body = this;
  if (fixture.m_density > 0.0) {
    this.ResetMassData();
  }
  this.m_world.m_flags |= Box2D.Dynamics.b2World.e_newFixture;
  return fixture;
};


/**
 * Creates a fixture from a shape and attach it to this body.
 * This is a convenience function. Use b2FixtureDef if you need to set parameters
 * like friction, restitution, user data, or filtering.
 * This function automatically updates the mass of the body.
 * @asparam shape the shape to be cloned.
 * @asparam density the shape density (set to zero for static bodies).
 * warning This function is locked during callbacks.
 * @param {Box2D.Collision.Shapes.b2Shape} shape
 * @param {number=} density
 * @return {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Body.prototype.CreateFixture2 = function(shape, density) {
  density = typeof density !== 'undefined' ? density : 0.0;
  var /** @type {Box2D.Dynamics.b2FixtureDef} */ def = new Box2D.Dynamics.b2FixtureDef();
  def.shape = shape;
  def.density = density;
  return this.CreateFixture(def);
};


/**
 * Destroy a fixture. This removes the fixture from the broad-phase and
 * destroys all contacts associated with this fixture. This will
 * automatically adjust the mass of the body if the body is dynamic and the
 * fixture has positive density.
 * All fixtures attached to a body are implicitly destroyed when the body is destroyed.
 * @asparam fixture the fixture to be removed.
 * warning This function is locked during callbacks.
 * @param {Box2D.Dynamics.b2Fixture} fixture
 */
Box2D.Dynamics.b2Body.prototype.DestroyFixture = function(fixture) {
  if (this.m_world.IsLocked() == true) {
    return;
  }
  var /** @type {Box2D.Dynamics.b2Fixture} */ node = this.m_fixtureList;
  var /** @type {Box2D.Dynamics.b2Fixture} */ ppF = null;
  var /** @type {boolean} */ found = false;
  while (node != null) {
    if (node == fixture) {
      if (ppF)
        ppF.m_next = fixture.m_next;
      else
        this.m_fixtureList = fixture.m_next;
      found = true;
      break;
    }
    ppF = node;
    node = node.m_next;
  }
  var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ edge = this.m_contactList;
  while (edge) {
    var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ c = edge.contact;
    edge = edge.next;
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureA = c.GetFixtureA();
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureB = c.GetFixtureB();
    if (fixture == fixtureA || fixture == fixtureB) {
      this.m_world.m_contactManager.Destroy(c);
    }
  }
  if (this.m_flags & Box2D.Dynamics.b2Body.e_activeFlag) {
    var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_world.m_contactManager.m_broadPhase;
    fixture.DestroyProxy(broadPhase);
  } else {
  }
  fixture.Destroy();
  fixture.m_body = null;
  fixture.m_next = null;
  --this.m_fixtureCount;
  this.ResetMassData();
};


/**
 * Set the position of the body's origin and rotation (radians).
 * This breaks any contacts and wakes the other bodies.
 * @asparam position the new world position of the body's origin (not necessarily
 * the center of mass).
 * @asparam angle the new world rotation angle of the body in radians.
 * @param {Box2D.Common.Math.b2Vec2} position
 * @param {number} angle
 */
Box2D.Dynamics.b2Body.prototype.SetPositionAndAngle = function(position, angle) {
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  if (this.m_world.IsLocked() == true) {
    return;
  }
  this.m_xf.R.Set(angle);
  this.m_xf.position.SetV(position);
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = this.m_xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = this.m_sweep.localCenter;
  this.m_sweep.c.x = (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_sweep.c.y = (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  this.m_sweep.c.x += this.m_xf.position.x;
  this.m_sweep.c.y += this.m_xf.position.y;
  this.m_sweep.c0.SetV(this.m_sweep.c);
  this.m_sweep.a0 = this.m_sweep.a = angle;
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for (f = this.m_fixtureList; f; f = f.m_next) {
    f.Synchronize(broadPhase, this.m_xf, this.m_xf);
  }
  this.m_world.m_contactManager.FindNewContacts();
};


/**
 * Set the position of the body's origin and rotation (radians).
 * This breaks any contacts and wakes the other bodies.
 * Note this is less efficient than the other overload - you should use that
 * if the angle is available.
 * @asparam xf the transform of position and angle to set the bdoy to.
 * @param {Box2D.Common.Math.b2Transform} xf
 */
Box2D.Dynamics.b2Body.prototype.SetTransform = function(xf) {
  this.SetPositionAndAngle(xf.position, xf.GetAngle());
};


/**
 * Get the body transform for the body's origin.
 * @asreturn the world transform of the body's origin.
 * @return {Box2D.Common.Math.b2Transform}
 */
Box2D.Dynamics.b2Body.prototype.GetTransform = function() {
  return this.m_xf;
};


/**
 * Get the world body origin position.
 * @asreturn the world position of the body's origin.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetPosition = function() {
  return this.m_xf.position;
};


/**
 * Setthe world body origin position.
 * @asparam position the new position of the body
 * @param {Box2D.Common.Math.b2Vec2} position
 */
Box2D.Dynamics.b2Body.prototype.SetPosition = function(position) {
  this.SetPositionAndAngle(position, this.GetAngle());
};


/**
 * Get the angle in radians.
 * @asreturn the current world rotation angle in radians.
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetAngle = function() {
  return this.m_sweep.a;
};


/**
 * Set the world body angle
 * @asparam angle the new angle of the body.
 * @param {number} angle
 */
Box2D.Dynamics.b2Body.prototype.SetAngle = function(angle) {
  this.SetPositionAndAngle(this.GetPosition(), angle);
};


/**
 * Get the world position of the center of mass.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetWorldCenter = function() {
  return this.m_sweep.c;
};


/**
 * Get the local position of the center of mass.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLocalCenter = function() {
  return this.m_sweep.localCenter;
};


/**
 * Set the linear velocity of the center of mass.
 * @asparam v the new linear velocity of the center of mass.
 * @param {Box2D.Common.Math.b2Vec2} v
 */
Box2D.Dynamics.b2Body.prototype.SetLinearVelocity = function(v) {
  if (this.m_type == Box2D.Dynamics.b2Body.b2_staticBody) {
    return;
  }
  this.m_linearVelocity.SetV(v);
};


/**
 * Get the linear velocity of the center of mass.
 * @asreturn the linear velocity of the center of mass.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocity = function() {
  return this.m_linearVelocity;
};


/**
 * Set the angular velocity.
 * @asparam omega the new angular velocity in radians/second.
 * @param {number} omega
 */
Box2D.Dynamics.b2Body.prototype.SetAngularVelocity = function(omega) {
  if (this.m_type == Box2D.Dynamics.b2Body.b2_staticBody) {
    return;
  }
  this.m_angularVelocity = omega;
};


/**
 * Get the angular velocity.
 * @asreturn the angular velocity in radians/second.
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetAngularVelocity = function() {
  return this.m_angularVelocity;
};


/**
 * Get the definition containing the body properties.
 * asonly
 * @return {Box2D.Dynamics.b2BodyDef}
 */
Box2D.Dynamics.b2Body.prototype.GetDefinition = function() {
  var /** @type {Box2D.Dynamics.b2BodyDef} */ bd = new Box2D.Dynamics.b2BodyDef();
  bd.type = this.GetType();
  bd.allowSleep = (this.m_flags & Box2D.Dynamics.b2Body.e_allowSleepFlag) == Box2D.Dynamics.b2Body.e_allowSleepFlag;
  bd.angle = this.GetAngle();
  bd.angularDamping = this.m_angularDamping;
  bd.angularVelocity = this.m_angularVelocity;
  bd.fixedRotation = (this.m_flags & Box2D.Dynamics.b2Body.e_fixedRotationFlag) == Box2D.Dynamics.b2Body.e_fixedRotationFlag;
  bd.bullet = (this.m_flags & Box2D.Dynamics.b2Body.e_bulletFlag) == Box2D.Dynamics.b2Body.e_bulletFlag;
  bd.awake = (this.m_flags & Box2D.Dynamics.b2Body.e_awakeFlag) == Box2D.Dynamics.b2Body.e_awakeFlag;
  bd.linearDamping = this.m_linearDamping;
  bd.linearVelocity.SetV(this.GetLinearVelocity());
  bd.position = this.GetPosition();
  bd.userData = this.GetUserData();
  return bd;
};


/**
 * Apply a force at a world point. If the force is not
 * applied at the center of mass, it will generate a torque and
 * affect the angular velocity. This wakes up the body.
 * @asparam force the world force vector, usually in Newtons (N).
 * @asparam point the world position of the point of application.
 * @param {Box2D.Common.Math.b2Vec2} force
 * @param {Box2D.Common.Math.b2Vec2} point
 */
Box2D.Dynamics.b2Body.prototype.ApplyForce = function(force, point) {
  if (this.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody) {
    return;
  }
  if (this.IsAwake() == false) {
    this.SetAwake(true);
  }
  this.m_force.x += force.x;
  this.m_force.y += force.y;
  this.m_torque += ((point.x - this.m_sweep.c.x) * force.y - (point.y - this.m_sweep.c.y) * force.x);
};


/**
 * Apply a torque. This affects the angular velocity
 * without affecting the linear velocity of the center of mass.
 * This wakes up the body.
 * @asparam torque about the z-axis (out of the screen), usually in N-m.
 * @param {number} torque
 */
Box2D.Dynamics.b2Body.prototype.ApplyTorque = function(torque) {
  if (this.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody) {
    return;
  }
  if (this.IsAwake() == false) {
    this.SetAwake(true);
  }
  this.m_torque += torque;
};


/**
 * Apply an impulse at a point. This immediately modifies the velocity.
 * It also modifies the angular velocity if the point of application
 * is not at the center of mass. This wakes up the body.
 * @asparam impulse the world impulse vector, usually in N-seconds or kg-m/s.
 * @asparam point the world position of the point of application.
 * @param {Box2D.Common.Math.b2Vec2} impulse
 * @param {Box2D.Common.Math.b2Vec2} point
 */
Box2D.Dynamics.b2Body.prototype.ApplyImpulse = function(impulse, point) {
  if (this.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody) {
    return;
  }
  if (this.IsAwake() == false) {
    this.SetAwake(true);
  }
  this.m_linearVelocity.x += this.m_invMass * impulse.x;
  this.m_linearVelocity.y += this.m_invMass * impulse.y;
  this.m_angularVelocity += this.m_invI * ((point.x - this.m_sweep.c.x) * impulse.y - (point.y - this.m_sweep.c.y) * impulse.x);
};


/**
 * Splits a body into two, preserving dynamic properties
 * @asparam	callback Called once per fixture, return true to move this fixture to the new body
 * <code>function Callback(fixture:b2Fixture):Boolean</code>
 * @asreturn The newly created bodies
 * asonly
 * @param {Function} callback
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Body.prototype.Split = function(callback) {
  var /** @type {Box2D.Dynamics.b2Fixture} */ prev = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ linearVelocity = this.GetLinearVelocity().Copy();
  var /** @type {number} */ angularVelocity = this.GetAngularVelocity();
  var /** @type {Box2D.Common.Math.b2Vec2} */ center = this.GetWorldCenter();
  var /** @type {Box2D.Dynamics.b2Body} */ body1 = this;
  var /** @type {Box2D.Dynamics.b2Body} */ body2 = this.m_world.CreateBody(this.GetDefinition());
  //var /** @type {Box2D.Dynamics.b2Fixture} */ prev = null;
  for (var /** @type {Box2D.Dynamics.b2Fixture} */ f = body1.m_fixtureList; f;) {
    if (callback(f)) {
      var /** @type {Box2D.Dynamics.b2Fixture} */ next = f.m_next;
      if (prev) {
        prev.m_next = next;
      } else {
        body1.m_fixtureList = next;
      }
      body1.m_fixtureCount--;
      f.m_next = body2.m_fixtureList;
      body2.m_fixtureList = f;
      body2.m_fixtureCount++;
      f.m_body = body2;
      f = next;
    } else {
      prev = f;
      f = f.m_next;
    }
  }
  body1.ResetMassData();
  body2.ResetMassData();
  var /** @type {Box2D.Common.Math.b2Vec2} */ center1 = body1.GetWorldCenter();
  var /** @type {Box2D.Common.Math.b2Vec2} */ center2 = body2.GetWorldCenter();
  var /** @type {Box2D.Common.Math.b2Vec2} */ velocity1 = Box2D.Common.Math.b2Math.AddVV(linearVelocity, Box2D.Common.Math.b2Math.CrossFV(angularVelocity, Box2D.Common.Math.b2Math.SubtractVV(center1, center)));
  var /** @type {Box2D.Common.Math.b2Vec2} */ velocity2 = Box2D.Common.Math.b2Math.AddVV(linearVelocity, Box2D.Common.Math.b2Math.CrossFV(angularVelocity, Box2D.Common.Math.b2Math.SubtractVV(center2, center)));
  body1.SetLinearVelocity(velocity1);
  body2.SetLinearVelocity(velocity2);
  body1.SetAngularVelocity(angularVelocity);
  body2.SetAngularVelocity(angularVelocity);
  body1.SynchronizeFixtures();
  body2.SynchronizeFixtures();
  return body2;
};


/**
 * Merges another body into this. Only fixtures, mass and velocity are effected,
 * Other properties are ignored
 * asonly
 * @param {Box2D.Dynamics.b2Body} other
 */
Box2D.Dynamics.b2Body.prototype.Merge = function(other) {
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  for (f = other.m_fixtureList; f;) {
    var /** @type {Box2D.Dynamics.b2Fixture} */ next = f.m_next;
    other.m_fixtureCount--;
    f.m_next = this.m_fixtureList;
    this.m_fixtureList = f;
    this.m_fixtureCount++;
    f.m_body = null;
    f = next;
  }
  var /** @type {Box2D.Dynamics.b2Body} */ body1 = this;
  var /** @type {Box2D.Dynamics.b2Body} */ body2 = other;
  var /** @type {Box2D.Common.Math.b2Vec2} */ center1 = body1.GetWorldCenter();
  var /** @type {Box2D.Common.Math.b2Vec2} */ center2 = body2.GetWorldCenter();
  var /** @type {Box2D.Common.Math.b2Vec2} */ velocity1 = body1.GetLinearVelocity().Copy();
  var /** @type {Box2D.Common.Math.b2Vec2} */ velocity2 = body2.GetLinearVelocity().Copy();
  var /** @type {number} */ angular1 = body1.GetAngularVelocity();
  var /** @type {number} */ angular = body2.GetAngularVelocity();
  body1.ResetMassData();
  this.SynchronizeFixtures();
};


/**
 * Get the total mass of the body.
 * @asreturn the mass, usually in kilograms (kg).
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetMass = function() {
  return this.m_mass;
};


/**
 * Get the central rotational inertia of the body.
 * @asreturn the rotational inertia, usually in kg-m^2.
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetInertia = function() {
  return this.m_I;
};


/** 
 * Get the mass data of the body. The rotational inertial is relative to the center of mass.
 * @param {Box2D.Collision.Shapes.b2MassData} data
 */
Box2D.Dynamics.b2Body.prototype.GetMassData = function(data) {
  data.mass = this.m_mass;
  data.I = this.m_I;
  data.center.SetV(this.m_sweep.localCenter);
};


/**
 * Set the mass properties to override the mass properties of the fixtures
 * Note that this changes the center of mass position.
 * Note that creating or destroying fixtures can also alter the mass.
 * This function has no effect if the body isn't dynamic.
 * warning The supplied rotational inertia should be relative to the center of mass
 * @asparam	data the mass properties.
 * @param {Box2D.Collision.Shapes.b2MassData} massData
 */
Box2D.Dynamics.b2Body.prototype.SetMassData = function(massData) {
  Box2D.Common.b2Settings.b2Assert(this.m_world.IsLocked() == false);
  if (this.m_world.IsLocked() == true) {
    return;
  }
  if (this.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody) {
    return;
  }
  this.m_invMass = 0.0;
  this.m_I = 0.0;
  this.m_invI = 0.0;
  this.m_mass = massData.mass;
  if (this.m_mass <= 0.0) {
    this.m_mass = 1.0;
  }
  this.m_invMass = 1.0 / this.m_mass;
  if (massData.I > 0.0 && (this.m_flags & Box2D.Dynamics.b2Body.e_fixedRotationFlag) == 0) {
    this.m_I = massData.I - this.m_mass * (massData.center.x * massData.center.x + massData.center.y * massData.center.y);
    this.m_invI = 1.0 / this.m_I;
  }
  var /** @type {Box2D.Common.Math.b2Vec2} */ oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(massData.center);
  this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x);
};


/**
 * This resets the mass properties to the sum of the mass properties of the fixtures.
 * This normally does not need to be called unless you called SetMassData to override
 * the mass and later you want to reset the mass.
 */
Box2D.Dynamics.b2Body.prototype.ResetMassData = function() {
  this.m_mass = 0.0;
  this.m_invMass = 0.0;
  this.m_I = 0.0;
  this.m_invI = 0.0;
  this.m_sweep.localCenter.SetZero();
  if (this.m_type == Box2D.Dynamics.b2Body.b2_staticBody || this.m_type == Box2D.Dynamics.b2Body.b2_kinematicBody) {
    return;
  }
  var /** @type {Box2D.Common.Math.b2Vec2} */ center = Box2D.Common.Math.b2Vec2.Make(0, 0);
  for (var /** @type {Box2D.Dynamics.b2Fixture} */ f = this.m_fixtureList; f; f = f.m_next) {
    if (f.m_density == 0.0) {
      continue;
    }
    var /** @type {Box2D.Collision.Shapes.b2MassData} */ massData = f.GetMassData();
    this.m_mass += massData.mass;
    center.x += massData.center.x * massData.mass;
    center.y += massData.center.y * massData.mass;
    this.m_I += massData.I;
  }
  if (this.m_mass > 0.0) {
    this.m_invMass = 1.0 / this.m_mass;
    center.x *= this.m_invMass;
    center.y *= this.m_invMass;
  } else {
    this.m_mass = 1.0;
    this.m_invMass = 1.0;
  }
  if (this.m_I > 0.0 && (this.m_flags & Box2D.Dynamics.b2Body.e_fixedRotationFlag) == 0) {
    this.m_I -= this.m_mass * (center.x * center.x + center.y * center.y);
    this.m_I *= this.m_inertiaScale;
    Box2D.Common.b2Settings.b2Assert(this.m_I > 0);
    this.m_invI = 1.0 / this.m_I;
  } else {
    this.m_I = 0.0;
    this.m_invI = 0.0;
  }
  var /** @type {Box2D.Common.Math.b2Vec2} */ oldCenter = this.m_sweep.c.Copy();
  this.m_sweep.localCenter.SetV(center);
  this.m_sweep.c0.SetV(Box2D.Common.Math.b2Math.MulX(this.m_xf, this.m_sweep.localCenter));
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_linearVelocity.x += this.m_angularVelocity * -(this.m_sweep.c.y - oldCenter.y);
  this.m_linearVelocity.y += this.m_angularVelocity * +(this.m_sweep.c.x - oldCenter.x);
};


/**
 * Get the world coordinates of a point given the local coordinates.
 * @asparam localPoint a point on the body measured relative the the body's origin.
 * @asreturn the same point expressed in world coordinates.
 * @param {Box2D.Common.Math.b2Vec2} localPoint
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetWorldPoint = function(localPoint) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ A = this.m_xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ u = new Box2D.Common.Math.b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  u.x += this.m_xf.position.x;
  u.y += this.m_xf.position.y;
  return u;
};


/**
 * Get the world coordinates of a vector given the local coordinates.
 * @asparam localVector a vector fixed in the body.
 * @asreturn the same vector expressed in world coordinates.
 * @param {Box2D.Common.Math.b2Vec2} localVector
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetWorldVector = function(localVector) {
  return Box2D.Common.Math.b2Math.MulMV(this.m_xf.R, localVector);
};


/**
 * Gets a local point relative to the body's origin given a world point.
 * @asparam a point in world coordinates.
 * @asreturn the corresponding local point relative to the body's origin.
 * @param {Box2D.Common.Math.b2Vec2} worldPoint
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLocalPoint = function(worldPoint) {
  return Box2D.Common.Math.b2Math.MulXT(this.m_xf, worldPoint);
};


/**
 * Gets a local vector given a world vector.
 * @asparam a vector in world coordinates.
 * @asreturn the corresponding local vector.
 * @param {Box2D.Common.Math.b2Vec2} worldVector
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLocalVector = function(worldVector) {
  return Box2D.Common.Math.b2Math.MulTMV(this.m_xf.R, worldVector);
};


/**
 * Get the world linear velocity of a world point attached to this body.
 * @asparam a point in world coordinates.
 * @asreturn the world velocity of a point.
 * @param {Box2D.Common.Math.b2Vec2} worldPoint
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocityFromWorldPoint = function(worldPoint) {
  return new Box2D.Common.Math.b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
};


/**
 * Get the world velocity of a local point.
 * @asparam a point in local coordinates.
 * @asreturn the world velocity of a point.
 * @param {Box2D.Common.Math.b2Vec2} localPoint
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.GetLinearVelocityFromLocalPoint = function(localPoint) {
  var /** @type {Box2D.Common.Math.b2Mat22} */ A = this.m_xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ worldPoint = new Box2D.Common.Math.b2Vec2(A.col1.x * localPoint.x + A.col2.x * localPoint.y, A.col1.y * localPoint.x + A.col2.y * localPoint.y);
  worldPoint.x += this.m_xf.position.x;
  worldPoint.y += this.m_xf.position.y;
  return new Box2D.Common.Math.b2Vec2(this.m_linearVelocity.x - this.m_angularVelocity * (worldPoint.y - this.m_sweep.c.y), this.m_linearVelocity.y + this.m_angularVelocity * (worldPoint.x - this.m_sweep.c.x));
};


/**
 * Get the linear damping of the body.
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetLinearDamping = function() {
  return this.m_linearDamping;
};


/**
 * Set the linear damping of the body.
 * @param {number} linearDamping
 */
Box2D.Dynamics.b2Body.prototype.SetLinearDamping = function(linearDamping) {
  this.m_linearDamping = linearDamping;
};


/**
 * Get the angular damping of the body
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetAngularDamping = function() {
  return this.m_angularDamping;
};


/**
 * Set the angular damping of the body.
 * @param {number} angularDamping
 */
Box2D.Dynamics.b2Body.prototype.SetAngularDamping = function(angularDamping) {
  this.m_angularDamping = angularDamping;
};


/**
 * Set the type of this body. This may alter the mass and velocity
 * @asparam	type - enum stored as a static member of b2Body
 * @param {number} type
 */
Box2D.Dynamics.b2Body.prototype.SetType = function(type) {
  if (this.m_type == type) {
    return;
  }
  this.m_type = (type) >> 0;
  this.ResetMassData();
  if (this.m_type == Box2D.Dynamics.b2Body.b2_staticBody) {
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0.0;
  }
  this.SetAwake(true);
  this.m_force.SetZero();
  this.m_torque = 0.0;
  for (var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce = this.m_contactList; ce; ce = ce.next) {
    ce.contact.FlagForFiltering();
  }
};


/**
 * Get the type of this body.
 * @asreturn type enum as a uint
 * @return {number}
 */
Box2D.Dynamics.b2Body.prototype.GetType = function() {
  return (this.m_type) >>> 0;
};


/**
 * Should this body be treated like a bullet for continuous collision detection?
 * @param {boolean} flag
 */
Box2D.Dynamics.b2Body.prototype.SetBullet = function(flag) {
  if (flag) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_bulletFlag;
  } else {
    this.m_flags &= (~Box2D.Dynamics.b2Body.e_bulletFlag) >>> 0;
  }
};


/**
 * Is this body treated like a bullet for continuous collision detection?
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.IsBullet = function() {
  return (this.m_flags & Box2D.Dynamics.b2Body.e_bulletFlag) == Box2D.Dynamics.b2Body.e_bulletFlag;
};


/**
 * Is this body allowed to sleep
 * @asparam	flag
 * @param {boolean} flag
 */
Box2D.Dynamics.b2Body.prototype.SetSleepingAllowed = function(flag) {
  if (flag) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_allowSleepFlag;
  } else {
    this.m_flags &= (~Box2D.Dynamics.b2Body.e_allowSleepFlag) >>> 0;
    this.SetAwake(true);
  }
};


/**
 * Set the sleep state of the body. A sleeping body has vety low CPU cost.
 * @asparam	flag - set to true to put body to sleep, false to wake it
 * @param {boolean} flag
 */
Box2D.Dynamics.b2Body.prototype.SetAwake = function(flag) {
  if (flag) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_awakeFlag;
    this.m_sleepTime = 0.0;
  } else {
    this.m_flags &= (~Box2D.Dynamics.b2Body.e_awakeFlag) >>> 0;
    this.m_sleepTime = 0.0;
    this.m_linearVelocity.SetZero();
    this.m_angularVelocity = 0.0;
    this.m_force.SetZero();
    this.m_torque = 0.0;
  }
};


/**
 * Get the sleeping state of this body.
 * @asreturn true if body is sleeping
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.IsAwake = function() {
  return (this.m_flags & Box2D.Dynamics.b2Body.e_awakeFlag) == Box2D.Dynamics.b2Body.e_awakeFlag;
};


/**
 * Set this body to have fixed rotation. This causes the mass to be reset.
 * @asparam	fixed - true means no rotation
 * @param {boolean} fixed
 */
Box2D.Dynamics.b2Body.prototype.SetFixedRotation = function(fixed) {
  if (fixed) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_fixedRotationFlag;
  } else {
    this.m_flags &= (~Box2D.Dynamics.b2Body.e_fixedRotationFlag) >>> 0;
  }
  this.ResetMassData();
};


/**
 * Does this body have fixed rotation?
 * @asreturn true means fixed rotation
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.IsFixedRotation = function() {
  return (this.m_flags & Box2D.Dynamics.b2Body.e_fixedRotationFlag) == Box2D.Dynamics.b2Body.e_fixedRotationFlag;
};


/** Set the active state of the body. An inactive body is not
 * simulated and cannot be collided with or woken up.
 * If you pass a flag of true, all fixtures will be added to the
 * broad-phase.
 * If you pass a flag of false, all fixtures will be removed from
 * the broad-phase and all contacts will be destroyed.
 * Fixtures and joints are otherwise unaffected. You may continue
 * to create/destroy fixtures and joints on inactive bodies.
 * Fixtures on an inactive body are implicitly inactive and will
 * not participate in collisions, ray-casts, or queries.
 * Joints connected to an inactive body are implicitly inactive.
 * An inactive body is still owned by a b2World object and remains
 * in the body list.
 * @param {boolean} flag
 */
Box2D.Dynamics.b2Body.prototype.SetActive = function(flag) {
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = null;
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  if (flag == this.IsActive()) {
    return;
  }
  //var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  if (flag) {
    this.m_flags |= Box2D.Dynamics.b2Body.e_activeFlag;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for (f = this.m_fixtureList; f; f = f.m_next) {
      f.CreateProxy(broadPhase, this.m_xf);
    }
  } else {
    this.m_flags &= (~Box2D.Dynamics.b2Body.e_activeFlag) >>> 0;
    broadPhase = this.m_world.m_contactManager.m_broadPhase;
    for (f = this.m_fixtureList; f; f = f.m_next) {
      f.DestroyProxy(broadPhase);
    }
    var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce = this.m_contactList;
    while (ce) {
      var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce0 = ce;
      ce = ce.next;
      this.m_world.m_contactManager.Destroy(ce0.contact);
    }
    this.m_contactList = null;
  }
};


/**
 * Get the active state of the body.
 * @asreturn true if active.
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.IsActive = function() {
  return (this.m_flags & Box2D.Dynamics.b2Body.e_activeFlag) == Box2D.Dynamics.b2Body.e_activeFlag;
};


/**
 * Is this body allowed to sleep?
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.IsSleepingAllowed = function() {
  return (this.m_flags & Box2D.Dynamics.b2Body.e_allowSleepFlag) == Box2D.Dynamics.b2Body.e_allowSleepFlag;
};


/**
 * Get the list of all fixtures attached to this body.
 * @return {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Body.prototype.GetFixtureList = function() {
  return this.m_fixtureList;
};


/**
 * Get the list of all joints attached to this body.
 * @return {Box2D.Dynamics.Joints.b2JointEdge}
 */
Box2D.Dynamics.b2Body.prototype.GetJointList = function() {
  return this.m_jointList;
};


/**
 * Get the list of all controllers attached to this body.
 * @return {Box2D.Dynamics.Controllers.b2ControllerEdge}
 */
Box2D.Dynamics.b2Body.prototype.GetControllerList = function() {
  return this.m_controllerList;
};


/**
 * Get a list of all contacts attached to this body.
 * @return {Box2D.Dynamics.Contacts.b2ContactEdge}
 */
Box2D.Dynamics.b2Body.prototype.GetContactList = function() {
  return this.m_contactList;
};


/**
 * Get the next body in the world's body list.
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Body.prototype.GetNext = function() {
  return this.m_next;
};


/**
 * Get the user data pointer that was provided in the body definition.
 * @return {*}
 */
Box2D.Dynamics.b2Body.prototype.GetUserData = function() {
  return this.Box2D_Dynamics_b2Body_m_userData;
};


/**
 * Set the user data. Use this to store your application specific data.
 * @param {*} data
 */
Box2D.Dynamics.b2Body.prototype.SetUserData = function(data) {
  this.Box2D_Dynamics_b2Body_m_userData = data;
};


/**
 * Get the parent world of this body.
 * @return {Box2D.Dynamics.b2World}
 */
Box2D.Dynamics.b2Body.prototype.GetWorld = function() {
  return this.m_world;
};


Box2D.Dynamics.b2Body.get__s_xf1 = function() {
  var value = new Box2D.Common.Math.b2Transform();
  Object.defineProperties(Box2D.Dynamics.b2Body, { s_xf1: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2Body.set__s_xf1 = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2Body, { s_xf1: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Transform}
 */
Box2D.Dynamics.b2Body.s_xf1;

Object.defineProperties(Box2D.Dynamics.b2Body, /** @lends {Box2D.Dynamics.b2Body} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Transform}
 */
s_xf1: {
  get: Box2D.Dynamics.b2Body.get__s_xf1,
  set: Box2D.Dynamics.b2Body.set__s_xf1,
  configurable: true}});


/**
 */
Box2D.Dynamics.b2Body.prototype.SynchronizeFixtures = function() {
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  var /** @type {Box2D.Common.Math.b2Transform} */ xf1 = Box2D.Dynamics.b2Body.s_xf1;
  xf1.R.Set(this.m_sweep.a0);
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = xf1.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = this.m_sweep.localCenter;
  xf1.position.x = this.m_sweep.c0.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  xf1.position.y = this.m_sweep.c0.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
  //var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_world.m_contactManager.m_broadPhase;
  for (f = this.m_fixtureList; f; f = f.m_next) {
    f.Synchronize(broadPhase, xf1, this.m_xf);
  }
};


/**
 */
Box2D.Dynamics.b2Body.prototype.SynchronizeTransform = function() {
  this.m_xf.R.Set(this.m_sweep.a);
  var /** @type {Box2D.Common.Math.b2Mat22} */ tMat = this.m_xf.R;
  var /** @type {Box2D.Common.Math.b2Vec2} */ tVec = this.m_sweep.localCenter;
  this.m_xf.position.x = this.m_sweep.c.x - (tMat.col1.x * tVec.x + tMat.col2.x * tVec.y);
  this.m_xf.position.y = this.m_sweep.c.y - (tMat.col1.y * tVec.x + tMat.col2.y * tVec.y);
};


/**
 * @param {Box2D.Dynamics.b2Body} other
 * @return {boolean}
 */
Box2D.Dynamics.b2Body.prototype.ShouldCollide = function(other) {
  if (this.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody && other.m_type != Box2D.Dynamics.b2Body.b2_dynamicBody) {
    return false;
  }
  for (var /** @type {Box2D.Dynamics.Joints.b2JointEdge} */ jn = this.m_jointList; jn; jn = jn.next) {
    if (jn.other == other)
      if (jn.joint.m_collideConnected == false) {
        return false;
      }
  }
  return true;
};


/**
 * @param {number} t
 */
Box2D.Dynamics.b2Body.prototype.Advance = function(t) {
  this.m_sweep.Advance(t);
  this.m_sweep.c.SetV(this.m_sweep.c0);
  this.m_sweep.a = this.m_sweep.a0;
  this.SynchronizeTransform();
};


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_flags = 0;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_type = 0;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_islandIndex = 0;


/**
 * @type {Box2D.Common.Math.b2Transform}
 */
Box2D.Dynamics.b2Body.prototype.m_xf = null;


/**
 * @type {Box2D.Common.Math.b2Sweep}
 */
Box2D.Dynamics.b2Body.prototype.m_sweep = null;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.m_linearVelocity = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_angularVelocity = NaN;


/**
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2Body.prototype.m_force = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_torque = NaN;


/**
 * @type {Box2D.Dynamics.b2World}
 */
Box2D.Dynamics.b2Body.prototype.m_world = null;


/**
 * @type {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Body.prototype.m_prev = null;


/**
 * @type {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Body.prototype.m_next = null;


/**
 * @type {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Body.prototype.m_fixtureList = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_fixtureCount = 0;


/**
 * @type {Box2D.Dynamics.Controllers.b2ControllerEdge}
 */
Box2D.Dynamics.b2Body.prototype.m_controllerList = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_controllerCount = 0;


/**
 * @type {Box2D.Dynamics.Joints.b2JointEdge}
 */
Box2D.Dynamics.b2Body.prototype.m_jointList = null;


/**
 * @type {Box2D.Dynamics.Contacts.b2ContactEdge}
 */
Box2D.Dynamics.b2Body.prototype.m_contactList = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_mass = NaN;

/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_invMass = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_I = NaN;

/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_invI = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_inertiaScale = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_linearDamping = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_angularDamping = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.m_sleepTime = NaN;


/**
 * @private
 * @type {*}
 */
Box2D.Dynamics.b2Body.prototype.Box2D_Dynamics_b2Body_m_userData = undefined;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_islandFlag = 0x1;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_awakeFlag = 0x2;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_allowSleepFlag = 0x4;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_bulletFlag = 0x8;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_fixedRotationFlag = 0x10;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.e_activeFlag = 0x20;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.b2_staticBody = 0;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.b2_kinematicBody = 1;


/**
 * @nocollapse
 * @type {number}
 */
Box2D.Dynamics.b2Body.b2_dynamicBody = 2;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Dynamics.b2Body.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2Body', qName: 'Box2D.Dynamics.b2Body', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Dynamics.b2Body.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_flags': { type: 'uint', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_flags = v : inst.m_flags;}},
        'm_type': { type: 'int', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_type = v : inst.m_type;}},
        'm_islandIndex': { type: 'int', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_islandIndex = v : inst.m_islandIndex;}},
        'm_xf': { type: 'Box2D.Common.Math.b2Transform', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_xf = v : inst.m_xf;}},
        'm_sweep': { type: 'Box2D.Common.Math.b2Sweep', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_sweep = v : inst.m_sweep;}},
        'm_linearVelocity': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_linearVelocity = v : inst.m_linearVelocity;}},
        'm_angularVelocity': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_angularVelocity = v : inst.m_angularVelocity;}},
        'm_force': { type: 'Box2D.Common.Math.b2Vec2', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_force = v : inst.m_force;}},
        'm_torque': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_torque = v : inst.m_torque;}},
        'm_world': { type: 'Box2D.Dynamics.b2World', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_world = v : inst.m_world;}},
        'm_prev': { type: 'Box2D.Dynamics.b2Body', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_prev = v : inst.m_prev;}},
        'm_next': { type: 'Box2D.Dynamics.b2Body', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_next = v : inst.m_next;}},
        'm_fixtureList': { type: 'Box2D.Dynamics.b2Fixture', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_fixtureList = v : inst.m_fixtureList;}},
        'm_fixtureCount': { type: 'int', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_fixtureCount = v : inst.m_fixtureCount;}},
        'm_controllerList': { type: 'Box2D.Dynamics.Controllers.b2ControllerEdge', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_controllerList = v : inst.m_controllerList;}},
        'm_controllerCount': { type: 'int', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_controllerCount = v : inst.m_controllerCount;}},
        'm_jointList': { type: 'Box2D.Dynamics.Joints.b2JointEdge', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_jointList = v : inst.m_jointList;}},
        'm_contactList': { type: 'Box2D.Dynamics.Contacts.b2ContactEdge', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_contactList = v : inst.m_contactList;}},
        'm_mass': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_mass = v : inst.m_mass;}},
        'm_I': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_I = v : inst.m_I;}},
        'm_inertiaScale': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_inertiaScale = v : inst.m_inertiaScale;}},
        'm_linearDamping': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_linearDamping = v : inst.m_linearDamping;}},
        'm_angularDamping': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_angularDamping = v : inst.m_angularDamping;}},
        'm_sleepTime': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Body */ inst, /** * */ v) {return v !== undefined ? inst.m_sleepTime = v : inst.m_sleepTime;}},
        '|e_islandFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_islandFlag = v : Box2D.Dynamics.b2Body.e_islandFlag;}},
        '|e_awakeFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_awakeFlag = v : Box2D.Dynamics.b2Body.e_awakeFlag;}},
        '|e_allowSleepFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_allowSleepFlag = v : Box2D.Dynamics.b2Body.e_allowSleepFlag;}},
        '|e_bulletFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_bulletFlag = v : Box2D.Dynamics.b2Body.e_bulletFlag;}},
        '|e_fixedRotationFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_fixedRotationFlag = v : Box2D.Dynamics.b2Body.e_fixedRotationFlag;}},
        '|e_activeFlag': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.e_activeFlag = v : Box2D.Dynamics.b2Body.e_activeFlag;}},
        '|b2_staticBody': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.b2_staticBody = v : Box2D.Dynamics.b2Body.b2_staticBody;}},
        '|b2_kinematicBody': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.b2_kinematicBody = v : Box2D.Dynamics.b2Body.b2_kinematicBody;}},
        '|b2_dynamicBody': { type: 'uint', get_set: function (/** * */ v) {return v !== undefined ? Box2D.Dynamics.b2Body.b2_dynamicBody = v : Box2D.Dynamics.b2Body.b2_dynamicBody;}}
      };
    },
    methods: function () {
      return {
        'CreateFixture': { type: 'Box2D.Dynamics.b2Fixture', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Dynamics.b2FixtureDef', false ]; }},
        'CreateFixture2': { type: 'Box2D.Dynamics.b2Fixture', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Collision.Shapes.b2Shape', false ,'Number', true ]; }},
        'DestroyFixture': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Dynamics.b2Fixture', false ]; }},
        'SetPositionAndAngle': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Number', false ]; }},
        'SetTransform': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Transform', false ]; }},
        'GetTransform': { type: 'Box2D.Common.Math.b2Transform', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetPosition': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetPosition': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetAngle': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetAngle': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }},
        'GetWorldCenter': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetLocalCenter': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetLinearVelocity': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLinearVelocity': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetAngularVelocity': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }},
        'GetAngularVelocity': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetDefinition': { type: 'Box2D.Dynamics.b2BodyDef', declaredBy: 'Box2D.Dynamics.b2Body'},
        'ApplyForce': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'ApplyTorque': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }},
        'ApplyImpulse': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'Split': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Function', false ]; }},
        'Merge': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Dynamics.b2Body', false ]; }},
        'GetMass': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetInertia': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetMassData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', false ]; }},
        'SetMassData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', false ]; }},
        'ResetMassData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetWorldPoint': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetWorldVector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLocalPoint': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLocalVector': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLinearVelocityFromWorldPoint': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLinearVelocityFromLocalPoint': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetLinearDamping': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetLinearDamping': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }},
        'GetAngularDamping': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetAngularDamping': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }},
        'SetType': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'uint', false ]; }},
        'GetType': { type: 'uint', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetBullet': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Boolean', false ]; }},
        'IsBullet': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetSleepingAllowed': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Boolean', false ]; }},
        'SetAwake': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Boolean', false ]; }},
        'IsAwake': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetFixedRotation': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Boolean', false ]; }},
        'IsFixedRotation': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetActive': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Boolean', false ]; }},
        'IsActive': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body'},
        'IsSleepingAllowed': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetFixtureList': { type: 'Box2D.Dynamics.b2Fixture', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetJointList': { type: 'Box2D.Dynamics.Joints.b2JointEdge', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetControllerList': { type: 'Box2D.Dynamics.Controllers.b2ControllerEdge', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetContactList': { type: 'Box2D.Dynamics.Contacts.b2ContactEdge', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetNext': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2Body'},
        'GetUserData': { type: '*', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SetUserData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ '*', false ]; }},
        'GetWorld': { type: 'Box2D.Dynamics.b2World', declaredBy: 'Box2D.Dynamics.b2Body'},
        'b2Body': { type: '', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Dynamics.b2BodyDef', false ,'Box2D.Dynamics.b2World', false ]; }},
        'SynchronizeFixtures': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body'},
        'SynchronizeTransform': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body'},
        'ShouldCollide': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Box2D.Dynamics.b2Body', false ]; }},
        'Advance': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Body', parameters: function () { return [ 'Number', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Dynamics.b2Body.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Dynamics.b2Body.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Dynamics.b2Body);
