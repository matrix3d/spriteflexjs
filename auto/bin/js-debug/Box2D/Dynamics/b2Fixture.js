/**
 * Generated by Apache Royale Compiler from Box2D/Dynamics/b2Fixture.as
 * Box2D.Dynamics.b2Fixture
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Dynamics.b2Fixture');
/* Royale Dependency List: Box2D.Collision.IBroadPhase,Box2D.Collision.Shapes.b2MassData,Box2D.Collision.Shapes.b2Shape,Box2D.Collision.b2AABB,Box2D.Collision.b2RayCastInput,Box2D.Collision.b2RayCastOutput,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Dynamics.Contacts.b2Contact,Box2D.Dynamics.Contacts.b2ContactEdge,Box2D.Dynamics.b2Body,Box2D.Dynamics.b2FilterData,Box2D.Dynamics.b2FixtureDef*/




/**
 * @asprivate
 * @constructor
 */
Box2D.Dynamics.b2Fixture = function() {
  
  this.m_filter = new Box2D.Dynamics.b2FilterData();
  this.m_aabb = new Box2D.Collision.b2AABB();
  this.m_userData = null;
  this.m_body = null;
  this.m_next = null;
  this.m_shape = null;
  this.m_density = 0.0;
  this.m_friction = 0.0;
  this.m_restitution = 0.0;
};


/**
 * Get the type of the child shape. You can use this to down cast to the concrete shape.
 * @asreturn the shape type.
 * @return {number}
 */
Box2D.Dynamics.b2Fixture.prototype.GetType = function() {
  return this.m_shape.GetType();
};


/**
 * Get the child shape. You can modify the child shape, however you should not change the
 * number of vertices because this will crash some collision caching mechanisms.
 * @return {Box2D.Collision.Shapes.b2Shape}
 */
Box2D.Dynamics.b2Fixture.prototype.GetShape = function() {
  return this.m_shape;
};


/**
 * Set if this fixture is a sensor.
 * @param {boolean} sensor
 */
Box2D.Dynamics.b2Fixture.prototype.SetSensor = function(sensor) {
  if (this.m_isSensor == sensor)
    return;
  this.m_isSensor = sensor;
  if (this.m_body == null)
    return;
  var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ edge = this.m_body.GetContactList();
  while (edge) {
    var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ contact = edge.contact;
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureA = contact.GetFixtureA();
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureB = contact.GetFixtureB();
    if (fixtureA == this || fixtureB == this)
      contact.SetSensor(fixtureA.IsSensor() || fixtureB.IsSensor());
    edge = edge.next;
  }
};


/**
 * Is this fixture a sensor (non-solid)?
 * @asreturn the true if the shape is a sensor.
 * @return {boolean}
 */
Box2D.Dynamics.b2Fixture.prototype.IsSensor = function() {
  return this.m_isSensor;
};


/**
 * Set the contact filtering data. This will not update contacts until the next time
 * step when either parent body is active and awake.
 * @param {Box2D.Dynamics.b2FilterData} filter
 */
Box2D.Dynamics.b2Fixture.prototype.SetFilterData = function(filter) {
  this.m_filter = filter.Copy();
  if (this.m_body)
    return;
  var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ edge = this.m_body.GetContactList();
  while (edge) {
    var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ contact = edge.contact;
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureA = contact.GetFixtureA();
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureB = contact.GetFixtureB();
    if (fixtureA == this || fixtureB == this)
      contact.FlagForFiltering();
    edge = edge.next;
  }
};


/**
 * Get the contact filtering data.
 * @return {Box2D.Dynamics.b2FilterData}
 */
Box2D.Dynamics.b2Fixture.prototype.GetFilterData = function() {
  return this.m_filter.Copy();
};


/**
 * Get the parent body of this fixture. This is NULL if the fixture is not attached.
 * @asreturn the parent body.
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Fixture.prototype.GetBody = function() {
  return this.m_body;
};


/**
 * Get the next fixture in the parent body's fixture list.
 * @asreturn the next shape.
 * @return {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Fixture.prototype.GetNext = function() {
  return this.m_next;
};


/**
 * Get the user data that was assigned in the fixture definition. Use this to
 * store your application specific data.
 * @return {*}
 */
Box2D.Dynamics.b2Fixture.prototype.GetUserData = function() {
  return this.m_userData;
};


/**
 * Set the user data. Use this to store your application specific data.
 * @param {*} data
 */
Box2D.Dynamics.b2Fixture.prototype.SetUserData = function(data) {
  this.m_userData = data;
};


/**
 * Test a point for containment in this fixture.
 * @asparam xf the shape world transform.
 * @asparam p a point in world coordinates.
 * @param {Box2D.Common.Math.b2Vec2} p
 * @return {boolean}
 */
Box2D.Dynamics.b2Fixture.prototype.TestPoint = function(p) {
  return this.m_shape.TestPoint(this.m_body.GetTransform(), p);
};


/**
 * Perform a ray cast against this shape.
 * @asparam output the ray-cast results.
 * @asparam input the ray-cast input parameters.
 * @param {Box2D.Collision.b2RayCastOutput} output
 * @param {Box2D.Collision.b2RayCastInput} input
 * @return {boolean}
 */
Box2D.Dynamics.b2Fixture.prototype.RayCast = function(output, input) {
  return this.m_shape.RayCast(output, input, this.m_body.GetTransform());
};


/**
 * Get the mass data for this fixture. The mass data is based on the density and
 * the shape. The rotational inertia is about the shape's origin. This operation may be expensive
 * @asparam massData - this is a reference to a valid massData, if it is null a new b2MassData is allocated and then returned
 * note if the input is null then you must get the return value.
 * @param {Box2D.Collision.Shapes.b2MassData=} massData
 * @return {Box2D.Collision.Shapes.b2MassData}
 */
Box2D.Dynamics.b2Fixture.prototype.GetMassData = function(massData) {
  massData = typeof massData !== 'undefined' ? massData : null;
  if (massData == null) {
    massData = new Box2D.Collision.Shapes.b2MassData();
  }
  this.m_shape.ComputeMass(massData, this.m_density);
  return massData;
};


/**
 * Set the density of this fixture. This will _not_ automatically adjust the mass
 * of the body. You must call b2Body::ResetMassData to update the body's mass.
 * @asparam	density
 * @param {number} density
 */
Box2D.Dynamics.b2Fixture.prototype.SetDensity = function(density) {
  this.m_density = density;
};


/**
 * Get the density of this fixture.
 * @asreturn density
 * @return {number}
 */
Box2D.Dynamics.b2Fixture.prototype.GetDensity = function() {
  return this.m_density;
};


/**
 * Get the coefficient of friction.
 * @return {number}
 */
Box2D.Dynamics.b2Fixture.prototype.GetFriction = function() {
  return this.m_friction;
};


/**
 * Set the coefficient of friction.
 * @param {number} friction
 */
Box2D.Dynamics.b2Fixture.prototype.SetFriction = function(friction) {
  this.m_friction = friction;
};


/**
 * Get the coefficient of restitution.
 * @return {number}
 */
Box2D.Dynamics.b2Fixture.prototype.GetRestitution = function() {
  return this.m_restitution;
};


/**
 * Get the coefficient of restitution.
 * @param {number} restitution
 */
Box2D.Dynamics.b2Fixture.prototype.SetRestitution = function(restitution) {
  this.m_restitution = restitution;
};


/**
 * Get the fixture's AABB. This AABB may be enlarge and/or stale.
 * If you need a more accurate AABB, compute it using the shape and
 * the body transform.
 * @asreturn
 * @return {Box2D.Collision.b2AABB}
 */
Box2D.Dynamics.b2Fixture.prototype.GetAABB = function() {
  return this.m_aabb;
};


/**
 * the destructor cannot access the allocator (no destructor arguments allowed by C++).
 *  We need separation create/destroy functions from the constructor/destructor because
 * @param {Box2D.Dynamics.b2Body} body
 * @param {Box2D.Common.Math.b2Transform} xf
 * @param {Box2D.Dynamics.b2FixtureDef} def
 */
Box2D.Dynamics.b2Fixture.prototype.Create = function(body, xf, def) {
  this.m_userData = def.userData;
  this.m_friction = def.friction;
  this.m_restitution = def.restitution;
  this.m_body = body;
  this.m_next = null;
  this.m_filter = def.filter.Copy();
  this.m_isSensor = def.isSensor;
  this.m_shape = def.shape.Copy();
  this.m_density = def.density;
};


/**
 * the destructor cannot access the allocator (no destructor arguments allowed by C++).
 *  We need separation create/destroy functions from the constructor/destructor because
 */
Box2D.Dynamics.b2Fixture.prototype.Destroy = function() {
  this.m_shape = null;
};


/**
 * This supports body activation/deactivation.
 * @param {Box2D.Collision.IBroadPhase} broadPhase
 * @param {Box2D.Common.Math.b2Transform} xf
 */
Box2D.Dynamics.b2Fixture.prototype.CreateProxy = function(broadPhase, xf) {
  this.m_shape.ComputeAABB(this.m_aabb, xf);
  this.m_proxy = broadPhase.CreateProxy(this.m_aabb, this);
};


/**
 * This supports body activation/deactivation.
 * @param {Box2D.Collision.IBroadPhase} broadPhase
 */
Box2D.Dynamics.b2Fixture.prototype.DestroyProxy = function(broadPhase) {
  if (this.m_proxy == null) {
    return;
  }
  broadPhase.DestroyProxy(this.m_proxy);
  this.m_proxy = null;
};


/**
 * @param {Box2D.Collision.IBroadPhase} broadPhase
 * @param {Box2D.Common.Math.b2Transform} transform1
 * @param {Box2D.Common.Math.b2Transform} transform2
 */
Box2D.Dynamics.b2Fixture.prototype.Synchronize = function(broadPhase, transform1, transform2) {
  if (!this.m_proxy)
    return;
  var /** @type {Box2D.Collision.b2AABB} */ aabb1 = new Box2D.Collision.b2AABB();
  var /** @type {Box2D.Collision.b2AABB} */ aabb2 = new Box2D.Collision.b2AABB();
  this.m_shape.ComputeAABB(aabb1, transform1);
  this.m_shape.ComputeAABB(aabb2, transform2);
  this.m_aabb.Combine(aabb1, aabb2);
  var /** @type {Box2D.Common.Math.b2Vec2} */ displacement = Box2D.Common.Math.b2Math.SubtractVV(transform2.position, transform1.position);
  broadPhase.MoveProxy(this.m_proxy, this.m_aabb, displacement);
};


/**
 * @private
 * @type {Box2D.Collision.Shapes.b2MassData}
 */
Box2D.Dynamics.b2Fixture.prototype.Box2D_Dynamics_b2Fixture_m_massData = null;


/**
 * @type {Box2D.Collision.b2AABB}
 */
Box2D.Dynamics.b2Fixture.prototype.m_aabb = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Fixture.prototype.m_density = NaN;


/**
 * @type {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2Fixture.prototype.m_next = null;


/**
 * @type {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2Fixture.prototype.m_body = null;


/**
 * @type {Box2D.Collision.Shapes.b2Shape}
 */
Box2D.Dynamics.b2Fixture.prototype.m_shape = null;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Fixture.prototype.m_friction = NaN;


/**
 * @type {number}
 */
Box2D.Dynamics.b2Fixture.prototype.m_restitution = NaN;


/**
 * @type {*}
 */
Box2D.Dynamics.b2Fixture.prototype.m_proxy = undefined;


/**
 * @type {Box2D.Dynamics.b2FilterData}
 */
Box2D.Dynamics.b2Fixture.prototype.m_filter = null;


/**
 * @type {boolean}
 */
Box2D.Dynamics.b2Fixture.prototype.m_isSensor = false;


/**
 * @type {*}
 */
Box2D.Dynamics.b2Fixture.prototype.m_userData = undefined;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Dynamics.b2Fixture.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2Fixture', qName: 'Box2D.Dynamics.b2Fixture', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Dynamics.b2Fixture.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_aabb': { type: 'Box2D.Collision.b2AABB', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_aabb = v : inst.m_aabb;}},
        'm_density': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_density = v : inst.m_density;}},
        'm_next': { type: 'Box2D.Dynamics.b2Fixture', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_next = v : inst.m_next;}},
        'm_body': { type: 'Box2D.Dynamics.b2Body', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_body = v : inst.m_body;}},
        'm_shape': { type: 'Box2D.Collision.Shapes.b2Shape', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_shape = v : inst.m_shape;}},
        'm_friction': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_friction = v : inst.m_friction;}},
        'm_restitution': { type: 'Number', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_restitution = v : inst.m_restitution;}},
        'm_proxy': { type: '*', get_set: function f(/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== f ? inst.m_proxy = v : inst.m_proxy;}},
        'm_filter': { type: 'Box2D.Dynamics.b2FilterData', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_filter = v : inst.m_filter;}},
        'm_isSensor': { type: 'Boolean', get_set: function (/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== undefined ? inst.m_isSensor = v : inst.m_isSensor;}},
        'm_userData': { type: '*', get_set: function f(/** Box2D.Dynamics.b2Fixture */ inst, /** * */ v) {return v !== f ? inst.m_userData = v : inst.m_userData;}}
      };
    },
    methods: function () {
      return {
        'GetType': { type: 'int', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'GetShape': { type: 'Box2D.Collision.Shapes.b2Shape', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'SetSensor': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Boolean', false ]; }},
        'IsSensor': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'SetFilterData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Dynamics.b2FilterData', false ]; }},
        'GetFilterData': { type: 'Box2D.Dynamics.b2FilterData', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'GetBody': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'GetNext': { type: 'Box2D.Dynamics.b2Fixture', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'GetUserData': { type: '*', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'SetUserData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ '*', false ]; }},
        'TestPoint': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCast': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Collision.b2RayCastOutput', false ,'Box2D.Collision.b2RayCastInput', false ]; }},
        'GetMassData': { type: 'Box2D.Collision.Shapes.b2MassData', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Collision.Shapes.b2MassData', true ]; }},
        'SetDensity': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Number', false ]; }},
        'GetDensity': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'GetFriction': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'SetFriction': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Number', false ]; }},
        'GetRestitution': { type: 'Number', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'SetRestitution': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Number', false ]; }},
        'GetAABB': { type: 'Box2D.Collision.b2AABB', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'b2Fixture': { type: '', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'Create': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Dynamics.b2Body', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Dynamics.b2FixtureDef', false ]; }},
        'Destroy': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture'},
        'CreateProxy': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Collision.IBroadPhase', false ,'Box2D.Common.Math.b2Transform', false ]; }},
        'DestroyProxy': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Collision.IBroadPhase', false ]; }},
        'Synchronize': { type: 'void', declaredBy: 'Box2D.Dynamics.b2Fixture', parameters: function () { return [ 'Box2D.Collision.IBroadPhase', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.Math.b2Transform', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Dynamics.b2Fixture.prototype.ROYALE_COMPILE_FLAGS = 9;
