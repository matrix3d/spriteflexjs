/**
 * Generated by Apache Royale Compiler from Box2D/Dynamics/b2World.as
 * Box2D.Dynamics.b2World
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('Box2D.Dynamics.b2World');
/* Royale Dependency List: Box2D.Collision.IBroadPhase,Box2D.Collision.Shapes.b2CircleShape,Box2D.Collision.Shapes.b2EdgeShape,Box2D.Collision.Shapes.b2PolygonShape,Box2D.Collision.Shapes.b2Shape,Box2D.Collision.Shapes.b2ShapeUtil,Box2D.Collision.b2AABB,Box2D.Collision.b2RayCastInput,Box2D.Collision.b2RayCastOutput,Box2D.Common.Math.b2Math,Box2D.Common.Math.b2Sweep,Box2D.Common.Math.b2Transform,Box2D.Common.Math.b2Vec2,Box2D.Common.b2Color,Box2D.Common.b2Settings,Box2D.Dynamics.Contacts.b2Contact,Box2D.Dynamics.Contacts.b2ContactEdge,Box2D.Dynamics.Contacts.b2ContactSolver,Box2D.Dynamics.Controllers.b2Controller,Box2D.Dynamics.Controllers.b2ControllerEdge,Box2D.Dynamics.Joints.b2Joint,Box2D.Dynamics.Joints.b2JointDef,Box2D.Dynamics.Joints.b2JointEdge,Box2D.Dynamics.Joints.b2JointUtil,Box2D.Dynamics.Joints.b2PulleyJoint,Box2D.Dynamics.b2Body,Box2D.Dynamics.b2BodyDef,Box2D.Dynamics.b2ContactFilter,Box2D.Dynamics.b2ContactListener,Box2D.Dynamics.b2ContactManager,Box2D.Dynamics.b2DebugDraw,Box2D.Dynamics.b2DestructionListener,Box2D.Dynamics.b2Fixture,Box2D.Dynamics.b2Island,Box2D.Dynamics.b2TimeStep,org.apache.royale.utils.Language*/




/**
 * @asparam gravity the world gravity vector.
 * @asparam doSleep improve performance by not simulating inactive bodies.
 * @constructor
 * @param {Box2D.Common.Math.b2Vec2} gravity
 * @param {boolean} doSleep
 */
Box2D.Dynamics.b2World = function(gravity, doSleep) {
  
  this.Box2D_Dynamics_b2World_s_stack = new Array();
  this.m_contactManager = new Box2D.Dynamics.b2ContactManager();
  this.Box2D_Dynamics_b2World_m_contactSolver = new Box2D.Dynamics.Contacts.b2ContactSolver();
  this.Box2D_Dynamics_b2World_m_island = new Box2D.Dynamics.b2Island();
  this.Box2D_Dynamics_b2World_m_destructionListener = null;
  this.Box2D_Dynamics_b2World_m_debugDraw = null;
  this.m_bodyList = null;
  this.m_contactList = null;
  this.Box2D_Dynamics_b2World_m_jointList = null;
  this.Box2D_Dynamics_b2World_m_controllerList = null;
  this.Box2D_Dynamics_b2World_m_bodyCount = 0;
  this.m_contactCount = 0;
  this.Box2D_Dynamics_b2World_m_jointCount = 0;
  this.Box2D_Dynamics_b2World_m_controllerCount = 0;
  Box2D.Dynamics.b2World.m_warmStarting = true;
  Box2D.Dynamics.b2World.m_continuousPhysics = true;
  this.Box2D_Dynamics_b2World_m_allowSleep = doSleep;
  this.Box2D_Dynamics_b2World_m_gravity = gravity;
  this.Box2D_Dynamics_b2World_m_inv_dt0 = 0.0;
  this.m_contactManager.m_world = this;
  var /** @type {Box2D.Dynamics.b2BodyDef} */ bd = new Box2D.Dynamics.b2BodyDef();
  this.m_groundBody = this.CreateBody(bd);
};


/**
 * Register a destruction listener.
 * @param {Box2D.Dynamics.b2DestructionListener} listener
 */
Box2D.Dynamics.b2World.prototype.SetDestructionListener = function(listener) {
  this.Box2D_Dynamics_b2World_m_destructionListener = listener;
};


/**
 * Register a contact filter to provide specific control over collision.
 * Otherwise the default filter is used (b2_defaultFilter).
 * @param {Box2D.Dynamics.b2ContactFilter} filter
 */
Box2D.Dynamics.b2World.prototype.SetContactFilter = function(filter) {
  this.m_contactManager.m_contactFilter = filter;
};


/**
 * Register a contact event listener
 * @param {Box2D.Dynamics.b2ContactListener} listener
 */
Box2D.Dynamics.b2World.prototype.SetContactListener = function(listener) {
  this.m_contactManager.m_contactListener = listener;
};


/**
 * Register a routine for debug drawing. The debug draw functions are called
 * inside the b2World::Step method, so make sure your renderer is ready to
 * consume draw commands when you call Step().
 * @param {Box2D.Dynamics.b2DebugDraw} debugDraw
 */
Box2D.Dynamics.b2World.prototype.SetDebugDraw = function(debugDraw) {
  this.Box2D_Dynamics_b2World_m_debugDraw = debugDraw;
};


/**
 * Use the given object as a broadphase.
 * The old broadphase will not be cleanly emptied.
 * warning It is not recommended you call this except immediately after constructing the world.
 * warning This function is locked during callbacks.
 * @param {Box2D.Collision.IBroadPhase} broadPhase
 */
Box2D.Dynamics.b2World.prototype.SetBroadPhase = function(broadPhase) {
  var /** @type {Box2D.Collision.IBroadPhase} */ oldBroadPhase = this.m_contactManager.m_broadPhase;
  this.m_contactManager.m_broadPhase = broadPhase;
  for (var /** @type {Box2D.Dynamics.b2Body} */ b = this.m_bodyList; b; b = b.m_next) {
    for (var /** @type {Box2D.Dynamics.b2Fixture} */ f = b.m_fixtureList; f; f = f.m_next) {
      f.m_proxy = broadPhase.CreateProxy(oldBroadPhase.GetFatAABB(f.m_proxy), f);
    }
  }
};


/**
 * Perform validation of internal data structures.
 */
Box2D.Dynamics.b2World.prototype.Validate = function() {
  this.m_contactManager.m_broadPhase.Validate();
};


/**
 * Get the number of broad-phase proxies.
 * @return {number}
 */
Box2D.Dynamics.b2World.prototype.GetProxyCount = function() {
  return this.m_contactManager.m_broadPhase.GetProxyCount();
};


/**
 * Create a rigid body given a definition. No reference to the definition
 * is retained.
 * warning This function is locked during callbacks.
 * @param {Box2D.Dynamics.b2BodyDef} def
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2World.prototype.CreateBody = function(def) {
  if (this.IsLocked() == true) {
    return null;
  }
  var /** @type {Box2D.Dynamics.b2Body} */ b = new Box2D.Dynamics.b2Body(def, this);
  b.m_prev = null;
  b.m_next = this.m_bodyList;
  if (this.m_bodyList) {
    this.m_bodyList.m_prev = b;
  }
  this.m_bodyList = b;
  ++this.Box2D_Dynamics_b2World_m_bodyCount;
  return b;
};


/**
 * Destroy a rigid body given a definition. No reference to the definition
 * is retained. This function is locked during callbacks.
 * warning This automatically deletes all associated shapes and joints.
 * warning This function is locked during callbacks.
 * @param {Box2D.Dynamics.b2Body} b
 */
Box2D.Dynamics.b2World.prototype.DestroyBody = function(b) {
  if (this.IsLocked() == true) {
    return;
  }
  var /** @type {Box2D.Dynamics.Joints.b2JointEdge} */ jn = b.m_jointList;
  while (jn) {
    var /** @type {Box2D.Dynamics.Joints.b2JointEdge} */ jn0 = jn;
    jn = jn.next;
    if (this.Box2D_Dynamics_b2World_m_destructionListener) {
      this.Box2D_Dynamics_b2World_m_destructionListener.SayGoodbyeJoint(jn0.joint);
    }
    this.DestroyJoint(jn0.joint);
  }
  var /** @type {Box2D.Dynamics.Controllers.b2ControllerEdge} */ coe = b.m_controllerList;
  while (coe) {
    var /** @type {Box2D.Dynamics.Controllers.b2ControllerEdge} */ coe0 = coe;
    coe = coe.nextController;
    coe0.controller.RemoveBody(b);
  }
  var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce = b.m_contactList;
  while (ce) {
    var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce0 = ce;
    ce = ce.next;
    this.m_contactManager.Destroy(ce0.contact);
  }
  b.m_contactList = null;
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = b.m_fixtureList;
  while (f) {
    var /** @type {Box2D.Dynamics.b2Fixture} */ f0 = f;
    f = f.m_next;
    if (this.Box2D_Dynamics_b2World_m_destructionListener) {
      this.Box2D_Dynamics_b2World_m_destructionListener.SayGoodbyeFixture(f0);
    }
    f0.DestroyProxy(this.m_contactManager.m_broadPhase);
    f0.Destroy();
  }
  b.m_fixtureList = null;
  b.m_fixtureCount = 0;
  if (b.m_prev) {
    b.m_prev.m_next = b.m_next;
  }
  if (b.m_next) {
    b.m_next.m_prev = b.m_prev;
  }
  if (b == this.m_bodyList) {
    this.m_bodyList = b.m_next;
  }
  --this.Box2D_Dynamics_b2World_m_bodyCount;
};


/**
 * Create a joint to constrain bodies together. No reference to the definition
 * is retained. This may cause the connected bodies to cease colliding.
 * warning This function is locked during callbacks.
 * @param {Box2D.Dynamics.Joints.b2JointDef} def
 * @return {Box2D.Dynamics.Joints.b2Joint}
 */
Box2D.Dynamics.b2World.prototype.CreateJoint = function(def) {
  var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = Box2D.Dynamics.Joints.b2JointUtil.Create(def, null);
  j.m_prev = null;
  j.m_next = this.Box2D_Dynamics_b2World_m_jointList;
  if (this.Box2D_Dynamics_b2World_m_jointList) {
    this.Box2D_Dynamics_b2World_m_jointList.m_prev = j;
  }
  this.Box2D_Dynamics_b2World_m_jointList = j;
  ++this.Box2D_Dynamics_b2World_m_jointCount;
  j.m_edgeA.joint = j;
  j.m_edgeA.other = j.m_bodyB;
  j.m_edgeA.prev = null;
  j.m_edgeA.next = j.m_bodyA.m_jointList;
  if (j.m_bodyA.m_jointList)
    j.m_bodyA.m_jointList.prev = j.m_edgeA;
  j.m_bodyA.m_jointList = j.m_edgeA;
  j.m_edgeB.joint = j;
  j.m_edgeB.other = j.m_bodyA;
  j.m_edgeB.prev = null;
  j.m_edgeB.next = j.m_bodyB.m_jointList;
  if (j.m_bodyB.m_jointList)
    j.m_bodyB.m_jointList.prev = j.m_edgeB;
  j.m_bodyB.m_jointList = j.m_edgeB;
  var /** @type {Box2D.Dynamics.b2Body} */ bodyA = def.bodyA;
  var /** @type {Box2D.Dynamics.b2Body} */ bodyB = def.bodyB;
  if (def.collideConnected == false) {
    var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ edge = bodyB.GetContactList();
    while (edge) {
      if (edge.other == bodyA) {
        edge.contact.FlagForFiltering();
      }
      edge = edge.next;
    }
  }
  return j;
};


/**
 * Destroy a joint. This may cause the connected bodies to begin colliding.
 * warning This function is locked during callbacks.
 * @param {Box2D.Dynamics.Joints.b2Joint} j
 */
Box2D.Dynamics.b2World.prototype.DestroyJoint = function(j) {
  var /** @type {boolean} */ collideConnected = j.m_collideConnected;
  if (j.m_prev) {
    j.m_prev.m_next = j.m_next;
  }
  if (j.m_next) {
    j.m_next.m_prev = j.m_prev;
  }
  if (j == this.Box2D_Dynamics_b2World_m_jointList) {
    this.Box2D_Dynamics_b2World_m_jointList = j.m_next;
  }
  var /** @type {Box2D.Dynamics.b2Body} */ bodyA = j.m_bodyA;
  var /** @type {Box2D.Dynamics.b2Body} */ bodyB = j.m_bodyB;
  bodyA.SetAwake(true);
  bodyB.SetAwake(true);
  if (j.m_edgeA.prev) {
    j.m_edgeA.prev.next = j.m_edgeA.next;
  }
  if (j.m_edgeA.next) {
    j.m_edgeA.next.prev = j.m_edgeA.prev;
  }
  if (j.m_edgeA == bodyA.m_jointList) {
    bodyA.m_jointList = j.m_edgeA.next;
  }
  j.m_edgeA.prev = null;
  j.m_edgeA.next = null;
  if (j.m_edgeB.prev) {
    j.m_edgeB.prev.next = j.m_edgeB.next;
  }
  if (j.m_edgeB.next) {
    j.m_edgeB.next.prev = j.m_edgeB.prev;
  }
  if (j.m_edgeB == bodyB.m_jointList) {
    bodyB.m_jointList = j.m_edgeB.next;
  }
  j.m_edgeB.prev = null;
  j.m_edgeB.next = null;
  Box2D.Dynamics.Joints.b2Joint.Destroy(j, null);
  --this.Box2D_Dynamics_b2World_m_jointCount;
  if (collideConnected == false) {
    var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ edge = bodyB.GetContactList();
    while (edge) {
      if (edge.other == bodyA) {
        edge.contact.FlagForFiltering();
      }
      edge = edge.next;
    }
  }
};


/**
 * Add a controller to the world list
 * @param {Box2D.Dynamics.Controllers.b2Controller} c
 * @return {Box2D.Dynamics.Controllers.b2Controller}
 */
Box2D.Dynamics.b2World.prototype.AddController = function(c) {
  c.m_next = this.Box2D_Dynamics_b2World_m_controllerList;
  c.m_prev = null;
  this.Box2D_Dynamics_b2World_m_controllerList = c;
  c.m_world = this;
  this.Box2D_Dynamics_b2World_m_controllerCount++;
  return c;
};


/**
 * @param {Box2D.Dynamics.Controllers.b2Controller} c
 */
Box2D.Dynamics.b2World.prototype.RemoveController = function(c) {
  if (c.m_prev)
    c.m_prev.m_next = c.m_next;
  if (c.m_next)
    c.m_next.m_prev = c.m_prev;
  if (this.Box2D_Dynamics_b2World_m_controllerList == c)
    this.Box2D_Dynamics_b2World_m_controllerList = c.m_next;
  this.Box2D_Dynamics_b2World_m_controllerCount--;
};


/**
 * @param {Box2D.Dynamics.Controllers.b2Controller} controller
 * @return {Box2D.Dynamics.Controllers.b2Controller}
 */
Box2D.Dynamics.b2World.prototype.CreateController = function(controller) {
  if (controller.m_world != this)
    throw new Error("Controller can only be a member of one world");
  controller.m_next = this.Box2D_Dynamics_b2World_m_controllerList;
  controller.m_prev = null;
  if (this.Box2D_Dynamics_b2World_m_controllerList)
    this.Box2D_Dynamics_b2World_m_controllerList.m_prev = controller;
  this.Box2D_Dynamics_b2World_m_controllerList = controller;
  ++this.Box2D_Dynamics_b2World_m_controllerCount;
  controller.m_world = this;
  return controller;
};


/**
 * @param {Box2D.Dynamics.Controllers.b2Controller} controller
 */
Box2D.Dynamics.b2World.prototype.DestroyController = function(controller) {
  controller.Clear();
  if (controller.m_next)
    controller.m_next.m_prev = controller.m_prev;
  if (controller.m_prev)
    controller.m_prev.m_next = controller.m_next;
  if (controller == this.Box2D_Dynamics_b2World_m_controllerList)
    this.Box2D_Dynamics_b2World_m_controllerList = controller.m_next;
  --this.Box2D_Dynamics_b2World_m_controllerCount;
};


/**
 * Enable/disable warm starting. For testing.
 * @param {boolean} flag
 */
Box2D.Dynamics.b2World.prototype.SetWarmStarting = function(flag) {
  Box2D.Dynamics.b2World.m_warmStarting = flag;
};


/**
 * Enable/disable continuous physics. For testing.
 * @param {boolean} flag
 */
Box2D.Dynamics.b2World.prototype.SetContinuousPhysics = function(flag) {
  Box2D.Dynamics.b2World.m_continuousPhysics = flag;
};


/**
 * Get the number of bodies.
 * @return {number}
 */
Box2D.Dynamics.b2World.prototype.GetBodyCount = function() {
  return this.Box2D_Dynamics_b2World_m_bodyCount;
};


/**
 * Get the number of joints.
 * @return {number}
 */
Box2D.Dynamics.b2World.prototype.GetJointCount = function() {
  return this.Box2D_Dynamics_b2World_m_jointCount;
};


/**
 * Get the number of contacts (each may have 0 or more contact points).
 * @return {number}
 */
Box2D.Dynamics.b2World.prototype.GetContactCount = function() {
  return this.m_contactCount;
};


/**
 * Change the global gravity vector.
 * @param {Box2D.Common.Math.b2Vec2} gravity
 */
Box2D.Dynamics.b2World.prototype.SetGravity = function(gravity) {
  this.Box2D_Dynamics_b2World_m_gravity = gravity;
};


/**
 * Get the global gravity vector.
 * @return {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2World.prototype.GetGravity = function() {
  return this.Box2D_Dynamics_b2World_m_gravity;
};


/**
 * The world provides a single static ground body with no collision shapes.
 * You can use this to simplify the creation of joints and static shapes.
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2World.prototype.GetGroundBody = function() {
  return this.m_groundBody;
};


Box2D.Dynamics.b2World.get__s_timestep2 = function() {
  var value = new Box2D.Dynamics.b2TimeStep();
  Object.defineProperties(Box2D.Dynamics.b2World, { s_timestep2: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_timestep2 = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_timestep2: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Dynamics.b2TimeStep}
 */
Box2D.Dynamics.b2World.s_timestep2;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Dynamics.b2TimeStep}
 */
s_timestep2: {
  get: Box2D.Dynamics.b2World.get__s_timestep2,
  set: Box2D.Dynamics.b2World.set__s_timestep2,
  configurable: true}});


/**
 * Take a time step. This performs collision detection, integration,
 * and constraint solution.
 * @asparam timeStep the amount of time to simulate, this should not vary.
 * @asparam velocityIterations for the velocity constraint solver.
 * @asparam positionIterations for the position constraint solver.
 * @param {number} dt
 * @param {number} velocityIterations
 * @param {number} positionIterations
 */
Box2D.Dynamics.b2World.prototype.Step = function(dt, velocityIterations, positionIterations) {
  if (this.m_flags & Box2D.Dynamics.b2World.e_newFixture) {
    this.m_contactManager.FindNewContacts();
    this.m_flags &= ~Box2D.Dynamics.b2World.e_newFixture;
  }
  this.m_flags |= Box2D.Dynamics.b2World.e_locked;
  var /** @type {Box2D.Dynamics.b2TimeStep} */ step = Box2D.Dynamics.b2World.s_timestep2;
  step.dt = dt;
  step.velocityIterations = velocityIterations;
  step.positionIterations = positionIterations;
  if (dt > 0.0) {
    step.inv_dt = 1.0 / dt;
  } else {
    step.inv_dt = 0.0;
  }
  step.dtRatio = this.Box2D_Dynamics_b2World_m_inv_dt0 * dt;
  step.warmStarting = Box2D.Dynamics.b2World.m_warmStarting;
  this.m_contactManager.Collide();
  if (step.dt > 0.0) {
    this.Solve(step);
  }
  if (Box2D.Dynamics.b2World.m_continuousPhysics && step.dt > 0.0) {
    this.SolveTOI(step);
  }
  if (step.dt > 0.0) {
    this.Box2D_Dynamics_b2World_m_inv_dt0 = step.inv_dt;
  }
  this.m_flags &= ~Box2D.Dynamics.b2World.e_locked;
};


/**
 * Call this after you are done with time steps to clear the forces. You normally
 * call this after each call to Step, unless you are performing sub-steps.
 */
Box2D.Dynamics.b2World.prototype.ClearForces = function() {
  for (var /** @type {Box2D.Dynamics.b2Body} */ body = this.m_bodyList; body; body = body.m_next) {
    body.m_force.SetZero();
    body.m_torque = 0.0;
  }
};


Box2D.Dynamics.b2World.get__s_xf = function() {
  var value = new Box2D.Common.Math.b2Transform();
  Object.defineProperties(Box2D.Dynamics.b2World, { s_xf: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_xf = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_xf: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Transform}
 */
Box2D.Dynamics.b2World.s_xf;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Transform}
 */
s_xf: {
  get: Box2D.Dynamics.b2World.get__s_xf,
  set: Box2D.Dynamics.b2World.set__s_xf,
  configurable: true}});


/**
 * Call this to draw shapes and other debug draw data.
 */
Box2D.Dynamics.b2World.prototype.DrawDebugData = function() {
  var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  var /** @type {number} */ i = 0;
  var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = null;
  var /** @type {Box2D.Collision.IBroadPhase} */ bp = null;
  var /** @type {Box2D.Common.Math.b2Transform} */ xf = null;
  var /** @type {Box2D.Collision.Shapes.b2Shape} */ s = null;
  if (this.Box2D_Dynamics_b2World_m_debugDraw == null) {
    return;
  }
  this.Box2D_Dynamics_b2World_m_debugDraw.m_sprite.graphics.clear();
  var /** @type {number} */ flags = this.Box2D_Dynamics_b2World_m_debugDraw.GetFlags();
  //var /** @type {number} */ i = 0;
  //var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ f = null;
  //var /** @type {Box2D.Collision.Shapes.b2Shape} */ s = null;
  //var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = null;
  //var /** @type {Box2D.Collision.IBroadPhase} */ bp = null;
  var /** @type {Box2D.Common.Math.b2Vec2} */ invQ = new Box2D.Common.Math.b2Vec2();
  var /** @type {Box2D.Common.Math.b2Vec2} */ x1 = new Box2D.Common.Math.b2Vec2();
  var /** @type {Box2D.Common.Math.b2Vec2} */ x2 = new Box2D.Common.Math.b2Vec2();
  //var /** @type {Box2D.Common.Math.b2Transform} */ xf = null;
  var /** @type {Box2D.Collision.b2AABB} */ b1 = new Box2D.Collision.b2AABB();
  var /** @type {Box2D.Collision.b2AABB} */ b2 = new Box2D.Collision.b2AABB();
  var /** @type {Array} */ vs = [new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2()];
  var /** @type {Box2D.Common.b2Color} */ color = new Box2D.Common.b2Color(0, 0, 0);
  if (flags & Box2D.Dynamics.b2DebugDraw.e_shapeBit) {
    for (b = this.m_bodyList; b; b = b.m_next) {
      xf = b.m_xf;
      for (f = b.GetFixtureList(); f; f = f.m_next) {
        s = f.GetShape();
        if (b.IsActive() == false) {
          color.Set(0.5, 0.5, 0.3);
          this.DrawShape(s, xf, color);
        } else if (b.GetType() == Box2D.Dynamics.b2Body.b2_staticBody) {
          color.Set(0.5, 0.9, 0.5);
          this.DrawShape(s, xf, color);
        } else if (b.GetType() == Box2D.Dynamics.b2Body.b2_kinematicBody) {
          color.Set(0.5, 0.5, 0.9);
          this.DrawShape(s, xf, color);
        } else if (b.IsAwake() == false) {
          color.Set(0.6, 0.6, 0.6);
          this.DrawShape(s, xf, color);
        } else {
          color.Set(0.9, 0.7, 0.7);
          this.DrawShape(s, xf, color);
        }
      }
    }
  }
  if (flags & Box2D.Dynamics.b2DebugDraw.e_jointBit) {
    for (j = this.Box2D_Dynamics_b2World_m_jointList; j; j = j.m_next) {
      this.DrawJoint(j);
    }
  }
  if (flags & Box2D.Dynamics.b2DebugDraw.e_controllerBit) {
    for (var /** @type {Box2D.Dynamics.Controllers.b2Controller} */ c = this.Box2D_Dynamics_b2World_m_controllerList; c; c = c.m_next) {
      c.Draw(this.Box2D_Dynamics_b2World_m_debugDraw);
    }
  }
  if (flags & Box2D.Dynamics.b2DebugDraw.e_pairBit) {
    color.Set(0.3, 0.9, 0.9);
    for (var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ contact = this.m_contactManager.m_contactList; contact; contact = contact.GetNext()) {
      var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureA = contact.GetFixtureA();
      var /** @type {Box2D.Dynamics.b2Fixture} */ fixtureB = contact.GetFixtureB();
      var /** @type {Box2D.Common.Math.b2Vec2} */ cA = fixtureA.GetAABB().GetCenter();
      var /** @type {Box2D.Common.Math.b2Vec2} */ cB = fixtureB.GetAABB().GetCenter();
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(cA, cB, color);
    }
  }
  if (flags & Box2D.Dynamics.b2DebugDraw.e_aabbBit) {
    bp = this.m_contactManager.m_broadPhase;
    vs = [new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2(), new Box2D.Common.Math.b2Vec2()];
    for (b = this.m_bodyList; b; b = b.GetNext()) {
      if (b.IsActive() == false) {
        continue;
      }
      for (f = b.GetFixtureList(); f; f = f.GetNext()) {
        var /** @type {Box2D.Collision.b2AABB} */ aabb = bp.GetFatAABB(f.m_proxy);
        vs[0].Set(aabb.lowerBound.x, aabb.lowerBound.y);
        vs[1].Set(aabb.upperBound.x, aabb.lowerBound.y);
        vs[2].Set(aabb.upperBound.x, aabb.upperBound.y);
        vs[3].Set(aabb.lowerBound.x, aabb.upperBound.y);
        this.Box2D_Dynamics_b2World_m_debugDraw.DrawPolygon(vs, 4, color);
      }
    }
  }
  if (flags & Box2D.Dynamics.b2DebugDraw.e_centerOfMassBit) {
    for (b = this.m_bodyList; b; b = b.m_next) {
      xf = Box2D.Dynamics.b2World.s_xf;
      xf.R = b.m_xf.R;
      xf.position = b.GetWorldCenter();
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawTransform(xf);
    }
  }
};


/**
 * Query the world for all fixtures that potentially overlap the
 * provided AABB.
 * @asparam callback a user implemented callback class. It should match signature
 * <code>function Callback(fixture:b2Fixture):Boolean</code>
 * Return true to continue to the next fixture.
 * @asparam aabb the query box.
 * @param {Function} callback
 * @param {Box2D.Collision.b2AABB} aabb
 */
Box2D.Dynamics.b2World.prototype.QueryAABB = function(callback, aabb) {
  var self = this;
  function WorldQueryWrapper(proxy) {
    return !!(callback(broadPhase.GetUserData(proxy)));
  };
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_contactManager.m_broadPhase;
  broadPhase.Query(WorldQueryWrapper, aabb);
};


/**
 * Query the world for all fixtures that precisely overlap the
 * provided transformed shape.
 * @asparam callback a user implemented callback class. It should match signature
 * <code>function Callback(fixture:b2Fixture):Boolean</code>
 * Return true to continue to the next fixture.
 * asonly
 * @param {Function} callback
 * @param {Box2D.Collision.Shapes.b2Shape} shape
 * @param {Box2D.Common.Math.b2Transform=} transform
 */
Box2D.Dynamics.b2World.prototype.QueryShape = function(callback, shape, transform) {
  var self = this;
  transform = typeof transform !== 'undefined' ? transform : null;
  function WorldQueryWrapper(proxy) {
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixture = broadPhase.GetUserData(proxy);
    if (Box2D.Collision.Shapes.b2ShapeUtil.TestOverlap(shape, transform, fixture.GetShape(), fixture.GetBody().GetTransform()))
      return !!(callback(fixture));
    return true;
  };
  if (transform == null) {
    transform = new Box2D.Common.Math.b2Transform();
    transform.SetIdentity();
  }
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_contactManager.m_broadPhase;
  var /** @type {Box2D.Collision.b2AABB} */ aabb = new Box2D.Collision.b2AABB();
  shape.ComputeAABB(aabb, transform);
  broadPhase.Query(WorldQueryWrapper, aabb);
};


/**
 * Query the world for all fixtures that contain a point.
 * @asparam callback a user implemented callback class. It should match signature
 * <code>function Callback(fixture:b2Fixture):Boolean</code>
 * Return true to continue to the next fixture.
 * asonly
 * @param {Function} callback
 * @param {Box2D.Common.Math.b2Vec2} p
 */
Box2D.Dynamics.b2World.prototype.QueryPoint = function(callback, p) {
  var self = this;
  function WorldQueryWrapper(proxy) {
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixture = broadPhase.GetUserData(proxy);
    if (fixture.TestPoint(p))
      return !!(callback(fixture));
    return true;
  };
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_contactManager.m_broadPhase;
  var /** @type {Box2D.Collision.b2AABB} */ aabb = new Box2D.Collision.b2AABB();
  aabb.lowerBound.Set(p.x - Box2D.Common.b2Settings.b2_linearSlop, p.y - Box2D.Common.b2Settings.b2_linearSlop);
  aabb.upperBound.Set(p.x + Box2D.Common.b2Settings.b2_linearSlop, p.y + Box2D.Common.b2Settings.b2_linearSlop);
  broadPhase.Query(WorldQueryWrapper, aabb);
};


/**
 * Ray-cast the world for all fixtures in the path of the ray. Your callback
 * Controls whether you get the closest point, any point, or n-points
 * The ray-cast ignores shapes that contain the starting point
 * @asparam callback A callback function which must be of signature:
 * <code>function Callback(fixture:b2Fixture,    // The fixture hit by the ray
 * point:b2Vec2,         // The point of initial intersection
 * normal:b2Vec2,        // The normal vector at the point of intersection
 * fraction:Number       // The fractional length along the ray of the intersection
 * ):Number
 * </code>
 * Callback should return the new length of the ray as a fraction of the original length.
 * By returning 0, you immediately terminate.
 * By returning 1, you continue wiht the original ray.
 * By returning the current fraction, you proceed to find the closest point.
 * @asparam point1 the ray starting point
 * @asparam point2 the ray ending point
 * @param {Function} callback
 * @param {Box2D.Common.Math.b2Vec2} point1
 * @param {Box2D.Common.Math.b2Vec2} point2
 */
Box2D.Dynamics.b2World.prototype.RayCast = function(callback, point1, point2) {
  var self = this;
  function RayCastWrapper(input, proxy) {
    var /** @type {*} */ userData = broadPhase.GetUserData(proxy);
    var /** @type {Box2D.Dynamics.b2Fixture} */ fixture = userData;
    var /** @type {boolean} */ hit = fixture.RayCast(output, input);
    if (hit) {
      var /** @type {number} */ fraction = output.fraction;
      var /** @type {Box2D.Common.Math.b2Vec2} */ point = new Box2D.Common.Math.b2Vec2((1.0 - fraction) * point1.x + fraction * point2.x, (1.0 - fraction) * point1.y + fraction * point2.y);
      return Number(callback(fixture, point, output.normal, fraction));
    }
    return input.maxFraction;
  };
  var /** @type {Box2D.Collision.IBroadPhase} */ broadPhase = this.m_contactManager.m_broadPhase;
  var /** @type {Box2D.Collision.b2RayCastOutput} */ output = new Box2D.Collision.b2RayCastOutput();
  var /** @type {Box2D.Collision.b2RayCastInput} */ input = new Box2D.Collision.b2RayCastInput(point1, point2);
  broadPhase.RayCast(RayCastWrapper, input);
};


/**
 * @param {Box2D.Common.Math.b2Vec2} point1
 * @param {Box2D.Common.Math.b2Vec2} point2
 * @return {Box2D.Dynamics.b2Fixture}
 */
Box2D.Dynamics.b2World.prototype.RayCastOne = function(point1, point2) {
  var self = this;
  function RayCastOneWrapper(fixture, point, normal, fraction) {
    result = fixture;
    return fraction;
  };
  var /** @type {Box2D.Dynamics.b2Fixture} */ result = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ result = null;
  this.RayCast(RayCastOneWrapper, point1, point2);
  return result;
};


/**
 * @param {Box2D.Common.Math.b2Vec2} point1
 * @param {Box2D.Common.Math.b2Vec2} point2
 * @return {Array}
 */
Box2D.Dynamics.b2World.prototype.RayCastAll = function(point1, point2) {
  var self = this;
  function RayCastAllWrapper(fixture, point, normal, fraction) {
    result[result.length] = fixture;
    return 1;
  };
  var /** @type {Array} */ result = new Array();
  this.RayCast(RayCastAllWrapper, point1, point2);
  return result;
};


/**
 * Get the world body list. With the returned body, use b2Body::GetNext to get
 * the next body in the world list. A NULL body indicates the end of the list.
 * @asreturn the head of the world body list.
 * @return {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2World.prototype.GetBodyList = function() {
  return this.m_bodyList;
};


/**
 * Get the world joint list. With the returned joint, use b2Joint::GetNext to get
 * the next joint in the world list. A NULL joint indicates the end of the list.
 * @asreturn the head of the world joint list.
 * @return {Box2D.Dynamics.Joints.b2Joint}
 */
Box2D.Dynamics.b2World.prototype.GetJointList = function() {
  return this.Box2D_Dynamics_b2World_m_jointList;
};


/**
 * Get the world contact list. With the returned contact, use b2Contact::GetNext to get
 * the next contact in the world list. A NULL contact indicates the end of the list.
 * @asreturn the head of the world contact list.
 * warning contacts are 
 * @return {Box2D.Dynamics.Contacts.b2Contact}
 */
Box2D.Dynamics.b2World.prototype.GetContactList = function() {
  return this.m_contactList;
};


/**
 * Is the world locked (in the middle of a time step).
 * @return {boolean}
 */
Box2D.Dynamics.b2World.prototype.IsLocked = function() {
  return (this.m_flags & Box2D.Dynamics.b2World.e_locked) > 0;
};


/**
 * @private
 * @type {Array}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_s_stack = null;


/**
 * @param {Box2D.Dynamics.b2TimeStep} step
 */
Box2D.Dynamics.b2World.prototype.Solve = function(step) {
  var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  var /** @type {Box2D.Dynamics.b2Body} */ other = null;
  //var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  for (var /** @type {Box2D.Dynamics.Controllers.b2Controller} */ controller = this.Box2D_Dynamics_b2World_m_controllerList; controller; controller = controller.m_next) {
    controller.Step(step);
  }
  var /** @type {Box2D.Dynamics.b2Island} */ island = this.Box2D_Dynamics_b2World_m_island;
  island.Initialize(this.Box2D_Dynamics_b2World_m_bodyCount, this.m_contactCount, this.Box2D_Dynamics_b2World_m_jointCount, null, this.m_contactManager.m_contactListener, this.Box2D_Dynamics_b2World_m_contactSolver);
  for (b = this.m_bodyList; b; b = b.m_next) {
    b.m_flags &= (~Box2D.Dynamics.b2Body.e_islandFlag) >>> 0;
  }
  for (var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ c = this.m_contactList; c; c = c.m_next) {
    c.m_flags &= (~Box2D.Dynamics.Contacts.b2Contact.e_islandFlag) >>> 0;
  }
  for (var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = this.Box2D_Dynamics_b2World_m_jointList; j; j = j.m_next) {
    j.m_islandFlag = false;
  }
  var /** @type {number} */ stackSize = this.Box2D_Dynamics_b2World_m_bodyCount;
  var /** @type {Array} */ stack = this.Box2D_Dynamics_b2World_s_stack;
  for (var /** @type {Box2D.Dynamics.b2Body} */ seed = this.m_bodyList; seed; seed = seed.m_next) {
    if (seed.m_flags & Box2D.Dynamics.b2Body.e_islandFlag) {
      continue;
    }
    if (seed.IsAwake() == false || seed.IsActive() == false) {
      continue;
    }
    if (seed.GetType() == Box2D.Dynamics.b2Body.b2_staticBody) {
      continue;
    }
    island.Clear();
    var /** @type {number} */ stackCount = 0;
    stack[stackCount++] = seed;
    seed.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
    while (stackCount > 0) {
      b = /* implicit cast */ org.apache.royale.utils.Language.as(stack[--stackCount], Box2D.Dynamics.b2Body, true);
      island.AddBody(b);
      if (b.IsAwake() == false) {
        b.SetAwake(true);
      }
      if (b.GetType() == Box2D.Dynamics.b2Body.b2_staticBody) {
        continue;
      }
      //var /** @type {Box2D.Dynamics.b2Body} */ other = null;
      for (var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ ce = b.m_contactList; ce; ce = ce.next) {
        if (ce.contact.m_flags & Box2D.Dynamics.Contacts.b2Contact.e_islandFlag) {
          continue;
        }
        if (ce.contact.IsSensor() == true || ce.contact.IsEnabled() == false || ce.contact.IsTouching() == false) {
          continue;
        }
        island.AddContact(ce.contact);
        ce.contact.m_flags |= Box2D.Dynamics.Contacts.b2Contact.e_islandFlag;
        other = ce.other;
        if (other.m_flags & Box2D.Dynamics.b2Body.e_islandFlag) {
          continue;
        }
        stack[stackCount++] = other;
        other.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
      }
      for (var /** @type {Box2D.Dynamics.Joints.b2JointEdge} */ jn = b.m_jointList; jn; jn = jn.next) {
        if (jn.joint.m_islandFlag == true) {
          continue;
        }
        other = jn.other;
        if (other.IsActive() == false) {
          continue;
        }
        island.AddJoint(jn.joint);
        jn.joint.m_islandFlag = true;
        if (other.m_flags & Box2D.Dynamics.b2Body.e_islandFlag) {
          continue;
        }
        stack[stackCount++] = other;
        other.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
      }
    }
    island.Solve(step, this.Box2D_Dynamics_b2World_m_gravity, this.Box2D_Dynamics_b2World_m_allowSleep);
    for (var /** @type {number} */ i = 0; i < island.m_bodyCount; ++i) {
      b = /* implicit cast */ org.apache.royale.utils.Language.as(island.m_bodies[i], Box2D.Dynamics.b2Body, true);
      if (b.GetType() == Box2D.Dynamics.b2Body.b2_staticBody) {
        b.m_flags &= (~Box2D.Dynamics.b2Body.e_islandFlag) >>> 0;
      }
    }
  }
  for (i = 0; i < stack.length; ++i) {
    if (!stack[i])
      break;
    stack[i] = null;
  }
  for (b = this.m_bodyList; b; b = b.m_next) {
    if (b.IsAwake() == false || b.IsActive() == false) {
      continue;
    }
    if (b.GetType() == Box2D.Dynamics.b2Body.b2_staticBody) {
      continue;
    }
    b.SynchronizeFixtures();
  }
  this.m_contactManager.FindNewContacts();
};


Box2D.Dynamics.b2World.get__s_backupA = function() {
  var value = new Box2D.Common.Math.b2Sweep();
  Object.defineProperties(Box2D.Dynamics.b2World, { s_backupA: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_backupA = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_backupA: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Sweep}
 */
Box2D.Dynamics.b2World.s_backupA;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Sweep}
 */
s_backupA: {
  get: Box2D.Dynamics.b2World.get__s_backupA,
  set: Box2D.Dynamics.b2World.set__s_backupA,
  configurable: true}});


Box2D.Dynamics.b2World.get__s_backupB = function() {
  var value = new Box2D.Common.Math.b2Sweep();
  Object.defineProperties(Box2D.Dynamics.b2World, { s_backupB: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_backupB = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_backupB: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.Math.b2Sweep}
 */
Box2D.Dynamics.b2World.s_backupB;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Common.Math.b2Sweep}
 */
s_backupB: {
  get: Box2D.Dynamics.b2World.get__s_backupB,
  set: Box2D.Dynamics.b2World.set__s_backupB,
  configurable: true}});


Box2D.Dynamics.b2World.get__s_timestep = function() {
  var value = new Box2D.Dynamics.b2TimeStep();
  Object.defineProperties(Box2D.Dynamics.b2World, { s_timestep: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_timestep = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_timestep: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Dynamics.b2TimeStep}
 */
Box2D.Dynamics.b2World.s_timestep;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Dynamics.b2TimeStep}
 */
s_timestep: {
  get: Box2D.Dynamics.b2World.get__s_timestep,
  set: Box2D.Dynamics.b2World.set__s_timestep,
  configurable: true}});


/**
 * @private
 * @type {Array}
 */
Box2D.Dynamics.b2World.s_queue = new Array();


/**
 * @param {Box2D.Dynamics.b2TimeStep} step
 */
Box2D.Dynamics.b2World.prototype.SolveTOI = function(step) {
  var /** @type {Box2D.Dynamics.b2Body} */ bB = null;
  var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ c = null;
  var /** @type {number} */ i = 0;
  var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = null;
  var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ cEdge = null;
  var /** @type {Box2D.Dynamics.b2Fixture} */ fA = null;
  var /** @type {Box2D.Dynamics.b2Fixture} */ fB = null;
  var /** @type {Box2D.Dynamics.b2Body} */ bA = null;
  //var /** @type {Box2D.Dynamics.b2Body} */ b = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ fA = null;
  //var /** @type {Box2D.Dynamics.b2Fixture} */ fB = null;
  //var /** @type {Box2D.Dynamics.b2Body} */ bA = null;
  //var /** @type {Box2D.Dynamics.b2Body} */ bB = null;
  //var /** @type {Box2D.Dynamics.Contacts.b2ContactEdge} */ cEdge = null;
  //var /** @type {Box2D.Dynamics.Joints.b2Joint} */ j = null;
  var /** @type {Box2D.Dynamics.b2Island} */ island = this.Box2D_Dynamics_b2World_m_island;
  island.Initialize(this.Box2D_Dynamics_b2World_m_bodyCount, Box2D.Common.b2Settings.b2_maxTOIContactsPerIsland, Box2D.Common.b2Settings.b2_maxTOIJointsPerIsland, null, this.m_contactManager.m_contactListener, this.Box2D_Dynamics_b2World_m_contactSolver);
  var /** @type {Array} */ queue = Box2D.Dynamics.b2World.s_queue;
  for (b = this.m_bodyList; b; b = b.m_next) {
    b.m_flags &= (~Box2D.Dynamics.b2Body.e_islandFlag) >>> 0;
    b.m_sweep.t0 = 0.0;
  }
  //var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ c = null;
  for (c = this.m_contactList; c; c = c.m_next) {
    c.m_flags &= (~(Box2D.Dynamics.Contacts.b2Contact.e_toiFlag | Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)) >>> 0;
  }
  for (j = this.Box2D_Dynamics_b2World_m_jointList; j; j = j.m_next) {
    j.m_islandFlag = false;
  }
  for (;;) {
    var /** @type {Box2D.Dynamics.Contacts.b2Contact} */ minContact = null;
    var /** @type {number} */ minTOI = 1.0;
    for (c = this.m_contactList; c; c = c.m_next) {
      if (c.IsSensor() == true || c.IsEnabled() == false || c.IsContinuous() == false) {
        continue;
      }
      var /** @type {number} */ toi = 1.0;
      if (c.m_flags & Box2D.Dynamics.Contacts.b2Contact.e_toiFlag) {
        toi = c.m_toi;
      } else {
        fA = c.m_fixtureA;
        fB = c.m_fixtureB;
        bA = fA.m_body;
        bB = fB.m_body;
        if ((bA.GetType() != Box2D.Dynamics.b2Body.b2_dynamicBody || bA.IsAwake() == false) && (bB.GetType() != Box2D.Dynamics.b2Body.b2_dynamicBody || bB.IsAwake() == false)) {
          continue;
        }
        var /** @type {number} */ t0 = bA.m_sweep.t0;
        if (bA.m_sweep.t0 < bB.m_sweep.t0) {
          t0 = bB.m_sweep.t0;
          bA.m_sweep.Advance(t0);
        } else if (bB.m_sweep.t0 < bA.m_sweep.t0) {
          t0 = bA.m_sweep.t0;
          bB.m_sweep.Advance(t0);
        }
        toi = c.ComputeTOI(bA.m_sweep, bB.m_sweep);
        Box2D.Common.b2Settings.b2Assert(0.0 <= toi && toi <= 1.0);
        if (toi > 0.0 && toi < 1.0) {
          toi = (1.0 - toi) * t0 + toi;
          if (toi > 1)
            toi = 1;
        }
        c.m_toi = toi;
        c.m_flags |= Box2D.Dynamics.Contacts.b2Contact.e_toiFlag;
      }
      if (Number.MIN_VALUE < toi && toi < minTOI) {
        minContact = c;
        minTOI = toi;
      }
    }
    if (minContact == null || 1.0 - 100.0 * Number.MIN_VALUE < minTOI) {
      break;
    }
    fA = minContact.m_fixtureA;
    fB = minContact.m_fixtureB;
    bA = fA.m_body;
    bB = fB.m_body;
    Box2D.Dynamics.b2World.s_backupA.Set(bA.m_sweep);
    Box2D.Dynamics.b2World.s_backupB.Set(bB.m_sweep);
    bA.Advance(minTOI);
    bB.Advance(minTOI);
    minContact.Update(this.m_contactManager.m_contactListener);
    minContact.m_flags &= (~Box2D.Dynamics.Contacts.b2Contact.e_toiFlag) >>> 0;
    if (minContact.IsSensor() == true || minContact.IsEnabled() == false) {
      bA.m_sweep.Set(Box2D.Dynamics.b2World.s_backupA);
      bB.m_sweep.Set(Box2D.Dynamics.b2World.s_backupB);
      bA.SynchronizeTransform();
      bB.SynchronizeTransform();
      continue;
    }
    if (minContact.IsTouching() == false) {
      continue;
    }
    var /** @type {Box2D.Dynamics.b2Body} */ seed = bA;
    if (seed.GetType() != Box2D.Dynamics.b2Body.b2_dynamicBody) {
      seed = bB;
    }
    island.Clear();
    var /** @type {number} */ queueStart = 0;
    var /** @type {number} */ queueSize = 0;
    queue[queueStart + queueSize++] = seed;
    seed.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
    while (queueSize > 0) {
      b = /* implicit cast */ org.apache.royale.utils.Language.as(queue[queueStart++], Box2D.Dynamics.b2Body, true);
      --queueSize;
      island.AddBody(b);
      if (b.IsAwake() == false) {
        b.SetAwake(true);
      }
      if (b.GetType() != Box2D.Dynamics.b2Body.b2_dynamicBody) {
        continue;
      }
      for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
        if (island.m_contactCount == island.m_contactCapacity) {
          break;
        }
        if (cEdge.contact.m_flags & Box2D.Dynamics.Contacts.b2Contact.e_islandFlag) {
          continue;
        }
        if (cEdge.contact.IsSensor() == true || cEdge.contact.IsEnabled() == false || cEdge.contact.IsTouching() == false) {
          continue;
        }
        island.AddContact(cEdge.contact);
        cEdge.contact.m_flags |= Box2D.Dynamics.Contacts.b2Contact.e_islandFlag;
        var /** @type {Box2D.Dynamics.b2Body} */ other = cEdge.other;
        if (other.m_flags & Box2D.Dynamics.b2Body.e_islandFlag) {
          continue;
        }
        if (other.GetType() != Box2D.Dynamics.b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true);
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
      }
      for (var /** @type {Box2D.Dynamics.Joints.b2JointEdge} */ jEdge = b.m_jointList; jEdge; jEdge = jEdge.next) {
        if (island.m_jointCount == island.m_jointCapacity)
          continue;
        if (jEdge.joint.m_islandFlag == true)
          continue;
        other = jEdge.other;
        if (other.IsActive() == false) {
          continue;
        }
        island.AddJoint(jEdge.joint);
        jEdge.joint.m_islandFlag = true;
        if (other.m_flags & Box2D.Dynamics.b2Body.e_islandFlag)
          continue;
        if (other.GetType() != Box2D.Dynamics.b2Body.b2_staticBody) {
          other.Advance(minTOI);
          other.SetAwake(true);
        }
        queue[queueStart + queueSize] = other;
        ++queueSize;
        other.m_flags |= Box2D.Dynamics.b2Body.e_islandFlag;
      }
    }
    var /** @type {Box2D.Dynamics.b2TimeStep} */ subStep = Box2D.Dynamics.b2World.s_timestep;
    subStep.warmStarting = false;
    subStep.dt = (1.0 - minTOI) * step.dt;
    subStep.inv_dt = 1.0 / subStep.dt;
    subStep.dtRatio = 0.0;
    subStep.velocityIterations = step.velocityIterations;
    subStep.positionIterations = step.positionIterations;
    island.SolveTOI(subStep);
    //var /** @type {number} */ i = 0;
    for (i = 0; i < island.m_bodyCount; ++i) {
      b = /* implicit cast */ org.apache.royale.utils.Language.as(island.m_bodies[i], Box2D.Dynamics.b2Body, true);
      b.m_flags &= (~Box2D.Dynamics.b2Body.e_islandFlag) >>> 0;
      if (b.IsAwake() == false) {
        continue;
      }
      if (b.GetType() != Box2D.Dynamics.b2Body.b2_dynamicBody) {
        continue;
      }
      b.SynchronizeFixtures();
      for (cEdge = b.m_contactList; cEdge; cEdge = cEdge.next) {
        cEdge.contact.m_flags &= (~Box2D.Dynamics.Contacts.b2Contact.e_toiFlag) >>> 0;
      }
    }
    for (i = 0; i < island.m_contactCount; ++i) {
      c = /* implicit cast */ org.apache.royale.utils.Language.as(island.m_contacts[i], Box2D.Dynamics.Contacts.b2Contact, true);
      c.m_flags &= (~(Box2D.Dynamics.Contacts.b2Contact.e_toiFlag | Box2D.Dynamics.Contacts.b2Contact.e_islandFlag)) >>> 0;
    }
    for (i = 0; i < island.m_jointCount; ++i) {
      j = /* implicit cast */ org.apache.royale.utils.Language.as(island.m_joints[i], Box2D.Dynamics.Joints.b2Joint, true);
      j.m_islandFlag = false;
    }
    this.m_contactManager.FindNewContacts();
  }
};


Box2D.Dynamics.b2World.get__s_jointColor = function() {
  var value = new Box2D.Common.b2Color(0.5, 0.8, 0.8);
  Object.defineProperties(Box2D.Dynamics.b2World, { s_jointColor: { value: value, writable: true }});
  return value;
};
Box2D.Dynamics.b2World.set__s_jointColor = function(value) {
  Object.defineProperties(Box2D.Dynamics.b2World, { s_jointColor: { value: value, writable: true }});
};
/**
 * @private
 * @type {Box2D.Common.b2Color}
 */
Box2D.Dynamics.b2World.s_jointColor;

Object.defineProperties(Box2D.Dynamics.b2World, /** @lends {Box2D.Dynamics.b2World} */ {
/**
 * @private
 * @type {Box2D.Common.b2Color}
 */
s_jointColor: {
  get: Box2D.Dynamics.b2World.get__s_jointColor,
  set: Box2D.Dynamics.b2World.set__s_jointColor,
  configurable: true}});


/**
 * @param {Box2D.Dynamics.Joints.b2Joint} joint
 */
Box2D.Dynamics.b2World.prototype.DrawJoint = function(joint) {
  var /** @type {Box2D.Dynamics.b2Body} */ b1 = joint.GetBodyA();
  var /** @type {Box2D.Dynamics.b2Body} */ b2 = joint.GetBodyB();
  var /** @type {Box2D.Common.Math.b2Transform} */ xf1 = b1.m_xf;
  var /** @type {Box2D.Common.Math.b2Transform} */ xf2 = b2.m_xf;
  var /** @type {Box2D.Common.Math.b2Vec2} */ x1 = xf1.position;
  var /** @type {Box2D.Common.Math.b2Vec2} */ x2 = xf2.position;
  var /** @type {Box2D.Common.Math.b2Vec2} */ p1 = joint.GetAnchorA();
  var /** @type {Box2D.Common.Math.b2Vec2} */ p2 = joint.GetAnchorB();
  var /** @type {Box2D.Common.b2Color} */ color = Box2D.Dynamics.b2World.s_jointColor;
  switch (joint.m_type) {
    case Box2D.Dynamics.Joints.b2Joint.e_distanceJoint:
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(p1, p2, color);
      break;
    case Box2D.Dynamics.Joints.b2Joint.e_pulleyJoint:
      var /** @type {Box2D.Dynamics.Joints.b2PulleyJoint} */ pulley = joint;
      var /** @type {Box2D.Common.Math.b2Vec2} */ s1 = pulley.GetGroundAnchorA();
      var /** @type {Box2D.Common.Math.b2Vec2} */ s2 = pulley.GetGroundAnchorB();
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(s1, p1, color);
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(s2, p2, color);
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(s1, s2, color);
      break;
    case Box2D.Dynamics.Joints.b2Joint.e_mouseJoint:
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(p1, p2, color);
      break;
    default:
      if (b1 != this.m_groundBody)
        this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(x1, p1, color);
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(p1, p2, color);
      if (b2 != this.m_groundBody)
        this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(x2, p2, color);
  }
};


/**
 * @param {Box2D.Collision.Shapes.b2Shape} shape
 * @param {Box2D.Common.Math.b2Transform} xf
 * @param {Box2D.Common.b2Color} color
 */
Box2D.Dynamics.b2World.prototype.DrawShape = function(shape, xf, color) {
  var /** @type {number} */ i = 0;
  switch (shape.m_type) {
    case Box2D.Collision.Shapes.b2Shape.e_circleShape:
      var /** @type {Box2D.Collision.Shapes.b2CircleShape} */ circle = shape;
      var /** @type {Box2D.Common.Math.b2Vec2} */ center = Box2D.Common.Math.b2Math.MulX(xf, circle.m_p);
      var /** @type {number} */ radius = circle.m_radius;
      var /** @type {Box2D.Common.Math.b2Vec2} */ axis = xf.R.col1;
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSolidCircle(center, radius, axis, color);
      break;
    case Box2D.Collision.Shapes.b2Shape.e_polygonShape:
      //var /** @type {number} */ i = 0;
      var /** @type {Box2D.Collision.Shapes.b2PolygonShape} */ poly = shape;
      var /** @type {number} */ vertexCount = poly.GetVertexCount();
      var /** @type {Array} */ localVertices = poly.GetVertices();
      var /** @type {Array} */ vertices = new Array(vertexCount);
      for (i = 0; i < vertexCount; ++i) {
        vertices[i] = Box2D.Common.Math.b2Math.MulX(xf, /* implicit cast */ org.apache.royale.utils.Language.as(localVertices[i], Box2D.Common.Math.b2Vec2, true));
      }
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSolidPolygon(vertices, vertexCount, color);
      break;
    case Box2D.Collision.Shapes.b2Shape.e_edgeShape:
      var /** @type {Box2D.Collision.Shapes.b2EdgeShape} */ edge = shape;
      this.Box2D_Dynamics_b2World_m_debugDraw.DrawSegment(Box2D.Common.Math.b2Math.MulX(xf, edge.GetVertex1()), Box2D.Common.Math.b2Math.MulX(xf, edge.GetVertex2()), color);
      break;
  }
};


/**
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.m_flags = 0;


/**
 * @type {Box2D.Dynamics.b2ContactManager}
 */
Box2D.Dynamics.b2World.prototype.m_contactManager = null;


/**
 * @private
 * @type {Box2D.Dynamics.Contacts.b2ContactSolver}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_contactSolver = null;


/**
 * @private
 * @type {Box2D.Dynamics.b2Island}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_island = null;


/**
 * @type {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2World.prototype.m_bodyList = null;


/**
 * @private
 * @type {Box2D.Dynamics.Joints.b2Joint}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_jointList = null;


/**
 * @type {Box2D.Dynamics.Contacts.b2Contact}
 */
Box2D.Dynamics.b2World.prototype.m_contactList = null;


/**
 * @private
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_bodyCount = 0;


/**
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.m_contactCount = 0;


/**
 * @private
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_jointCount = 0;


/**
 * @private
 * @type {Box2D.Dynamics.Controllers.b2Controller}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_controllerList = null;


/**
 * @private
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_controllerCount = 0;


/**
 * @private
 * @type {Box2D.Common.Math.b2Vec2}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_gravity = null;


/**
 * @private
 * @type {boolean}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_allowSleep = false;


/**
 * @type {Box2D.Dynamics.b2Body}
 */
Box2D.Dynamics.b2World.prototype.m_groundBody = null;


/**
 * @private
 * @type {Box2D.Dynamics.b2DestructionListener}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_destructionListener = null;


/**
 * @private
 * @type {Box2D.Dynamics.b2DebugDraw}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_debugDraw = null;


/**
 * @private
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.Box2D_Dynamics_b2World_m_inv_dt0 = NaN;


/**
 * @private
 * @type {boolean}
 */
Box2D.Dynamics.b2World.m_warmStarting = false;


/**
 * @private
 * @type {boolean}
 */
Box2D.Dynamics.b2World.m_continuousPhysics = false;


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Dynamics.b2World.e_newFixture = 0x1;


/**
 * @nocollapse
 * @const
 * @type {number}
 */
Box2D.Dynamics.b2World.e_locked = 0x2;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
Box2D.Dynamics.b2World.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'b2World', qName: 'Box2D.Dynamics.b2World', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
Box2D.Dynamics.b2World.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'm_flags': { type: 'int', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_flags = v : inst.m_flags;}},
        'm_contactManager': { type: 'Box2D.Dynamics.b2ContactManager', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_contactManager = v : inst.m_contactManager;}},
        'm_bodyList': { type: 'Box2D.Dynamics.b2Body', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_bodyList = v : inst.m_bodyList;}},
        'm_contactList': { type: 'Box2D.Dynamics.Contacts.b2Contact', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_contactList = v : inst.m_contactList;}},
        'm_contactCount': { type: 'int', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_contactCount = v : inst.m_contactCount;}},
        'm_groundBody': { type: 'Box2D.Dynamics.b2Body', get_set: function (/** Box2D.Dynamics.b2World */ inst, /** * */ v) {return v !== undefined ? inst.m_groundBody = v : inst.m_groundBody;}}
      };
    },
    methods: function () {
      return {
        'b2World': { type: '', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Boolean', false ]; }},
        'SetDestructionListener': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2DestructionListener', false ]; }},
        'SetContactFilter': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2ContactFilter', false ]; }},
        'SetContactListener': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2ContactListener', false ]; }},
        'SetDebugDraw': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2DebugDraw', false ]; }},
        'SetBroadPhase': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Collision.IBroadPhase', false ]; }},
        'Validate': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetProxyCount': { type: 'int', declaredBy: 'Box2D.Dynamics.b2World'},
        'CreateBody': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2BodyDef', false ]; }},
        'DestroyBody': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2Body', false ]; }},
        'CreateJoint': { type: 'Box2D.Dynamics.Joints.b2Joint', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Joints.b2JointDef', false ]; }},
        'DestroyJoint': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Joints.b2Joint', false ]; }},
        'AddController': { type: 'Box2D.Dynamics.Controllers.b2Controller', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Controllers.b2Controller', false ]; }},
        'RemoveController': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Controllers.b2Controller', false ]; }},
        'CreateController': { type: 'Box2D.Dynamics.Controllers.b2Controller', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Controllers.b2Controller', false ]; }},
        'DestroyController': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Controllers.b2Controller', false ]; }},
        'SetWarmStarting': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Boolean', false ]; }},
        'SetContinuousPhysics': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Boolean', false ]; }},
        'GetBodyCount': { type: 'int', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetJointCount': { type: 'int', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetContactCount': { type: 'int', declaredBy: 'Box2D.Dynamics.b2World'},
        'SetGravity': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetGravity': { type: 'Box2D.Common.Math.b2Vec2', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetGroundBody': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2World'},
        'Step': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Number', false ,'int', false ,'int', false ]; }},
        'ClearForces': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World'},
        'DrawDebugData': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World'},
        'QueryAABB': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Function', false ,'Box2D.Collision.b2AABB', false ]; }},
        'QueryShape': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Function', false ,'Box2D.Collision.Shapes.b2Shape', false ,'Box2D.Common.Math.b2Transform', true ]; }},
        'QueryPoint': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Function', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCast': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Function', false ,'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCastOne': { type: 'Box2D.Dynamics.b2Fixture', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'RayCastAll': { type: 'Array', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Common.Math.b2Vec2', false ,'Box2D.Common.Math.b2Vec2', false ]; }},
        'GetBodyList': { type: 'Box2D.Dynamics.b2Body', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetJointList': { type: 'Box2D.Dynamics.Joints.b2Joint', declaredBy: 'Box2D.Dynamics.b2World'},
        'GetContactList': { type: 'Box2D.Dynamics.Contacts.b2Contact', declaredBy: 'Box2D.Dynamics.b2World'},
        'IsLocked': { type: 'Boolean', declaredBy: 'Box2D.Dynamics.b2World'},
        'Solve': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2TimeStep', false ]; }},
        'SolveTOI': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.b2TimeStep', false ]; }},
        'DrawJoint': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Dynamics.Joints.b2Joint', false ]; }},
        'DrawShape': { type: 'void', declaredBy: 'Box2D.Dynamics.b2World', parameters: function () { return [ 'Box2D.Collision.Shapes.b2Shape', false ,'Box2D.Common.Math.b2Transform', false ,'Box2D.Common.b2Color', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
Box2D.Dynamics.b2World.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
Box2D.Dynamics.b2World.prototype.ROYALE_INITIAL_STATICS = Object.keys(Box2D.Dynamics.b2World);
