/**
 * Generated by Apache Royale Compiler from flash/__native/util/Earcut.as
 * flash.__native.util.Earcut
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('flash.__native.util.Earcut');
/* Royale Dependency List: org.apache.royale.utils.Language*/
goog.provide('flash.__native.util.Earcut.Node');



/**
 * @constructor
 */
flash.__native.util.Earcut = function() {
};


/**
 * @param {*} data
 * @param {*=} holeIndices
 * @param {*=} dim
 */
flash.__native.util.Earcut.prototype.earcut = function(data, holeIndices, dim) {
  holeIndices = typeof holeIndices !== 'undefined' ? holeIndices : null;
  dim = typeof dim !== 'undefined' ? dim : 2;
  var /** @type {*} */ hasHoles = holeIndices && holeIndices.length, /** @type {*} */ outerLen = hasHoles ? holeIndices[0] * dim : data.length, /** @type {*} */ outerNode = this.linkedList(data, 0, outerLen, dim, true), /** @type {*} */ triangles = [];
  if (!outerNode || outerNode.next === outerNode.prev)
    return triangles;
  var /** @type {*} */ minX, /** @type {*} */ minY, /** @type {*} */ maxX, /** @type {*} */ maxY, /** @type {*} */ x, /** @type {*} */ y, /** @type {*} */ invSize;
  if (hasHoles)
    outerNode = this.eliminateHoles(data, holeIndices, outerNode, dim);
  if (data.length > 80 * dim) {
    minX = maxX = data[0];
    minY = maxY = data[1];
    for (var /** @type {*} */ i = dim; i < outerLen; i += dim) {
      x = data[i];
      y = data[i + 1];
      if (x < minX)
        minX = x;
      if (y < minY)
        minY = y;
      if (x > maxX)
        maxX = x;
      if (y > maxY)
        maxY = y;
    }
    invSize = Math.max(maxX - minX, maxY - minY);
    invSize = invSize !== 0 ? 1 / invSize : 0;
  }
  this.earcutLinked(outerNode, triangles, dim, minX, minY, invSize);
  return triangles;
};


/**
 * @param {*} data
 * @param {*} start
 * @param {*} end
 * @param {*} dim
 * @param {*} clockwise
 */
flash.__native.util.Earcut.prototype.linkedList = function(data, start, end, dim, clockwise) {
  var /** @type {*} */ i, /** @type {*} */ last;
  if (clockwise === (this.signedArea(data, start, end, dim) > 0)) {
    for (i = start; i < end; i += dim)
      last = this.insertNode(i, data[i], data[i + 1], last);
  } else {
    for (i = end - dim; i >= start; i -= dim)
      last = this.insertNode(i, data[i], data[i + 1], last);
  }
  if (last && this.equals(last, last.next)) {
    this.removeNode(last);
    last = last.next;
  }
  return last;
};


/**
 * @param {*} start
 * @param {*=} end
 */
flash.__native.util.Earcut.prototype.filterPoints = function(start, end) {
  end = typeof end !== 'undefined' ? end : null;
  if (!start)
    return start;
  if (!end)
    end = start;
  var /** @type {*} */ p = start, /** @type {*} */ again;
  do {
    again = false;
    if (!p.steiner && (this.equals(p, p.next) || this.area(p.prev, p, p.next) === 0)) {
      this.removeNode(p);
      p = end = p.prev;
      if (p === p.next)
        break;
      again = true;
    } else {
      p = p.next;
    }
  } while (again || p !== end);
  return end;
};


/**
 * @param {*} ear
 * @param {*} triangles
 * @param {*} dim
 * @param {*} minX
 * @param {*} minY
 * @param {*} invSize
 * @param {*=} pass
 */
flash.__native.util.Earcut.prototype.earcutLinked = function(ear, triangles, dim, minX, minY, invSize, pass) {
  pass = typeof pass !== 'undefined' ? pass : null;
  if (!ear)
    return;
  if (!pass && invSize)
    this.indexCurve(ear, minX, minY, invSize);
  var /** @type {*} */ stop = ear, /** @type {*} */ prev, /** @type {*} */ next;
  while (ear.prev !== ear.next) {
    prev = ear.prev;
    next = ear.next;
    if (invSize ? this.isEarHashed(ear, minX, minY, invSize) : this.isEar(ear)) {
      triangles.push(prev.i / dim);
      triangles.push(ear.i / dim);
      triangles.push(next.i / dim);
      this.removeNode(ear);
      ear = next.next;
      stop = next.next;
      continue;
    }
    ear = next;
    if (ear === stop) {
      if (!pass) {
        this.earcutLinked(this.filterPoints(ear), triangles, dim, minX, minY, invSize, 1);
      } else if (pass === 1) {
        ear = this.cureLocalIntersections(this.filterPoints(ear), triangles, dim);
        this.earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);
      } else if (pass === 2) {
        this.splitEarcut(ear, triangles, dim, minX, minY, invSize);
      }
      break;
    }
  }
};


/**
 * @param {*} ear
 */
flash.__native.util.Earcut.prototype.isEar = function(ear) {
  var /** @type {*} */ a = ear.prev, /** @type {*} */ b = ear, /** @type {*} */ c = ear.next;
  if (this.area(a, b, c) >= 0)
    return false;
  var /** @type {*} */ p = ear.next.next;
  while (p !== ear.prev) {
    if (this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && this.area(p.prev, p, p.next) >= 0)
      return false;
    p = p.next;
  }
  return true;
};


/**
 * @param {*} ear
 * @param {*} minX
 * @param {*} minY
 * @param {*} invSize
 */
flash.__native.util.Earcut.prototype.isEarHashed = function(ear, minX, minY, invSize) {
  var /** @type {*} */ a = ear.prev, /** @type {*} */ b = ear, /** @type {*} */ c = ear.next;
  if (this.area(a, b, c) >= 0)
    return false;
  var /** @type {*} */ minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x), /** @type {*} */ minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y), /** @type {*} */ maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x), /** @type {*} */ maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);
  var /** @type {*} */ minZ = this.zOrder(minTX, minTY, minX, minY, invSize), /** @type {*} */ maxZ = this.zOrder(maxTX, maxTY, minX, minY, invSize);
  var /** @type {*} */ p = ear.prevZ, /** @type {*} */ n = ear.nextZ;
  while (p && p.z >= minZ && n && n.z <= maxZ) {
    if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && this.area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
    if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && this.area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  while (p && p.z >= minZ) {
    if (p !== ear.prev && p !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) && this.area(p.prev, p, p.next) >= 0)
      return false;
    p = p.prevZ;
  }
  while (n && n.z <= maxZ) {
    if (n !== ear.prev && n !== ear.next && this.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) && this.area(n.prev, n, n.next) >= 0)
      return false;
    n = n.nextZ;
  }
  return true;
};


/**
 * @param {*} start
 * @param {*} triangles
 * @param {*} dim
 */
flash.__native.util.Earcut.prototype.cureLocalIntersections = function(start, triangles, dim) {
  var /** @type {*} */ p = start;
  do {
    var /** @type {*} */ a = p.prev, /** @type {*} */ b = p.next.next;
    if (!this.equals(a, b) && this.intersects(a, p, p.next, b) && this.locallyInside(a, b) && this.locallyInside(b, a)) {
      triangles.push(a.i / dim);
      triangles.push(p.i / dim);
      triangles.push(b.i / dim);
      this.removeNode(p);
      this.removeNode(p.next);
      p = start = b;
    }
    p = p.next;
  } while (p !== start);
  return this.filterPoints(p);
};


/**
 * @param {*} start
 * @param {*} triangles
 * @param {*} dim
 * @param {*} minX
 * @param {*} minY
 * @param {*} invSize
 */
flash.__native.util.Earcut.prototype.splitEarcut = function(start, triangles, dim, minX, minY, invSize) {
  var /** @type {*} */ a = start;
  do {
    var /** @type {*} */ b = a.next.next;
    while (b !== a.prev) {
      if (a.i !== b.i && this.isValidDiagonal(a, b)) {
        var /** @type {*} */ c = this.splitPolygon(a, b);
        a = this.filterPoints(a, a.next);
        c = this.filterPoints(c, c.next);
        this.earcutLinked(a, triangles, dim, minX, minY, invSize);
        this.earcutLinked(c, triangles, dim, minX, minY, invSize);
        return;
      }
      b = b.next;
    }
    a = a.next;
  } while (a !== start);
};


/**
 * @param {*} data
 * @param {*} holeIndices
 * @param {*} outerNode
 * @param {*} dim
 */
flash.__native.util.Earcut.prototype.eliminateHoles = function(data, holeIndices, outerNode, dim) {
  var /** @type {*} */ queue = [], /** @type {*} */ i, /** @type {*} */ len, /** @type {*} */ start, /** @type {*} */ end, /** @type {*} */ list;
  for (i = 0, len = holeIndices.length; i < len; i++) {
    start = holeIndices[i] * dim;
    end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
    list = this.linkedList(data, start, end, dim, false);
    if (list === list.next)
      list.steiner = true;
    queue.push(this.getLeftmost(list));
  }
  queue.sort(org.apache.royale.utils.Language.closure(this.compareX, this, 'compareX'));
  for (i = 0; i < queue.length; i++) {
    this.eliminateHole(queue[i], outerNode);
    outerNode = this.filterPoints(outerNode, outerNode.next);
  }
  return outerNode;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.compareX = function(a, b) {
  return a.x - b.x;
};


/**
 * @param {*} hole
 * @param {*} outerNode
 */
flash.__native.util.Earcut.prototype.eliminateHole = function(hole, outerNode) {
  outerNode = this.findHoleBridge(hole, outerNode);
  if (outerNode) {
    var /** @type {*} */ b = this.splitPolygon(outerNode, hole);
    this.filterPoints(b, b.next);
  }
};


/**
 * @param {*} hole
 * @param {*} outerNode
 */
flash.__native.util.Earcut.prototype.findHoleBridge = function(hole, outerNode) {
  var /** @type {*} */ p = outerNode, /** @type {*} */ hx = hole.x, /** @type {*} */ hy = hole.y, /** @type {*} */ qx = -Infinity, /** @type {*} */ m;
  do {
    if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
      var /** @type {*} */ x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
      if (x <= hx && x > qx) {
        qx = x;
        if (x === hx) {
          if (hy === p.y)
            return p;
          if (hy === p.next.y)
            return p.next;
        }
        m = p.x < p.next.x ? p : p.next;
      }
    }
    p = p.next;
  } while (p !== outerNode);
  if (!m)
    return null;
  if (hx === qx)
    return m;
  var /** @type {*} */ stop = m, /** @type {*} */ mx = m.x, /** @type {*} */ my = m.y, /** @type {*} */ tanMin = Infinity, /** @type {*} */ tan;
  p = m;
  do {
    if (hx >= p.x && p.x >= mx && hx !== p.x && this.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {
      tan = Math.abs(hy - p.y) / (hx - p.x);
      if (this.locallyInside(p, hole) && (tan < tanMin || (tan === tanMin && (p.x > m.x || (p.x === m.x && this.sectorContainsSector(m, p)))))) {
        m = p;
        tanMin = tan;
      }
    }
    p = p.next;
  } while (p !== stop);
  return m;
};


/**
 * @param {*} m
 * @param {*} p
 */
flash.__native.util.Earcut.prototype.sectorContainsSector = function(m, p) {
  return this.area(m.prev, m, p.prev) < 0 && this.area(p.next, m, m.next) < 0;
};


/**
 * @param {*} start
 * @param {*} minX
 * @param {*} minY
 * @param {*} invSize
 */
flash.__native.util.Earcut.prototype.indexCurve = function(start, minX, minY, invSize) {
  var /** @type {*} */ p = start;
  do {
    if (p.z === null)
      p.z = this.zOrder(p.x, p.y, minX, minY, invSize);
    p.prevZ = p.prev;
    p.nextZ = p.next;
    p = p.next;
  } while (p !== start);
  p.prevZ.nextZ = null;
  p.prevZ = null;
  this.sortLinked(p);
};


/**
 * @param {*} list
 */
flash.__native.util.Earcut.prototype.sortLinked = function(list) {
  var /** @type {*} */ i, /** @type {*} */ p, /** @type {*} */ q, /** @type {*} */ e, /** @type {*} */ tail, /** @type {*} */ numMerges, /** @type {*} */ pSize, /** @type {*} */ qSize, /** @type {*} */ inSize = 1;
  do {
    p = list;
    list = null;
    tail = null;
    numMerges = 0;
    while (p) {
      numMerges++;
      q = p;
      pSize = 0;
      for (i = 0; i < inSize; i++) {
        pSize++;
        q = q.nextZ;
        if (!q)
          break;
      }
      qSize = inSize;
      while (pSize > 0 || (qSize > 0 && q)) {
        if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
          e = p;
          p = p.nextZ;
          pSize--;
        } else {
          e = q;
          q = q.nextZ;
          qSize--;
        }
        if (tail)
          tail.nextZ = e;
        else
          list = e;
        e.prevZ = tail;
        tail = e;
      }
      p = q;
    }
    tail.nextZ = null;
    inSize *= 2;
  } while (numMerges > 1);
  return list;
};


/**
 * @param {*} x
 * @param {*} y
 * @param {*} minX
 * @param {*} minY
 * @param {*} invSize
 */
flash.__native.util.Earcut.prototype.zOrder = function(x, y, minX, minY, invSize) {
  x = 32767 * (x - minX) * invSize;
  y = 32767 * (y - minY) * invSize;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;
  return x | (y << 1);
};


/**
 * @param {*} start
 */
flash.__native.util.Earcut.prototype.getLeftmost = function(start) {
  var /** @type {*} */ p = start, /** @type {*} */ leftmost = start;
  do {
    if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y))
      leftmost = p;
    p = p.next;
  } while (p !== start);
  return leftmost;
};


/**
 * @param {*} ax
 * @param {*} ay
 * @param {*} bx
 * @param {*} by
 * @param {*} cx
 * @param {*} cy
 * @param {*} px
 * @param {*} py
 */
flash.__native.util.Earcut.prototype.pointInTriangle = function(ax, ay, bx, by, cx, cy, px, py) {
  return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 && (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 && (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.isValidDiagonal = function(a, b) {
  return a.next.i !== b.i && a.prev.i !== b.i && !this.intersectsPolygon(a, b) && (this.locallyInside(a, b) && this.locallyInside(b, a) && this.middleInside(a, b) && (this.area(a.prev, a, b.prev) || this.area(a, b.prev, b)) || this.equals(a, b) && this.area(a.prev, a, a.next) > 0 && this.area(b.prev, b, b.next) > 0);
};


/**
 * @param {*} p
 * @param {*} q
 * @param {*} r
 */
flash.__native.util.Earcut.prototype.area = function(p, q, r) {
  return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
};


/**
 * @param {*} p1
 * @param {*} p2
 */
flash.__native.util.Earcut.prototype.equals = function(p1, p2) {
  return p1.x === p2.x && p1.y === p2.y;
};


/**
 * @param {*} p1
 * @param {*} q1
 * @param {*} p2
 * @param {*} q2
 */
flash.__native.util.Earcut.prototype.intersects = function(p1, q1, p2, q2) {
  var /** @type {*} */ o1 = this.sign(this.area(p1, q1, p2));
  var /** @type {*} */ o2 = this.sign(this.area(p1, q1, q2));
  var /** @type {*} */ o3 = this.sign(this.area(p2, q2, p1));
  var /** @type {*} */ o4 = this.sign(this.area(p2, q2, q1));
  if (o1 !== o2 && o3 !== o4)
    return true;
  if (o1 === 0 && this.onSegment(p1, p2, q1))
    return true;
  if (o2 === 0 && this.onSegment(p1, q2, q1))
    return true;
  if (o3 === 0 && this.onSegment(p2, p1, q2))
    return true;
  if (o4 === 0 && this.onSegment(p2, q1, q2))
    return true;
  return false;
};


/**
 * @param {*} p
 * @param {*} q
 * @param {*} r
 */
flash.__native.util.Earcut.prototype.onSegment = function(p, q, r) {
  return q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) && q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y);
};


/**
 * @param {*} num
 */
flash.__native.util.Earcut.prototype.sign = function(num) {
  return num > 0 ? 1 : num < 0 ? -1 : 0;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.intersectsPolygon = function(a, b) {
  var /** @type {*} */ p = a;
  do {
    if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i && this.intersects(p, p.next, a, b))
      return true;
    p = p.next;
  } while (p !== a);
  return false;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.locallyInside = function(a, b) {
  return this.area(a.prev, a, a.next) < 0 ? this.area(a, b, a.next) >= 0 && this.area(a, a.prev, b) >= 0 : this.area(a, b, a.prev) < 0 || this.area(a, a.next, b) < 0;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.middleInside = function(a, b) {
  var /** @type {*} */ p = a, /** @type {*} */ inside = false, /** @type {*} */ px = (a.x + b.x) / 2, /** @type {*} */ py = (a.y + b.y) / 2;
  do {
    if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y && (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
      inside = !inside;
    p = p.next;
  } while (p !== a);
  return inside;
};


/**
 * @param {*} a
 * @param {*} b
 */
flash.__native.util.Earcut.prototype.splitPolygon = function(a, b) {
  var /** @type {*} */ a2 = new flash.__native.util.Earcut.Node(a.i, a.x, a.y), /** @type {*} */ b2 = new flash.__native.util.Earcut.Node(b.i, b.x, b.y), /** @type {*} */ an = a.next, /** @type {*} */ bp = b.prev;
  a.next = b;
  b.prev = a;
  a2.next = an;
  an.prev = a2;
  b2.next = a2;
  a2.prev = b2;
  bp.next = b2;
  b2.prev = bp;
  return b2;
};


/**
 * @param {*} i
 * @param {*} x
 * @param {*} y
 * @param {*} last
 */
flash.__native.util.Earcut.prototype.insertNode = function(i, x, y, last) {
  var /** @type {*} */ p = new flash.__native.util.Earcut.Node(i, x, y);
  if (!last) {
    p.prev = p;
    p.next = p;
  } else {
    p.next = last.next;
    p.prev = last;
    last.next.prev = p;
    last.next = p;
  }
  return p;
};


/**
 * @param {*} p
 */
flash.__native.util.Earcut.prototype.removeNode = function(p) {
  p.next.prev = p.prev;
  p.prev.next = p.next;
  if (p.prevZ)
    p.prevZ.nextZ = p.nextZ;
  if (p.nextZ)
    p.nextZ.prevZ = p.prevZ;
};


/**
 * @param {*} data
 * @param {*} holeIndices
 * @param {*} dim
 * @param {*} triangles
 */
flash.__native.util.Earcut.prototype.deviation = function(data, holeIndices, dim, triangles) {
  var /** @type {*} */ hasHoles = holeIndices && holeIndices.length;
  var /** @type {*} */ outerLen = hasHoles ? holeIndices[0] * dim : data.length;
  var /** @type {*} */ polygonArea = Math.abs(this.signedArea(data, 0, outerLen, dim));
  if (hasHoles) {
    for (var /** @type {*} */ i = 0, /** @type {*} */ len = holeIndices.length; i < len; i++) {
      var /** @type {*} */ start = holeIndices[i] * dim;
      var /** @type {*} */ end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
      polygonArea -= Math.abs(this.signedArea(data, start, end, dim));
    }
  }
  var /** @type {*} */ trianglesArea = 0;
  for (i = 0; i < triangles.length; i += 3) {
    var /** @type {*} */ a = triangles[i] * dim;
    var /** @type {*} */ b = triangles[i + 1] * dim;
    var /** @type {*} */ c = triangles[i + 2] * dim;
    trianglesArea += Math.abs((data[a] - data[c]) * (data[b + 1] - data[a + 1]) - (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
  }
  return polygonArea === 0 && trianglesArea === 0 ? 0 : Math.abs((trianglesArea - polygonArea) / polygonArea);
};


/**
 * @param {*} data
 * @param {*} start
 * @param {*} end
 * @param {*} dim
 */
flash.__native.util.Earcut.prototype.signedArea = function(data, start, end, dim) {
  var /** @type {*} */ sum = 0;
  for (var /** @type {*} */ i = start, /** @type {*} */ j = end - dim; i < end; i += dim) {
    sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
    j = i;
  }
  return sum;
};


/**
 * @nocollapse
 * @param {*} data
 */
flash.__native.util.Earcut.flatten = function(data) {
  var /** @type {*} */ dim = data[0][0].length, /** @type {*} */ result = {vertices:[], holes:[], dimensions:dim}, /** @type {*} */ holeIndex = 0;
  for (var /** @type {*} */ i = 0; i < data.length; i++) {
    for (var /** @type {*} */ j = 0; j < data[i].length; j++) {
      for (var /** @type {*} */ d = 0; d < dim; d++)
        result.vertices.push(data[i][j][d]);
    }
    if (i > 0) {
      holeIndex += data[i - 1].length;
      result.holes.push(holeIndex);
    }
  }
  return result;
};


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
flash.__native.util.Earcut.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Earcut', qName: 'flash.__native.util.Earcut', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
flash.__native.util.Earcut.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    methods: function () {
      return {
        'Earcut': { type: '', declaredBy: 'flash.__native.util.Earcut'},
        'earcut': { type: '', declaredBy: 'flash.__native.util.Earcut', parameters: function () { return [ '*', false ,'*', true ,'*', true ]; }},
        'deviation': { type: '', declaredBy: 'flash.__native.util.Earcut', parameters: function () { return [ '*', false ,'*', false ,'*', false ,'*', false ]; }},
        '|flatten': { type: '', declaredBy: 'flash.__native.util.Earcut', parameters: function () { return [ '*', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
flash.__native.util.Earcut.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
flash.__native.util.Earcut.prototype.ROYALE_INITIAL_STATICS = Object.keys(flash.__native.util.Earcut);



/**
 * @constructor
 * @param {*} i
 * @param {*} x
 * @param {*} y
 */
flash.__native.util.Earcut.Node = function(i, x, y) {
  this.i = (i) >> 0;
  this.x = Number(x);
  this.y = Number(y);
  this.prev = null;
  this.next = null;
  this.z = null;
  this.prevZ = null;
  this.nextZ = null;
  this.steiner = false;
};


/**
 * @type {number}
 */
flash.__native.util.Earcut.Node.prototype.i = 0;


/**
 * @type {number}
 */
flash.__native.util.Earcut.Node.prototype.x = NaN;


/**
 * @type {number}
 */
flash.__native.util.Earcut.Node.prototype.y = NaN;


/**
 * @type {flash.__native.util.Earcut.Node}
 */
flash.__native.util.Earcut.Node.prototype.prev = null;


/**
 * @type {flash.__native.util.Earcut.Node}
 */
flash.__native.util.Earcut.Node.prototype.next = null;


/**
 * @type {Object}
 */
flash.__native.util.Earcut.Node.prototype.z = null;


/**
 * @type {Object}
 */
flash.__native.util.Earcut.Node.prototype.prevZ = null;


/**
 * @type {Object}
 */
flash.__native.util.Earcut.Node.prototype.nextZ = null;


/**
 * @type {boolean}
 */
flash.__native.util.Earcut.Node.prototype.steiner = false;


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
flash.__native.util.Earcut.Node.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Node', qName: 'flash.__native.util.Earcut.Node', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
flash.__native.util.Earcut.Node.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'i': { type: 'int', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.i = v : inst.i;}},
        'x': { type: 'Number', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.x = v : inst.x;}},
        'y': { type: 'Number', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.y = v : inst.y;}},
        'prev': { type: 'flash.__native.util.Earcut.Node', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.prev = v : inst.prev;}},
        'next': { type: 'flash.__native.util.Earcut.Node', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.next = v : inst.next;}},
        'z': { type: 'Object', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.z = v : inst.z;}},
        'prevZ': { type: 'Object', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.prevZ = v : inst.prevZ;}},
        'nextZ': { type: 'Object', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.nextZ = v : inst.nextZ;}},
        'steiner': { type: 'Boolean', get_set: function (/** flash.__native.util.Earcut.Node */ inst, /** * */ v) {return v !== undefined ? inst.steiner = v : inst.steiner;}}
      };
    },
    methods: function () {
      return {
        'Node': { type: '', declaredBy: 'flash.__native.util.Earcut.Node', parameters: function () { return [ '*', false ,'*', false ,'*', false ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
flash.__native.util.Earcut.Node.prototype.ROYALE_COMPILE_FLAGS = 9;
