/**
 * Generated by Apache Royale Compiler from flash/display/Graphics.as
 * flash.display.Graphics
 *
 * @fileoverview
 *
 * @suppress {missingRequire|checkTypes|accessControls}
 */

goog.provide('flash.display.Graphics');
/* Royale Dependency List: SpriteFlexjs,flash.display.BitmapData,flash.display.GraphicsBitmapFill,flash.display.GraphicsEndFill,flash.display.GraphicsGradientFill,flash.display.GraphicsPath,flash.display.GraphicsSolidFill,flash.display.GraphicsStroke,flash.display.GraphicsTrianglePath,flash.display.IGraphicsData,flash.display.IGraphicsFill,flash.display.IGraphicsPath,flash.display.IGraphicsStroke,flash.geom.ColorTransform,flash.geom.Matrix,flash.geom.Rectangle,flash.geom.Vector3D,org.apache.royale.utils.Language*/




/**
 * @constructor
 */
flash.display.Graphics = function() {
  
  this.graphicsData = new (org.apache.royale.utils.Language.synthVector('flash.display.IGraphicsData'))();
  this.gradientFills = /* implicit cast */ org.apache.royale.utils.Language.as(new (org.apache.royale.utils.Language.synthVector('flash.display.GraphicsGradientFill'))(), org.apache.royale.utils.Language.synthVector('flash.display.GraphicsGradientFill'), true);
  this.flash_display_Graphics_pathPool = [];
  this._worldMatrix = new flash.geom.Matrix();
  ;
};


/**
 * @type {Array.<flash.display.IGraphicsData>}
 */
flash.display.Graphics.prototype.graphicsData = null;


/**
 * @type {Array.<flash.display.GraphicsGradientFill>}
 */
flash.display.Graphics.prototype.gradientFills = null;


/**
 * @type {flash.display.GraphicsStroke}
 */
flash.display.Graphics.prototype.lastStroke = null;


/**
 * @type {flash.display.IGraphicsFill}
 */
flash.display.Graphics.prototype.lastFill = null;


/**
 * @private
 * @type {Array}
 */
flash.display.Graphics.prototype.flash_display_Graphics_pathPool = null;


/**
 * @private
 * @type {number}
 */
flash.display.Graphics.prototype.flash_display_Graphics_pathPoolPos = 0;


/**
 * @private
 * @type {flash.display.GraphicsPath}
 */
flash.display.Graphics.prototype.flash_display_Graphics_lastPath = null;


/**
 * @private
 * @type {flash.geom.Rectangle}
 */
flash.display.Graphics.prototype.flash_display_Graphics__bound = null;


/**
 * @private
 * @type {flash.geom.Rectangle}
 */
flash.display.Graphics.prototype.flash_display_Graphics__rect = null;


/**
 * @private
 * @type {boolean}
 */
flash.display.Graphics.prototype.flash_display_Graphics_lockBound = false;


/**
 * @nocollapse
 * @type {boolean}
 */
flash.display.Graphics.debug = false;


/**
 * @type {flash.geom.Matrix}
 */
flash.display.Graphics.prototype._worldMatrix = null;


/**
 */
flash.display.Graphics.prototype.clear = function() {
  SpriteFlexjs.dirtyGraphics = true;
  this.lastStroke = null;
  this.flash_display_Graphics_lastPath = null;
  this.flash_display_Graphics_pathPoolPos = 0;
  this.graphicsData = new (org.apache.royale.utils.Language.synthVector('flash.display.IGraphicsData'))();
  this.flash_display_Graphics__bound = null;
};


/**
 * @param {number} color
 * @param {number=} alpha
 */
flash.display.Graphics.prototype.beginFill = function(color, alpha) {
  alpha = typeof alpha !== 'undefined' ? alpha : 1.0;
  this.endStrokAndFill();
  this.lastFill = new flash.display.GraphicsSolidFill(color, alpha);
  this.graphicsData.push(this.lastFill);
};


/**
 * @param {string} type
 * @param {Array} colors
 * @param {Array} alphas
 * @param {Array} ratios
 * @param {*=} matrix
 * @param {string=} spreadMethod
 * @param {string=} interpolationMethod
 * @param {number=} focalPointRatio
 */
flash.display.Graphics.prototype.beginGradientFill = function(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
  matrix = typeof matrix !== 'undefined' ? matrix : null;
  spreadMethod = typeof spreadMethod !== 'undefined' ? spreadMethod : "pad";
  interpolationMethod = typeof interpolationMethod !== 'undefined' ? interpolationMethod : "rgb";
  focalPointRatio = typeof focalPointRatio !== 'undefined' ? focalPointRatio : 0;
  this.endStrokAndFill();
  this.lastFill = new flash.display.GraphicsGradientFill(type, colors, alphas, ratios, this.flash_display_Graphics__bound, matrix, spreadMethod, interpolationMethod, focalPointRatio);
  this.graphicsData.push(this.lastFill);
};


/**
 * @param {flash.display.BitmapData} bitmap
 * @param {flash.geom.Matrix=} matrix
 * @param {boolean=} repeat
 * @param {boolean=} smooth
 */
flash.display.Graphics.prototype.beginBitmapFill = function(bitmap, matrix, repeat, smooth) {
  matrix = typeof matrix !== 'undefined' ? matrix : null;
  repeat = typeof repeat !== 'undefined' ? repeat : true;
  smooth = typeof smooth !== 'undefined' ? smooth : false;
  this.endStrokAndFill();
  this.lastFill = new flash.display.GraphicsBitmapFill(bitmap, matrix, repeat, smooth);
  this.graphicsData.push(this.lastFill);
};


/**
 */
flash.display.Graphics.prototype.endStrokAndFill = function() {
  if (this.flash_display_Graphics_lastPath) {
    if (this.lastFill) {
      var /** @type {flash.display.GraphicsEndFill} */ efill = new flash.display.GraphicsEndFill();
      efill.fill = this.lastFill;
      this.graphicsData.push(efill);
      this.lastFill = null;
    }
    if (this.lastStroke && !isNaN(this.lastStroke.thickness)) {
      this.lastStroke = new flash.display.GraphicsStroke(NaN);
      this.graphicsData.push(this.lastStroke);
    }
    this.flash_display_Graphics_lastPath = null;
  }
};


/**
 * @param {string} type
 * @param {Array} colors
 * @param {Array} alphas
 * @param {Array} ratios
 * @param {*=} matrix
 * @param {string=} spreadMethod
 * @param {string=} interpolationMethod
 * @param {number=} focalPointRatio
 */
flash.display.Graphics.prototype.lineGradientStyle = function(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
  matrix = typeof matrix !== 'undefined' ? matrix : null;
  spreadMethod = typeof spreadMethod !== 'undefined' ? spreadMethod : "pad";
  interpolationMethod = typeof interpolationMethod !== 'undefined' ? interpolationMethod : "rgb";
  focalPointRatio = typeof focalPointRatio !== 'undefined' ? focalPointRatio : 0;
  if (this.lastStroke) {
    this.endFill();
    var /** @type {flash.display.GraphicsStroke} */ gs = this.lastStroke;
    gs.fill = new flash.display.GraphicsGradientFill(type, colors, alphas, ratios, this.flash_display_Graphics__bound, matrix, spreadMethod, interpolationMethod, focalPointRatio);
  }
};


/**
 * @param {number=} thickness
 * @param {number=} color
 * @param {number=} alpha
 * @param {boolean=} pixelHinting
 * @param {string=} scaleMode
 * @param {string=} caps
 * @param {string=} joints
 * @param {number=} miterLimit
 */
flash.display.Graphics.prototype.lineStyle = function(thickness, color, alpha, pixelHinting, scaleMode, caps, joints, miterLimit) {
  thickness = typeof thickness !== 'undefined' ? thickness : NaN;
  color = typeof color !== 'undefined' ? color : 0;
  alpha = typeof alpha !== 'undefined' ? alpha : 1.0;
  pixelHinting = typeof pixelHinting !== 'undefined' ? pixelHinting : false;
  scaleMode = typeof scaleMode !== 'undefined' ? scaleMode : "normal";
  caps = typeof caps !== 'undefined' ? caps : null;
  joints = typeof joints !== 'undefined' ? joints : null;
  miterLimit = typeof miterLimit !== 'undefined' ? miterLimit : 3;
  this.endStrokAndFill();
  if (!isNaN(thickness)) {
    this.lastStroke = new flash.display.GraphicsStroke(thickness === 0 ? 1 : thickness, pixelHinting, scaleMode, caps ? caps : "round", joints ? joints : "round", miterLimit, new flash.display.GraphicsSolidFill(color, alpha));
    this.graphicsData.push(this.lastStroke);
  }
};


/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 */
flash.display.Graphics.prototype.drawRect = function(x, y, width, height) {
  this.flash_display_Graphics_lockBound = true;
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.flash_display_Graphics_lastPath.closePath();
  this.flash_display_Graphics_lockBound = false;
  this.flash_display_Graphics_inflateBound(x, y);
  this.flash_display_Graphics_inflateBound(x + width, y + height);
};


/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} ellipseWidth
 * @param {number=} ellipseHeight
 */
flash.display.Graphics.prototype.drawRoundRect = function(x, y, width, height, ellipseWidth, ellipseHeight) {
  ellipseHeight = typeof ellipseHeight !== 'undefined' ? ellipseHeight : NaN;
  this.flash_display_Graphics_lockBound = true;
  if (isNaN(ellipseHeight))
    ellipseHeight = ellipseWidth;
  this.moveTo(x + ellipseWidth, y);
  this.lineTo(x + width - ellipseWidth, y);
  this.curveTo(x + width, y, x + width, y + ellipseHeight);
  this.lineTo(x + width, y + height - ellipseHeight);
  this.curveTo(x + width, y + height, x + width - ellipseWidth, y + height);
  this.lineTo(x + ellipseWidth, y + height);
  this.curveTo(x, y + height, x, y + height - ellipseHeight);
  this.lineTo(x, y + ellipseHeight);
  this.curveTo(x, y, x + ellipseWidth, y);
  this.flash_display_Graphics_lockBound = false;
  this.flash_display_Graphics_inflateBound(x, y);
  this.flash_display_Graphics_inflateBound(x + width, y + height);
};


/**
 * @param {number} x
 * @param {number} y
 * @param {number} width
 * @param {number} height
 * @param {number} topLeftRadius
 * @param {number} topRightRadius
 * @param {number} bottomLeftRadius
 * @param {number} bottomRightRadius
 */
flash.display.Graphics.prototype.drawRoundRectComplex = function(x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
  this.flash_display_Graphics_lockBound = true;
  this.moveTo(x + topLeftRadius, y);
  this.lineTo(x + width - topRightRadius, y);
  this.curveTo(x + width, y, x + width, y + topRightRadius);
  this.lineTo(x + width, y + height - bottomRightRadius);
  this.curveTo(x + width, y + height, x + width - bottomRightRadius, y + height);
  this.lineTo(x + bottomLeftRadius, y + height);
  this.curveTo(x, y + height, x, y + height - bottomLeftRadius);
  this.lineTo(x, y + topLeftRadius);
  this.curveTo(x, y, x + topLeftRadius, y);
  this.flash_display_Graphics_lockBound = false;
  this.flash_display_Graphics_inflateBound(x, y);
  this.flash_display_Graphics_inflateBound(x + width, y + height);
};


/**
 * @param {number} x
 * @param {number} y
 * @param {number} radius
 */
flash.display.Graphics.prototype.drawCircle = function(x, y, radius) {
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.moveTo(x + radius, y);
  this.flash_display_Graphics_lastPath.arc(x, y, radius, 0, Math.PI * 2);
  this.flash_display_Graphics_inflateBound(x - radius, y - radius);
  this.flash_display_Graphics_inflateBound(x + radius, y + radius);
};


/**
 * @param {number} x
 * @param {number} y
 * @param {number} w
 * @param {number} h
 */
flash.display.Graphics.prototype.drawEllipse = function(x, y, w, h) {
  this.flash_display_Graphics_lockBound = true;
  var /** @type {number} */ kappa = .5522848, /** @type {number} */ ox = (w / 2) * kappa, /** @type {number} */ oy = (h / 2) * kappa, /** @type {number} */ xe = x + w, /** @type {number} */ ye = y + h, /** @type {number} */ xm = x + w / 2, /** @type {number} */ ym = y + h / 2;
  this.moveTo(x, ym);
  this.cubicCurveTo(x, ym - oy, xm - ox, y, xm, y);
  this.cubicCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
  this.cubicCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
  this.cubicCurveTo(xm - ox, ye, x, ym + oy, x, ym);
  this.flash_display_Graphics_lockBound = false;
  this.flash_display_Graphics_inflateBound(x, y);
  this.flash_display_Graphics_inflateBound(x + w, y + h);
};


/**
 * @param {number} x
 * @param {number} y
 */
flash.display.Graphics.prototype.moveTo = function(x, y) {
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.moveTo(x, y);
  this.flash_display_Graphics_inflateBound(x, y);
};


/**
 * @param {number} x
 * @param {number} y
 */
flash.display.Graphics.prototype.lineTo = function(x, y) {
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.lineTo(x, y);
  this.flash_display_Graphics_inflateBound(x, y);
};


/**
 * @param {number} controlX
 * @param {number} controlY
 * @param {number} anchorX
 * @param {number} anchorY
 */
flash.display.Graphics.prototype.curveTo = function(controlX, controlY, anchorX, anchorY) {
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.curveTo(controlX, controlY, anchorX, anchorY);
  this.flash_display_Graphics_inflateBound(controlX, controlY);
  this.flash_display_Graphics_inflateBound(anchorX, anchorY);
};


/**
 * @param {number} controlX1
 * @param {number} controlY1
 * @param {number} controlX2
 * @param {number} controlY2
 * @param {number} anchorX
 * @param {number} anchorY
 */
flash.display.Graphics.prototype.cubicCurveTo = function(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.cubicCurveTo(controlX1, controlY1, controlX2, controlY2, anchorX, anchorY);
  this.flash_display_Graphics_inflateBound(controlX1, controlY1);
  this.flash_display_Graphics_inflateBound(controlX2, controlY2);
  this.flash_display_Graphics_inflateBound(anchorX, anchorY);
};


/**
 * @private
 * @param {number} x
 * @param {number} y
 */
flash.display.Graphics.prototype.flash_display_Graphics_inflateBound = function(x, y) {
  if (this.flash_display_Graphics_lockBound)
    return;
  if (this.flash_display_Graphics__bound == null) {
    this.flash_display_Graphics__bound = new flash.geom.Rectangle(Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
    this.flash_display_Graphics__rect = new flash.geom.Rectangle(Number.MAX_VALUE, Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  }
  if (this.flash_display_Graphics__bound.left > x) {
    this.flash_display_Graphics__bound.left = x;
    this.flash_display_Graphics__rect.left = x;
    if (this.lastStroke)
      this.flash_display_Graphics__bound.left -= this.lastStroke.thickness / 2;
  }
  if (this.flash_display_Graphics__bound.right < x) {
    this.flash_display_Graphics__bound.right = x;
    this.flash_display_Graphics__rect.right = x;
    if (this.lastStroke)
      this.flash_display_Graphics__bound.right += this.lastStroke.thickness / 2;
  }
  if (this.flash_display_Graphics__bound.top > y) {
    this.flash_display_Graphics__bound.top = y;
    this.flash_display_Graphics__rect.top = y;
    if (this.lastStroke)
      this.flash_display_Graphics__bound.top -= this.lastStroke.thickness / 2;
  }
  if (this.flash_display_Graphics__bound.bottom < y) {
    this.flash_display_Graphics__bound.bottom = y;
    this.flash_display_Graphics__rect.bottom = y;
    if (this.lastStroke)
      this.flash_display_Graphics__bound.bottom += this.lastStroke.thickness / 2;
  }
  if (this.lastFill && org.apache.royale.utils.Language.is(this.lastFill, flash.display.GraphicsGradientFill))
    org.apache.royale.utils.Language.as(this.lastFill, flash.display.GraphicsGradientFill, true).bounds = this.flash_display_Graphics__bound;
  if (this.lastStroke && org.apache.royale.utils.Language.is(this.lastStroke.fill, flash.display.GraphicsGradientFill))
    org.apache.royale.utils.Language.as(this.lastStroke.fill, flash.display.GraphicsGradientFill, true).bounds = this.flash_display_Graphics__bound;
};


/**
 * @private
 */
flash.display.Graphics.prototype.flash_display_Graphics_makePath = function() {
  if (this.flash_display_Graphics_lastPath == null) {
    var /** @type {boolean} */ isInitial = false;
    this.flash_display_Graphics_lastPath = /* implicit cast */ org.apache.royale.utils.Language.as(this.flash_display_Graphics_pathPool[this.flash_display_Graphics_pathPoolPos], flash.display.GraphicsPath, true);
    if (this.flash_display_Graphics_lastPath == null) {
      this.flash_display_Graphics_lastPath = /* implicit cast */ org.apache.royale.utils.Language.as(this.flash_display_Graphics_pathPool[this.flash_display_Graphics_pathPoolPos] = SpriteFlexjs.renderer.createPath(), flash.display.GraphicsPath, true);
      isInitial = true;
    }
    this.flash_display_Graphics_lastPath.clear();
    this.flash_display_Graphics_lastPath.gpuPath2DDirty = true;
    if (isInitial)
      this.flash_display_Graphics_lastPath.moveTo(0, 0);
    this.flash_display_Graphics_pathPoolPos++;
    this.graphicsData.push(this.flash_display_Graphics_lastPath);
  }
  SpriteFlexjs.dirtyGraphics = true;
};


/**
 */
flash.display.Graphics.prototype.endFill = function() {
  this.endStrokAndFill();
};


/**
 * @param {flash.display.Graphics} g
 */
flash.display.Graphics.prototype.copyFrom = function(g) {
  this.graphicsData = g.graphicsData.slice();
};


/**
 * @param {flash.display.BitmapData} bitmap
 * @param {flash.geom.Matrix=} matrix
 * @param {boolean=} repeat
 * @param {boolean=} smooth
 */
flash.display.Graphics.prototype.lineBitmapStyle = function(bitmap, matrix, repeat, smooth) {
  matrix = typeof matrix !== 'undefined' ? matrix : null;
  repeat = typeof repeat !== 'undefined' ? repeat : true;
  smooth = typeof smooth !== 'undefined' ? smooth : false;
  if (this.lastStroke && org.apache.royale.utils.Language.is(this.lastStroke, flash.display.GraphicsStroke)) {
    var /** @type {flash.display.GraphicsStroke} */ gs = this.lastStroke;
    gs.fill = new flash.display.GraphicsBitmapFill(bitmap, matrix, repeat, smooth);
  }
};


/**
 * @param {Array.<number>} commands
 * @param {Array.<number>} data
 * @param {string=} winding
 */
flash.display.Graphics.prototype.drawPath = function(commands, data, winding) {
  winding = typeof winding !== 'undefined' ? winding : "evenOdd";
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.commands.push.apply(null, commands);
  this.flash_display_Graphics_lastPath.data.push.apply(null, data);
};


/**
 * @param {Array.<number>} vertices
 * @param {Array.<number>=} indices
 * @param {Array.<number>=} uvtData
 * @param {string=} culling
 */
flash.display.Graphics.prototype.drawTriangles = function(vertices, indices, uvtData, culling) {
  indices = typeof indices !== 'undefined' ? indices : null;
  uvtData = typeof uvtData !== 'undefined' ? uvtData : null;
  culling = typeof culling !== 'undefined' ? culling : "none";
  this.flash_display_Graphics_makePath();
  this.flash_display_Graphics_lastPath.drawTriangles(vertices, indices, uvtData);
};


/**
 * @private
 * @param {flash.display.IGraphicsPath} path
 */
flash.display.Graphics.prototype.flash_display_Graphics_drawPathObject = function(path) {
  var /** @type {flash.display.GraphicsPath} */ graphicsPath = null;
  var /** @type {flash.display.GraphicsTrianglePath} */ graphicsTrianglePath = null;
  if (org.apache.royale.utils.Language.is(path, flash.display.GraphicsPath)) {
    graphicsPath = org.apache.royale.utils.Language.as(path, flash.display.GraphicsPath, true);
    this.drawPath(graphicsPath.commands, graphicsPath.data, graphicsPath.winding);
  } else if (org.apache.royale.utils.Language.is(path, flash.display.GraphicsTrianglePath)) {
    graphicsTrianglePath = org.apache.royale.utils.Language.as(path, flash.display.GraphicsTrianglePath, true);
    this.drawTriangles(graphicsTrianglePath.vertices, graphicsTrianglePath.indices, graphicsTrianglePath.uvtData, graphicsTrianglePath.culling);
  }
};


/**
 * @private
 * @param {flash.display.IGraphicsFill} fill
 */
flash.display.Graphics.prototype.flash_display_Graphics_beginFillObject = function(fill) {
  var /** @type {flash.display.GraphicsSolidFill} */ solidFill = null;
  var /** @type {flash.display.GraphicsGradientFill} */ gradientFill = null;
  var /** @type {flash.display.GraphicsBitmapFill} */ bitmapFill = null;
  if (fill == null) {
    this.endFill();
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsEndFill)) {
    this.endFill();
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsSolidFill)) {
    solidFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsSolidFill, true);
    this.beginFill(solidFill.color, solidFill.alpha);
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsGradientFill)) {
    gradientFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsGradientFill, true);
    this.beginGradientFill(gradientFill.type, gradientFill.colors, gradientFill.alphas, gradientFill.ratios, gradientFill.matrix, gradientFill.spreadMethod, gradientFill.interpolationMethod, gradientFill.focalPointRatio);
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsBitmapFill)) {
    bitmapFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsBitmapFill, true);
    this.beginBitmapFill(bitmapFill.bitmapData, bitmapFill.matrix, bitmapFill.repeat, bitmapFill.smooth);
  }
};


/**
 * @private
 * @param {flash.display.IGraphicsStroke} istroke
 */
flash.display.Graphics.prototype.flash_display_Graphics_beginStrokeObject = function(istroke) {
  var /** @type {flash.display.GraphicsSolidFill} */ solidFill = null;
  var /** @type {flash.display.GraphicsGradientFill} */ gradientFill = null;
  var /** @type {flash.display.GraphicsBitmapFill} */ bitmapFill = null;
  var /** @type {flash.display.GraphicsStroke} */ stroke = null;
  var /** @type {flash.display.IGraphicsFill} */ fill = null;
  if (istroke != null && org.apache.royale.utils.Language.is(istroke, flash.display.GraphicsStroke)) {
    stroke = istroke;
  }
  if (stroke && stroke.fill && org.apache.royale.utils.Language.is(stroke.fill, flash.display.IGraphicsFill)) {
    fill = stroke.fill;
  }
  if (stroke == null || fill == null) {
    this.lineStyle();
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsSolidFill)) {
    solidFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsSolidFill, true);
    this.lineStyle(stroke.thickness, solidFill.color, solidFill.alpha, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsGradientFill)) {
    gradientFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsGradientFill, true);
    this.lineStyle(stroke.thickness, 0, 1, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
    this.lineGradientStyle(gradientFill.type, gradientFill.colors, gradientFill.alphas, gradientFill.ratios, gradientFill.matrix, gradientFill.spreadMethod, gradientFill.interpolationMethod, gradientFill.focalPointRatio);
  } else if (org.apache.royale.utils.Language.is(fill, flash.display.GraphicsBitmapFill)) {
    bitmapFill = org.apache.royale.utils.Language.as(fill, flash.display.GraphicsBitmapFill, true);
    this.lineStyle(stroke.thickness, 0, 1, stroke.pixelHinting, stroke.scaleMode, stroke.caps, stroke.joints, stroke.miterLimit);
    this.lineBitmapStyle(bitmapFill.bitmapData, bitmapFill.matrix, bitmapFill.repeat, bitmapFill.smooth);
  }
};


/**
 * @param {Array.<IGraphicsData>} graphicsData
 */
flash.display.Graphics.prototype.drawGraphicsData = function(graphicsData) {
  var /** @type {flash.display.IGraphicsData} */ item = null;
  var /** @type {flash.display.IGraphicsPath} */ path = null;
  var /** @type {flash.display.IGraphicsFill} */ fill = null;
  var /** @type {flash.display.IGraphicsStroke} */ stroke = null;
  if (graphicsData == null) {
    return;
  }
  for (var /** @type {number} */ i = 0; i < graphicsData.length; i++) {
    item = graphicsData[graphicsData[org.apache.royale.utils.Language.CHECK_INDEX](i)];
    if (org.apache.royale.utils.Language.is(item, flash.display.IGraphicsPath)) {
      path = org.apache.royale.utils.Language.as(item, flash.display.IGraphicsPath, true);
      this.flash_display_Graphics_drawPathObject(path);
    } else if (org.apache.royale.utils.Language.is(item, flash.display.IGraphicsFill)) {
      fill = org.apache.royale.utils.Language.as(item, flash.display.IGraphicsFill, true);
      this.flash_display_Graphics_beginFillObject(fill);
    } else if (org.apache.royale.utils.Language.is(item, flash.display.IGraphicsStroke)) {
      stroke = org.apache.royale.utils.Language.as(item, flash.display.IGraphicsStroke, true);
      this.flash_display_Graphics_beginStrokeObject(stroke);
    }
  }
};


/**
 * @param {boolean=} recurse
 * @return {Array.<IGraphicsData>}
 */
flash.display.Graphics.prototype.readGraphicsData = function(recurse) {
  recurse = typeof recurse !== 'undefined' ? recurse : true;
  return this.graphicsData.slice();
};


/**
 * @param {CanvasRenderingContext2D} ctx
 * @param {flash.geom.Matrix} m
 * @param {string} blendMode
 * @param {flash.geom.ColorTransform} colorTransform
 * @param {boolean=} useCache
 * @param {flash.display.BitmapData=} cacheImage
 */
flash.display.Graphics.prototype.draw = function(ctx, m, blendMode, colorTransform, useCache, cacheImage) {
  useCache = typeof useCache !== 'undefined' ? useCache : false;
  cacheImage = typeof cacheImage !== 'undefined' ? cacheImage : null;
  if (this.graphicsData.length || useCache) {
    if (useCache) {
      SpriteFlexjs.renderer.renderImage(ctx, cacheImage, m, blendMode, colorTransform);
    } else {
      SpriteFlexjs.renderer.renderGraphics(ctx, this, m, blendMode, colorTransform);
    }
    SpriteFlexjs.drawCounter++;
  }
};


flash.display.Graphics.prototype.get__rect = function() {
  return this.flash_display_Graphics__rect;
};


flash.display.Graphics.prototype.get__bound = function() {
  return this.flash_display_Graphics__bound;
};


Object.defineProperties(flash.display.Graphics.prototype, /** @lends {flash.display.Graphics.prototype} */ {
/**
 * @type {flash.geom.Rectangle}
 */
rect: {
get: flash.display.Graphics.prototype.get__rect},
/**
 * @type {flash.geom.Rectangle}
 */
bound: {
get: flash.display.Graphics.prototype.get__bound}}
);


/**
 * Metadata
 *
 * @type {Object.<string, Array.<Object>>}
 */
flash.display.Graphics.prototype.ROYALE_CLASS_INFO = { names: [{ name: 'Graphics', qName: 'flash.display.Graphics', kind: 'class' }] };



/**
 * Reflection
 *
 * @return {Object.<string, Function>}
 */
flash.display.Graphics.prototype.ROYALE_REFLECTION_INFO = function () {
  return {
    variables: function () {
      return {
        'graphicsData': { type: 'Vector.<flash.display.IGraphicsData>', get_set: function (/** flash.display.Graphics */ inst, /** * */ v) {return v !== undefined ? inst.graphicsData = v : inst.graphicsData;}},
        'gradientFills': { type: 'Vector.<flash.display.GraphicsGradientFill>', get_set: function (/** flash.display.Graphics */ inst, /** * */ v) {return v !== undefined ? inst.gradientFills = v : inst.gradientFills;}},
        'lastStroke': { type: 'flash.display.GraphicsStroke', get_set: function (/** flash.display.Graphics */ inst, /** * */ v) {return v !== undefined ? inst.lastStroke = v : inst.lastStroke;}},
        'lastFill': { type: 'flash.display.IGraphicsFill', get_set: function (/** flash.display.Graphics */ inst, /** * */ v) {return v !== undefined ? inst.lastFill = v : inst.lastFill;}},
        '|debug': { type: 'Boolean', get_set: function (/** * */ v) {return v !== undefined ? flash.display.Graphics.debug = v : flash.display.Graphics.debug;}},
        '_worldMatrix': { type: 'flash.geom.Matrix', get_set: function (/** flash.display.Graphics */ inst, /** * */ v) {return v !== undefined ? inst._worldMatrix = v : inst._worldMatrix;}}
      };
    },
    accessors: function () {
      return {
        'rect': { type: 'flash.geom.Rectangle', access: 'readonly', declaredBy: 'flash.display.Graphics'},
        'bound': { type: 'flash.geom.Rectangle', access: 'readonly', declaredBy: 'flash.display.Graphics'}
      };
    },
    methods: function () {
      return {
        'Graphics': { type: '', declaredBy: 'flash.display.Graphics'},
        'clear': { type: 'void', declaredBy: 'flash.display.Graphics'},
        'beginFill': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'uint', false ,'Number', true ]; }},
        'beginGradientFill': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'String', false ,'Array', false ,'Array', false ,'Array', false ,'*', true ,'String', true ,'String', true ,'Number', true ]; }},
        'beginBitmapFill': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'flash.display.BitmapData', false ,'flash.geom.Matrix', true ,'Boolean', true ,'Boolean', true ]; }},
        'endStrokAndFill': { type: 'void', declaredBy: 'flash.display.Graphics'},
        'lineGradientStyle': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'String', false ,'Array', false ,'Array', false ,'Array', false ,'*', true ,'String', true ,'String', true ,'Number', true ]; }},
        'lineStyle': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', true ,'uint', true ,'Number', true ,'Boolean', true ,'String', true ,'String', true ,'String', true ,'Number', true ]; }},
        'drawRect': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ]; }},
        'drawRoundRect': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', true ]; }},
        'drawRoundRectComplex': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ]; }},
        'drawCircle': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ]; }},
        'drawEllipse': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ]; }},
        'moveTo': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'lineTo': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ]; }},
        'curveTo': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ]; }},
        'cubicCurveTo': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ,'Number', false ]; }},
        'endFill': { type: 'void', declaredBy: 'flash.display.Graphics'},
        'copyFrom': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'flash.display.Graphics', false ]; }},
        'lineBitmapStyle': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'flash.display.BitmapData', false ,'flash.geom.Matrix', true ,'Boolean', true ,'Boolean', true ]; }},
        'drawPath': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Vector.<int>', false ,'Vector.<Number>', false ,'String', true ]; }},
        'drawTriangles': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Vector.<Number>', false ,'Vector.<int>', true ,'Vector.<Number>', true ,'String', true ]; }},
        'drawGraphicsData': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Vector.<flash.display.IGraphicsData>', false ]; }},
        'readGraphicsData': { type: 'Vector.<flash.display.IGraphicsData>', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'Boolean', true ]; }},
        'draw': { type: 'void', declaredBy: 'flash.display.Graphics', parameters: function () { return [ 'CanvasRenderingContext2D', false ,'flash.geom.Matrix', false ,'String', false ,'flash.geom.ColorTransform', false ,'Boolean', true ,'flash.display.BitmapData', true ]; }}
      };
    }
  };
};
/**
 * @const
 * @type {number}
 */
flash.display.Graphics.prototype.ROYALE_COMPILE_FLAGS = 9;
/**
 * Provide reflection support for distinguishing dynamic fields on class object (static)
 * @const
 * @type {Array<string>}
 */
flash.display.Graphics.prototype.ROYALE_INITIAL_STATICS = Object.keys(flash.display.Graphics);
